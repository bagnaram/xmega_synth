   1               		.file	"ff.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  59               	mem_cpy:
  60               		.stabd	46,0,0
   1:ff.c          **** /*----------------------------------------------------------------------------/
   2:ff.c          **** /  FatFs - FAT file system module  R0.09b                 (C)ChaN, 2013
   3:ff.c          **** /-----------------------------------------------------------------------------/
   4:ff.c          **** / FatFs module is a generic FAT file system module for small embedded systems.
   5:ff.c          **** / This is a free software that opened for education, research and commercial
   6:ff.c          **** / developments under license policy of following terms.
   7:ff.c          **** /
   8:ff.c          **** /  Copyright (C) 2013, ChaN, all right reserved.
   9:ff.c          **** /
  10:ff.c          **** / * The FatFs module is a free software and there is NO WARRANTY.
  11:ff.c          **** / * No restriction on use. You can use, modify and redistribute it for
  12:ff.c          **** /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
  13:ff.c          **** / * Redistributions of source code must retain the above copyright notice.
  14:ff.c          **** /
  15:ff.c          **** /-----------------------------------------------------------------------------/
  16:ff.c          **** / Feb 26,'06 R0.00  Prototype.
  17:ff.c          **** /
  18:ff.c          **** / Apr 29,'06 R0.01  First stable version.
  19:ff.c          **** /
  20:ff.c          **** / Jun 01,'06 R0.02  Added FAT12 support.
  21:ff.c          **** /                   Removed unbuffered mode.
  22:ff.c          **** /                   Fixed a problem on small (<32M) partition.
  23:ff.c          **** / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
  24:ff.c          **** /
  25:ff.c          **** / Sep 22,'06 R0.03  Added f_rename().
  26:ff.c          **** /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
  27:ff.c          **** / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
  28:ff.c          **** /                   Fixed f_mkdir() creates incorrect directory on FAT32.
  29:ff.c          **** /
  30:ff.c          **** / Feb 04,'07 R0.04  Supported multiple drive system.
  31:ff.c          **** /                   Changed some interfaces for multiple drive system.
  32:ff.c          **** /                   Changed f_mountdrv() to f_mount().
  33:ff.c          **** /                   Added f_mkfs().
  34:ff.c          **** / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
  35:ff.c          **** /                   Added a capability of extending file size to f_lseek().
  36:ff.c          **** /                   Added minimization level 3.
  37:ff.c          **** /                   Fixed an endian sensitive code in f_mkfs().
  38:ff.c          **** / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
  39:ff.c          **** /                   Added FSInfo support.
  40:ff.c          **** /                   Fixed DBCS name can result FR_INVALID_NAME.
  41:ff.c          **** /                   Fixed short seek (<= csize) collapses the file object.
  42:ff.c          **** /
  43:ff.c          **** / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
  44:ff.c          **** /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
  45:ff.c          **** /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
  46:ff.c          **** / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
  47:ff.c          **** /                   Fixed off by one error at FAT sub-type determination.
  48:ff.c          **** /                   Fixed btr in f_read() can be mistruncated.
  49:ff.c          **** /                   Fixed cached sector is not flushed when create and close without write.
  50:ff.c          **** /
  51:ff.c          **** / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
  52:ff.c          **** /                   Improved performance of f_lseek() on moving to the same or following cluster.
  53:ff.c          **** /
  54:ff.c          **** / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
  55:ff.c          **** /                   Added long file name feature.
  56:ff.c          **** /                   Added multiple code page feature.
  57:ff.c          **** /                   Added re-entrancy for multitask operation.
  58:ff.c          **** /                   Added auto cluster size selection to f_mkfs().
  59:ff.c          **** /                   Added rewind option to f_readdir().
  60:ff.c          **** /                   Changed result code of critical errors.
  61:ff.c          **** /                   Renamed string functions to avoid name collision.
  62:ff.c          **** / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
  63:ff.c          **** /                   Added multiple sector size feature.
  64:ff.c          **** / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
  65:ff.c          **** /                   Fixed wrong cache control in f_lseek().
  66:ff.c          **** /                   Added relative path feature.
  67:ff.c          **** /                   Added f_chdir() and f_chdrive().
  68:ff.c          **** /                   Added proper case conversion to extended char.
  69:ff.c          **** / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
  70:ff.c          **** /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
  71:ff.c          **** /                   Fixed name matching error on the 13 char boundary.
  72:ff.c          **** /                   Added a configuration option, _LFN_UNICODE.
  73:ff.c          **** /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
  74:ff.c          **** /
  75:ff.c          **** / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
  76:ff.c          **** /                   Added file lock feature. (_FS_SHARE)
  77:ff.c          **** /                   Added fast seek feature. (_USE_FASTSEEK)
  78:ff.c          **** /                   Changed some types on the API, XCHAR->TCHAR.
  79:ff.c          **** /                   Changed fname member in the FILINFO structure on Unicode cfg.
  80:ff.c          **** /                   String functions support UTF-8 encoding files on Unicode cfg.
  81:ff.c          **** / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
  82:ff.c          **** /                   Added sector erase feature. (_USE_ERASE)
  83:ff.c          **** /                   Moved file lock semaphore table from fs object to the bss.
  84:ff.c          **** /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name con
  85:ff.c          **** /                   Fixed f_mkfs() creates wrong FAT32 volume.
  86:ff.c          **** / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
  87:ff.c          **** /                   f_lseek() reports required table size on creating CLMP.
  88:ff.c          **** /                   Extended format syntax of f_printf function.
  89:ff.c          **** /                   Ignores duplicated directory separators in given path name.
  90:ff.c          **** /
  91:ff.c          **** / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
  92:ff.c          **** /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
  93:ff.c          **** / Aug 27,'12 R0.09a Fixed assertion failure due to OS/2 EA on FAT12/16 volume.
  94:ff.c          **** /                   Changed f_open() and f_opendir reject null object pointer to avoid crash.
  95:ff.c          **** /                   Changed option name _FS_SHARE to _FS_LOCK.
  96:ff.c          **** / Jan 24,'13 R0.09b Added f_setlabel() and f_getlabel(). (_USE_LABEL = 1)
  97:ff.c          **** /---------------------------------------------------------------------------*/
  98:ff.c          **** 
  99:ff.c          **** #include "ff.h"			/* FatFs configurations and declarations */
 100:ff.c          **** #include "diskio.h"		/* Declarations of low level disk I/O functions */
 101:ff.c          **** 
 102:ff.c          **** 
 103:ff.c          **** /*--------------------------------------------------------------------------
 104:ff.c          **** 
 105:ff.c          ****    Module Private Definitions
 106:ff.c          **** 
 107:ff.c          **** ---------------------------------------------------------------------------*/
 108:ff.c          **** 
 109:ff.c          **** #if _FATFS != 82786	/* Revision ID */
 110:ff.c          **** #error Wrong include file (ff.h).
 111:ff.c          **** #endif
 112:ff.c          **** 
 113:ff.c          **** 
 114:ff.c          **** /* Definitions on sector size */
 115:ff.c          **** #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
 116:ff.c          **** #error Wrong sector size.
 117:ff.c          **** #endif
 118:ff.c          **** #if _MAX_SS != 512
 119:ff.c          **** #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
 120:ff.c          **** #else
 121:ff.c          **** #define	SS(fs)	512U			/* Fixed sector size */
 122:ff.c          **** #endif
 123:ff.c          **** 
 124:ff.c          **** 
 125:ff.c          **** /* Reentrancy related */
 126:ff.c          **** #if _FS_REENTRANT
 127:ff.c          **** #if _USE_LFN == 1
 128:ff.c          **** #error Static LFN work area must not be used in re-entrant configuration.
 129:ff.c          **** #endif
 130:ff.c          **** #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
 131:ff.c          **** #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
 132:ff.c          **** #else
 133:ff.c          **** #define	ENTER_FF(fs)
 134:ff.c          **** #define LEAVE_FF(fs, res)	return res
 135:ff.c          **** #endif
 136:ff.c          **** 
 137:ff.c          **** #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
 138:ff.c          **** 
 139:ff.c          **** 
 140:ff.c          **** /* File access control feature */
 141:ff.c          **** #if _FS_LOCK
 142:ff.c          **** #if _FS_READONLY
 143:ff.c          **** #error _FS_LOCK must be 0 on read-only cfg.
 144:ff.c          **** #endif
 145:ff.c          **** typedef struct {
 146:ff.c          **** 	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
 147:ff.c          **** 	DWORD clu;				/* File ID 2, directory */
 148:ff.c          **** 	WORD idx;				/* File ID 3, directory index */
 149:ff.c          **** 	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
 150:ff.c          **** } FILESEM;
 151:ff.c          **** #endif
 152:ff.c          **** 
 153:ff.c          **** 
 154:ff.c          **** 
 155:ff.c          **** /* DBCS code ranges and SBCS extend char conversion table */
 156:ff.c          **** 
 157:ff.c          **** #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
 158:ff.c          **** #define _DF1S	0x81	/* DBC 1st byte range 1 start */
 159:ff.c          **** #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
 160:ff.c          **** #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
 161:ff.c          **** #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
 162:ff.c          **** #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
 163:ff.c          **** #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
 164:ff.c          **** #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
 165:ff.c          **** #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
 166:ff.c          **** 
 167:ff.c          **** #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
 168:ff.c          **** #define _DF1S	0x81
 169:ff.c          **** #define _DF1E	0xFE
 170:ff.c          **** #define _DS1S	0x40
 171:ff.c          **** #define _DS1E	0x7E
 172:ff.c          **** #define _DS2S	0x80
 173:ff.c          **** #define _DS2E	0xFE
 174:ff.c          **** 
 175:ff.c          **** #elif _CODE_PAGE == 949	/* Korean */
 176:ff.c          **** #define _DF1S	0x81
 177:ff.c          **** #define _DF1E	0xFE
 178:ff.c          **** #define _DS1S	0x41
 179:ff.c          **** #define _DS1E	0x5A
 180:ff.c          **** #define _DS2S	0x61
 181:ff.c          **** #define _DS2E	0x7A
 182:ff.c          **** #define _DS3S	0x81
 183:ff.c          **** #define _DS3E	0xFE
 184:ff.c          **** 
 185:ff.c          **** #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
 186:ff.c          **** #define _DF1S	0x81
 187:ff.c          **** #define _DF1E	0xFE
 188:ff.c          **** #define _DS1S	0x40
 189:ff.c          **** #define _DS1E	0x7E
 190:ff.c          **** #define _DS2S	0xA1
 191:ff.c          **** #define _DS2E	0xFE
 192:ff.c          **** 
 193:ff.c          **** #elif _CODE_PAGE == 437	/* U.S. (OEM) */
 194:ff.c          **** #define _DF1S	0
 195:ff.c          **** #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x9
 196:ff.c          **** 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,
 197:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 198:ff.c          **** 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 199:ff.c          **** 
 200:ff.c          **** #elif _CODE_PAGE == 720	/* Arabic (OEM) */
 201:ff.c          **** #define _DF1S	0
 202:ff.c          **** #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x9
 203:ff.c          **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 204:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 205:ff.c          **** 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 206:ff.c          **** 
 207:ff.c          **** #elif _CODE_PAGE == 737	/* Greek (OEM) */
 208:ff.c          **** #define _DF1S	0
 209:ff.c          **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 210:ff.c          **** 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,
 211:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 212:ff.c          **** 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 213:ff.c          **** 
 214:ff.c          **** #elif _CODE_PAGE == 775	/* Baltic (OEM) */
 215:ff.c          **** #define _DF1S	0
 216:ff.c          **** #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x9
 217:ff.c          **** 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 218:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,
 219:ff.c          **** 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 220:ff.c          **** 
 221:ff.c          **** #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
 222:ff.c          **** #define _DF1S	0
 223:ff.c          **** #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x9
 224:ff.c          **** 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,
 225:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 226:ff.c          **** 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 227:ff.c          **** 
 228:ff.c          **** #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
 229:ff.c          **** #define _DF1S	0
 230:ff.c          **** #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x9
 231:ff.c          **** 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,
 232:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,
 233:ff.c          **** 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,
 234:ff.c          **** 
 235:ff.c          **** #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
 236:ff.c          **** #define _DF1S	0
 237:ff.c          **** #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x9
 238:ff.c          **** 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 239:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,
 240:ff.c          **** 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,
 241:ff.c          **** 
 242:ff.c          **** #elif _CODE_PAGE == 857	/* Turkish (OEM) */
 243:ff.c          **** #define _DF1S	0
 244:ff.c          **** #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x9
 245:ff.c          **** 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,
 246:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 247:ff.c          **** 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,
 248:ff.c          **** 
 249:ff.c          **** #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
 250:ff.c          **** #define _DF1S	0
 251:ff.c          **** #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x9
 252:ff.c          **** 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,
 253:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,
 254:ff.c          **** 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 255:ff.c          **** 
 256:ff.c          **** #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
 257:ff.c          **** #define _DF1S	0
 258:ff.c          **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 259:ff.c          **** 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,
 260:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 261:ff.c          **** 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 262:ff.c          **** 
 263:ff.c          **** #elif _CODE_PAGE == 866	/* Russian (OEM) */
 264:ff.c          **** #define _DF1S	0
 265:ff.c          **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 266:ff.c          **** 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,
 267:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 268:ff.c          **** 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,
 269:ff.c          **** 
 270:ff.c          **** #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
 271:ff.c          **** #define _DF1S	0
 272:ff.c          **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 273:ff.c          **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 274:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 275:ff.c          **** 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 276:ff.c          **** 
 277:ff.c          **** #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
 278:ff.c          **** #define _DF1S	0
 279:ff.c          **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 280:ff.c          **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 281:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 282:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 283:ff.c          **** 
 284:ff.c          **** #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
 285:ff.c          **** #define _DF1S	0
 286:ff.c          **** #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x8
 287:ff.c          **** 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 288:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 289:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 290:ff.c          **** 
 291:ff.c          **** #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
 292:ff.c          **** #define _DF1S	0
 293:ff.c          **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 294:ff.c          **** 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 295:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 296:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 297:ff.c          **** 
 298:ff.c          **** #elif _CODE_PAGE == 1253 /* Greek (Windows) */
 299:ff.c          **** #define _DF1S	0
 300:ff.c          **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 301:ff.c          **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 302:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 303:ff.c          **** 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,
 304:ff.c          **** 
 305:ff.c          **** #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
 306:ff.c          **** #define _DF1S	0
 307:ff.c          **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 308:ff.c          **** 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 309:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 310:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 311:ff.c          **** 
 312:ff.c          **** #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
 313:ff.c          **** #define _DF1S	0
 314:ff.c          **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 315:ff.c          **** 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 316:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 317:ff.c          **** 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 318:ff.c          **** 
 319:ff.c          **** #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
 320:ff.c          **** #define _DF1S	0
 321:ff.c          **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 322:ff.c          **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 323:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 324:ff.c          **** 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,
 325:ff.c          **** 
 326:ff.c          **** #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
 327:ff.c          **** #define _DF1S	0
 328:ff.c          **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 329:ff.c          **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 330:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 331:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 332:ff.c          **** 
 333:ff.c          **** #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
 334:ff.c          **** #define _DF1S	0
 335:ff.c          **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 336:ff.c          **** 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 337:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 338:ff.c          **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,
 339:ff.c          **** 
 340:ff.c          **** #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
 341:ff.c          **** #if _USE_LFN
 342:ff.c          **** #error Cannot use LFN feature without valid code page.
 343:ff.c          **** #endif
 344:ff.c          **** #define _DF1S	0
 345:ff.c          **** 
 346:ff.c          **** #else
 347:ff.c          **** #error Unknown code page
 348:ff.c          **** 
 349:ff.c          **** #endif
 350:ff.c          **** 
 351:ff.c          **** 
 352:ff.c          **** /* Character code support macros */
 353:ff.c          **** #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
 354:ff.c          **** #define IsLower(c)	(((c)>='a')&&((c)<='z'))
 355:ff.c          **** #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
 356:ff.c          **** 
 357:ff.c          **** #if _DF1S		/* Code page is DBCS */
 358:ff.c          **** 
 359:ff.c          **** #ifdef _DF2S	/* Two 1st byte areas */
 360:ff.c          **** #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) 
 361:ff.c          **** #else			/* One 1st byte area */
 362:ff.c          **** #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
 363:ff.c          **** #endif
 364:ff.c          **** 
 365:ff.c          **** #ifdef _DS3S	/* Three 2nd byte areas */
 366:ff.c          **** #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) 
 367:ff.c          **** #else			/* Two 2nd byte areas */
 368:ff.c          **** #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) 
 369:ff.c          **** #endif
 370:ff.c          **** 
 371:ff.c          **** #else			/* Code page is SBCS */
 372:ff.c          **** 
 373:ff.c          **** #define IsDBCS1(c)	0
 374:ff.c          **** #define IsDBCS2(c)	0
 375:ff.c          **** 
 376:ff.c          **** #endif /* _DF1S */
 377:ff.c          **** 
 378:ff.c          **** 
 379:ff.c          **** /* Name status flags */
 380:ff.c          **** #define NS			11		/* Index of name status byte in fn[] */
 381:ff.c          **** #define NS_LOSS		0x01	/* Out of 8.3 format */
 382:ff.c          **** #define NS_LFN		0x02	/* Force to create LFN entry */
 383:ff.c          **** #define NS_LAST		0x04	/* Last segment */
 384:ff.c          **** #define NS_BODY		0x08	/* Lower case flag (body) */
 385:ff.c          **** #define NS_EXT		0x10	/* Lower case flag (ext) */
 386:ff.c          **** #define NS_DOT		0x20	/* Dot entry */
 387:ff.c          **** 
 388:ff.c          **** 
 389:ff.c          **** /* FAT sub-type boundaries */
 390:ff.c          **** /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
 391:ff.c          **** #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
 392:ff.c          **** #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
 393:ff.c          **** 
 394:ff.c          **** 
 395:ff.c          **** /* FatFs refers the members in the FAT structures as byte array instead of
 396:ff.c          **** / structure member because the structure is not binary compatible between
 397:ff.c          **** / different platforms */
 398:ff.c          **** 
 399:ff.c          **** #define BS_jmpBoot			0	/* Jump instruction (3) */
 400:ff.c          **** #define BS_OEMName			3	/* OEM name (8) */
 401:ff.c          **** #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
 402:ff.c          **** #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
 403:ff.c          **** #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
 404:ff.c          **** #define BPB_NumFATs			16	/* Number of FAT copies (1) */
 405:ff.c          **** #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
 406:ff.c          **** #define BPB_TotSec16		19	/* Volume size [sector] (2) */
 407:ff.c          **** #define BPB_Media			21	/* Media descriptor (1) */
 408:ff.c          **** #define BPB_FATSz16			22	/* FAT size [sector] (2) */
 409:ff.c          **** #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
 410:ff.c          **** #define BPB_NumHeads		26	/* Number of heads (2) */
 411:ff.c          **** #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
 412:ff.c          **** #define BPB_TotSec32		32	/* Volume size [sector] (4) */
 413:ff.c          **** #define BS_DrvNum			36	/* Physical drive number (2) */
 414:ff.c          **** #define BS_BootSig			38	/* Extended boot signature (1) */
 415:ff.c          **** #define BS_VolID			39	/* Volume serial number (4) */
 416:ff.c          **** #define BS_VolLab			43	/* Volume label (8) */
 417:ff.c          **** #define BS_FilSysType		54	/* File system type (1) */
 418:ff.c          **** #define BPB_FATSz32			36	/* FAT size [sector] (4) */
 419:ff.c          **** #define BPB_ExtFlags		40	/* Extended flags (2) */
 420:ff.c          **** #define BPB_FSVer			42	/* File system version (2) */
 421:ff.c          **** #define BPB_RootClus		44	/* Root dir first cluster (4) */
 422:ff.c          **** #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
 423:ff.c          **** #define BPB_BkBootSec		50	/* Offset of backup boot sector (2) */
 424:ff.c          **** #define BS_DrvNum32			64	/* Physical drive number (2) */
 425:ff.c          **** #define BS_BootSig32		66	/* Extended boot signature (1) */
 426:ff.c          **** #define BS_VolID32			67	/* Volume serial number (4) */
 427:ff.c          **** #define BS_VolLab32			71	/* Volume label (8) */
 428:ff.c          **** #define BS_FilSysType32		82	/* File system type (1) */
 429:ff.c          **** #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
 430:ff.c          **** #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
 431:ff.c          **** #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
 432:ff.c          **** #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
 433:ff.c          **** #define MBR_Table			446	/* MBR: Partition table offset (2) */
 434:ff.c          **** #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
 435:ff.c          **** #define BS_55AA				510	/* Boot sector signature (2) */
 436:ff.c          **** 
 437:ff.c          **** #define	DIR_Name			0	/* Short file name (11) */
 438:ff.c          **** #define	DIR_Attr			11	/* Attribute (1) */
 439:ff.c          **** #define	DIR_NTres			12	/* NT flag (1) */
 440:ff.c          **** #define DIR_CrtTimeTenth	13	/* Created time sub-second (1) */
 441:ff.c          **** #define	DIR_CrtTime			14	/* Created time (2) */
 442:ff.c          **** #define	DIR_CrtDate			16	/* Created date (2) */
 443:ff.c          **** #define DIR_LstAccDate		18	/* Last accessed date (2) */
 444:ff.c          **** #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
 445:ff.c          **** #define	DIR_WrtTime			22	/* Modified time (2) */
 446:ff.c          **** #define	DIR_WrtDate			24	/* Modified date (2) */
 447:ff.c          **** #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
 448:ff.c          **** #define	DIR_FileSize		28	/* File size (4) */
 449:ff.c          **** #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
 450:ff.c          **** #define	LDIR_Attr			11	/* LFN attribute (1) */
 451:ff.c          **** #define	LDIR_Type			12	/* LFN type (1) */
 452:ff.c          **** #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
 453:ff.c          **** #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
 454:ff.c          **** #define	SZ_DIR				32		/* Size of a directory entry */
 455:ff.c          **** #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
 456:ff.c          **** #define	DDE					0xE5	/* Deleted directory entry mark in DIR_Name[0] */
 457:ff.c          **** #define	NDDE				0x05	/* Replacement of the character collides with DDE */
 458:ff.c          **** 
 459:ff.c          **** 
 460:ff.c          **** /*------------------------------------------------------------*/
 461:ff.c          **** /* Module private work area                                   */
 462:ff.c          **** /*------------------------------------------------------------*/
 463:ff.c          **** /* Note that uninitialized variables with static duration are
 464:ff.c          **** /  zeroed/nulled at start-up. If not, the compiler or start-up
 465:ff.c          **** /  routine is out of ANSI-C standard.
 466:ff.c          **** */
 467:ff.c          **** 
 468:ff.c          **** #if _VOLUMES
 469:ff.c          **** static
 470:ff.c          **** FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
 471:ff.c          **** #else
 472:ff.c          **** #error Number of volumes must not be 0.
 473:ff.c          **** #endif
 474:ff.c          **** 
 475:ff.c          **** static
 476:ff.c          **** WORD Fsid;				/* File system mount ID */
 477:ff.c          **** 
 478:ff.c          **** #if _FS_RPATH
 479:ff.c          **** static
 480:ff.c          **** BYTE CurrVol;			/* Current drive */
 481:ff.c          **** #endif
 482:ff.c          **** 
 483:ff.c          **** #if _FS_LOCK
 484:ff.c          **** static
 485:ff.c          **** FILESEM	Files[_FS_LOCK];	/* File lock semaphores */
 486:ff.c          **** #endif
 487:ff.c          **** 
 488:ff.c          **** #if _USE_LFN == 0			/* No LFN feature */
 489:ff.c          **** #define	DEF_NAMEBUF			BYTE sfn[12]
 490:ff.c          **** #define INIT_BUF(dobj)		(dobj).fn = sfn
 491:ff.c          **** #define	FREE_BUF()
 492:ff.c          **** 
 493:ff.c          **** #elif _USE_LFN == 1			/* LFN feature with static working buffer */
 494:ff.c          **** static WCHAR LfnBuf[_MAX_LFN+1];
 495:ff.c          **** #define	DEF_NAMEBUF			BYTE sfn[12]
 496:ff.c          **** #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
 497:ff.c          **** #define	FREE_BUF()
 498:ff.c          **** 
 499:ff.c          **** #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
 500:ff.c          **** #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
 501:ff.c          **** #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
 502:ff.c          **** #define	FREE_BUF()
 503:ff.c          **** 
 504:ff.c          **** #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
 505:ff.c          **** #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
 506:ff.c          **** #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
 507:ff.c          **** 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
 508:ff.c          **** 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
 509:ff.c          **** #define	FREE_BUF()			ff_memfree(lfn)
 510:ff.c          **** 
 511:ff.c          **** #else
 512:ff.c          **** #error Wrong LFN configuration.
 513:ff.c          **** #endif
 514:ff.c          **** 
 515:ff.c          **** 
 516:ff.c          **** #ifdef _EXCVT
 517:ff.c          **** static
 518:ff.c          **** const BYTE ExCvt[] = _EXCVT;	/* Upper conversion table for extended chars */
 519:ff.c          **** #endif
 520:ff.c          **** 
 521:ff.c          **** 
 522:ff.c          **** 
 523:ff.c          **** 
 524:ff.c          **** 
 525:ff.c          **** 
 526:ff.c          **** /*--------------------------------------------------------------------------
 527:ff.c          **** 
 528:ff.c          ****    Module Private Functions
 529:ff.c          **** 
 530:ff.c          **** ---------------------------------------------------------------------------*/
 531:ff.c          **** 
 532:ff.c          **** 
 533:ff.c          **** /*-----------------------------------------------------------------------*/
 534:ff.c          **** /* String functions                                                      */
 535:ff.c          **** /*-----------------------------------------------------------------------*/
 536:ff.c          **** 
 537:ff.c          **** /* Copy memory to memory */
 538:ff.c          **** static
 539:ff.c          **** void mem_cpy (void* dst, const void* src, UINT cnt) {
  62               	.LM0:
  63               	.LFBB1:
  64               	/* prologue: function */
  65               	/* frame size = 0 */
  66               	/* stack size = 0 */
  67               	.L__stack_usage = 0
  68 0000 FB01      		movw r30,r22
  70               	.LM1:
  71 0002 480F      		add r20,r24
  72 0004 591F      		adc r21,r25
 540:ff.c          **** 	BYTE *d = (BYTE*)dst;
  74               	.LM2:
  75 0006 DC01      		movw r26,r24
 541:ff.c          **** 	const BYTE *s = (const BYTE*)src;
 542:ff.c          **** 
 543:ff.c          **** #if _WORD_ACCESS == 1
 544:ff.c          **** 	while (cnt >= sizeof (int)) {
 545:ff.c          **** 		*(int*)d = *(int*)s;
 546:ff.c          **** 		d += sizeof (int); s += sizeof (int);
 547:ff.c          **** 		cnt -= sizeof (int);
 548:ff.c          **** 	}
 549:ff.c          **** #endif
 550:ff.c          **** 	while (cnt--)
  77               	.LM3:
  78 0008 00C0      		rjmp .L2
  79               	.L3:
 551:ff.c          **** 		*d++ = *s++;
  81               	.LM4:
  82 000a 8191      		ld r24,Z+
  83 000c 8D93      		st X+,r24
  84               	.L2:
 550:ff.c          **** 	while (cnt--)
  86               	.LM5:
  87 000e A417      		cp r26,r20
  88 0010 B507      		cpc r27,r21
  89 0012 01F4      		brne .L3
  90               	/* epilogue start */
 552:ff.c          **** }
  92               	.LM6:
  93 0014 0895      		ret
  98               	.Lscope1:
 100               		.stabd	78,0,0
 105               	get_fileinfo:
 106               		.stabd	46,0,0
 553:ff.c          **** 
 554:ff.c          **** /* Fill memory */
 555:ff.c          **** static
 556:ff.c          **** void mem_set (void* dst, int val, UINT cnt) {
 557:ff.c          **** 	BYTE *d = (BYTE*)dst;
 558:ff.c          **** 
 559:ff.c          **** 	while (cnt--)
 560:ff.c          **** 		*d++ = (BYTE)val;
 561:ff.c          **** }
 562:ff.c          **** 
 563:ff.c          **** /* Compare memory to memory */
 564:ff.c          **** static
 565:ff.c          **** int mem_cmp (const void* dst, const void* src, UINT cnt) {
 566:ff.c          **** 	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
 567:ff.c          **** 	int r = 0;
 568:ff.c          **** 
 569:ff.c          **** 	while (cnt-- && (r = *d++ - *s++) == 0) ;
 570:ff.c          **** 	return r;
 571:ff.c          **** }
 572:ff.c          **** 
 573:ff.c          **** /* Check if chr is contained in the string */
 574:ff.c          **** static
 575:ff.c          **** int chk_chr (const char* str, int chr) {
 576:ff.c          **** 	while (*str && *str != chr) str++;
 577:ff.c          **** 	return *str;
 578:ff.c          **** }
 579:ff.c          **** 
 580:ff.c          **** 
 581:ff.c          **** 
 582:ff.c          **** /*-----------------------------------------------------------------------*/
 583:ff.c          **** /* Request/Release grant to access the volume                            */
 584:ff.c          **** /*-----------------------------------------------------------------------*/
 585:ff.c          **** #if _FS_REENTRANT
 586:ff.c          **** 
 587:ff.c          **** static
 588:ff.c          **** int lock_fs (
 589:ff.c          **** 	FATFS *fs		/* File system object */
 590:ff.c          **** )
 591:ff.c          **** {
 592:ff.c          **** 	return ff_req_grant(fs->sobj);
 593:ff.c          **** }
 594:ff.c          **** 
 595:ff.c          **** 
 596:ff.c          **** static
 597:ff.c          **** void unlock_fs (
 598:ff.c          **** 	FATFS *fs,		/* File system object */
 599:ff.c          **** 	FRESULT res		/* Result code to be returned */
 600:ff.c          **** )
 601:ff.c          **** {
 602:ff.c          **** 	if (fs &&
 603:ff.c          **** 		res != FR_NOT_ENABLED &&
 604:ff.c          **** 		res != FR_INVALID_DRIVE &&
 605:ff.c          **** 		res != FR_INVALID_OBJECT &&
 606:ff.c          **** 		res != FR_TIMEOUT) {
 607:ff.c          **** 		ff_rel_grant(fs->sobj);
 608:ff.c          **** 	}
 609:ff.c          **** }
 610:ff.c          **** #endif
 611:ff.c          **** 
 612:ff.c          **** 
 613:ff.c          **** 
 614:ff.c          **** /*-----------------------------------------------------------------------*/
 615:ff.c          **** /* File lock control functions                                           */
 616:ff.c          **** /*-----------------------------------------------------------------------*/
 617:ff.c          **** #if _FS_LOCK
 618:ff.c          **** 
 619:ff.c          **** static
 620:ff.c          **** FRESULT chk_lock (	/* Check if the file can be accessed */
 621:ff.c          **** 	DIR* dj,		/* Directory object pointing the file to be checked */
 622:ff.c          **** 	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
 623:ff.c          **** )
 624:ff.c          **** {
 625:ff.c          **** 	UINT i, be;
 626:ff.c          **** 
 627:ff.c          **** 	/* Search file semaphore table */
 628:ff.c          **** 	for (i = be = 0; i < _FS_LOCK; i++) {
 629:ff.c          **** 		if (Files[i].fs) {	/* Existing entry */
 630:ff.c          **** 			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
 631:ff.c          **** 				Files[i].clu == dj->sclust &&
 632:ff.c          **** 				Files[i].idx == dj->index) break;
 633:ff.c          **** 		} else {			/* Blank entry */
 634:ff.c          **** 			be++;
 635:ff.c          **** 		}
 636:ff.c          **** 	}
 637:ff.c          **** 	if (i == _FS_LOCK)	/* The file is not opened */
 638:ff.c          **** 		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file?
 639:ff.c          **** 
 640:ff.c          **** 	/* The file has been opened. Reject any open against writing file and all write mode open */
 641:ff.c          **** 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 642:ff.c          **** }
 643:ff.c          **** 
 644:ff.c          **** 
 645:ff.c          **** static
 646:ff.c          **** int enq_lock (void)	/* Check if an entry is available for a new file */
 647:ff.c          **** {
 648:ff.c          **** 	UINT i;
 649:ff.c          **** 
 650:ff.c          **** 	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 651:ff.c          **** 	return (i == _FS_LOCK) ? 0 : 1;
 652:ff.c          **** }
 653:ff.c          **** 
 654:ff.c          **** 
 655:ff.c          **** static
 656:ff.c          **** UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
 657:ff.c          **** 	DIR* dj,	/* Directory object pointing the file to register or increment */
 658:ff.c          **** 	int acc		/* Desired access mode (0:Read, !0:Write) */
 659:ff.c          **** )
 660:ff.c          **** {
 661:ff.c          **** 	UINT i;
 662:ff.c          **** 
 663:ff.c          **** 
 664:ff.c          **** 	for (i = 0; i < _FS_LOCK; i++) {	/* Find the file */
 665:ff.c          **** 		if (Files[i].fs == dj->fs &&
 666:ff.c          **** 			Files[i].clu == dj->sclust &&
 667:ff.c          **** 			Files[i].idx == dj->index) break;
 668:ff.c          **** 	}
 669:ff.c          **** 
 670:ff.c          **** 	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
 671:ff.c          **** 		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 672:ff.c          **** 		if (i == _FS_LOCK) return 0;	/* No space to register (int err) */
 673:ff.c          **** 		Files[i].fs = dj->fs;
 674:ff.c          **** 		Files[i].clu = dj->sclust;
 675:ff.c          **** 		Files[i].idx = dj->index;
 676:ff.c          **** 		Files[i].ctr = 0;
 677:ff.c          **** 	}
 678:ff.c          **** 
 679:ff.c          **** 	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 680:ff.c          **** 
 681:ff.c          **** 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 682:ff.c          **** 
 683:ff.c          **** 	return i + 1;
 684:ff.c          **** }
 685:ff.c          **** 
 686:ff.c          **** 
 687:ff.c          **** static
 688:ff.c          **** FRESULT dec_lock (	/* Decrement file open counter */
 689:ff.c          **** 	UINT i			/* Semaphore index */
 690:ff.c          **** )
 691:ff.c          **** {
 692:ff.c          **** 	WORD n;
 693:ff.c          **** 	FRESULT res;
 694:ff.c          **** 
 695:ff.c          **** 
 696:ff.c          **** 	if (--i < _FS_LOCK) {
 697:ff.c          **** 		n = Files[i].ctr;
 698:ff.c          **** 		if (n == 0x100) n = 0;
 699:ff.c          **** 		if (n) n--;
 700:ff.c          **** 		Files[i].ctr = n;
 701:ff.c          **** 		if (!n) Files[i].fs = 0;
 702:ff.c          **** 		res = FR_OK;
 703:ff.c          **** 	} else {
 704:ff.c          **** 		res = FR_INT_ERR;
 705:ff.c          **** 	}
 706:ff.c          **** 	return res;
 707:ff.c          **** }
 708:ff.c          **** 
 709:ff.c          **** 
 710:ff.c          **** static
 711:ff.c          **** void clear_lock (	/* Clear lock entries of the volume */
 712:ff.c          **** 	FATFS *fs
 713:ff.c          **** )
 714:ff.c          **** {
 715:ff.c          **** 	UINT i;
 716:ff.c          **** 
 717:ff.c          **** 	for (i = 0; i < _FS_LOCK; i++) {
 718:ff.c          **** 		if (Files[i].fs == fs) Files[i].fs = 0;
 719:ff.c          **** 	}
 720:ff.c          **** }
 721:ff.c          **** #endif
 722:ff.c          **** 
 723:ff.c          **** 
 724:ff.c          **** 
 725:ff.c          **** /*-----------------------------------------------------------------------*/
 726:ff.c          **** /* Move/Flush disk access window                                         */
 727:ff.c          **** /*-----------------------------------------------------------------------*/
 728:ff.c          **** 
 729:ff.c          **** 
 730:ff.c          **** #if !_FS_READONLY
 731:ff.c          **** static
 732:ff.c          **** FRESULT sync_window (
 733:ff.c          **** 	FATFS *fs		/* File system object */
 734:ff.c          **** )
 735:ff.c          **** {
 736:ff.c          **** 	DWORD wsect;
 737:ff.c          **** 	UINT nf;
 738:ff.c          **** 
 739:ff.c          **** 	
 740:ff.c          **** 	if (fs->wflag) {	/* Write back the sector if it is dirty */
 741:ff.c          **** 		wsect = fs->winsect;	/* Current sector number */
 742:ff.c          **** 		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 743:ff.c          **** 			return FR_DISK_ERR;
 744:ff.c          **** 		fs->wflag = 0;
 745:ff.c          **** 		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 746:ff.c          **** 			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 747:ff.c          **** 				wsect += fs->fsize;
 748:ff.c          **** 				disk_write(fs->drv, fs->win, wsect, 1);
 749:ff.c          **** 			}
 750:ff.c          **** 		}
 751:ff.c          **** 	}
 752:ff.c          **** 	return FR_OK;
 753:ff.c          **** }
 754:ff.c          **** #endif
 755:ff.c          **** 
 756:ff.c          **** 
 757:ff.c          **** static
 758:ff.c          **** FRESULT move_window (
 759:ff.c          **** 	FATFS *fs,		/* File system object */
 760:ff.c          **** 	DWORD sector	/* Sector number to make appearance in the fs->win[] */
 761:ff.c          **** )
 762:ff.c          **** {
 763:ff.c          **** 	if (sector != fs->winsect) {	/* Changed current window */
 764:ff.c          **** #if !_FS_READONLY
 765:ff.c          **** 		if (sync_window(fs) != FR_OK)
 766:ff.c          **** 			return FR_DISK_ERR;
 767:ff.c          **** #endif
 768:ff.c          **** 		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 769:ff.c          **** 			return FR_DISK_ERR;
 770:ff.c          **** 		fs->winsect = sector;
 771:ff.c          **** 	}
 772:ff.c          **** 
 773:ff.c          **** 	return FR_OK;
 774:ff.c          **** }
 775:ff.c          **** 
 776:ff.c          **** 
 777:ff.c          **** 
 778:ff.c          **** 
 779:ff.c          **** /*-----------------------------------------------------------------------*/
 780:ff.c          **** /* Synchronize file system and strage device                             */
 781:ff.c          **** /*-----------------------------------------------------------------------*/
 782:ff.c          **** #if !_FS_READONLY
 783:ff.c          **** static
 784:ff.c          **** FRESULT sync_fs (	/* FR_OK: successful, FR_DISK_ERR: failed */
 785:ff.c          **** 	FATFS *fs		/* File system object */
 786:ff.c          **** )
 787:ff.c          **** {
 788:ff.c          **** 	FRESULT res;
 789:ff.c          **** 
 790:ff.c          **** 
 791:ff.c          **** 	res = sync_window(fs);
 792:ff.c          **** 	if (res == FR_OK) {
 793:ff.c          **** 		/* Update FSInfo sector if needed */
 794:ff.c          **** 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
 795:ff.c          **** 			fs->winsect = 0;
 796:ff.c          **** 			/* Create FSInfo structure */
 797:ff.c          **** 			mem_set(fs->win, 0, 512);
 798:ff.c          **** 			ST_WORD(fs->win+BS_55AA, 0xAA55);
 799:ff.c          **** 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 800:ff.c          **** 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 801:ff.c          **** 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 802:ff.c          **** 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 803:ff.c          **** 			/* Write it into the FSInfo sector */
 804:ff.c          **** 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
 805:ff.c          **** 			fs->fsi_flag = 0;
 806:ff.c          **** 		}
 807:ff.c          **** 		/* Make sure that no pending write process in the physical drive */
 808:ff.c          **** 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
 809:ff.c          **** 			res = FR_DISK_ERR;
 810:ff.c          **** 	}
 811:ff.c          **** 
 812:ff.c          **** 	return res;
 813:ff.c          **** }
 814:ff.c          **** #endif
 815:ff.c          **** 
 816:ff.c          **** 
 817:ff.c          **** 
 818:ff.c          **** 
 819:ff.c          **** /*-----------------------------------------------------------------------*/
 820:ff.c          **** /* Get sector# from cluster#                                             */
 821:ff.c          **** /*-----------------------------------------------------------------------*/
 822:ff.c          **** 
 823:ff.c          **** 
 824:ff.c          **** DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
 825:ff.c          **** 	FATFS *fs,		/* File system object */
 826:ff.c          **** 	DWORD clst		/* Cluster# to be converted */
 827:ff.c          **** )
 828:ff.c          **** {
 829:ff.c          **** 	clst -= 2;
 830:ff.c          **** 	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 831:ff.c          **** 	return clst * fs->csize + fs->database;
 832:ff.c          **** }
 833:ff.c          **** 
 834:ff.c          **** 
 835:ff.c          **** 
 836:ff.c          **** 
 837:ff.c          **** /*-----------------------------------------------------------------------*/
 838:ff.c          **** /* FAT access - Read value of a FAT entry                                */
 839:ff.c          **** /*-----------------------------------------------------------------------*/
 840:ff.c          **** 
 841:ff.c          **** 
 842:ff.c          **** DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
 843:ff.c          **** 	FATFS *fs,	/* File system object */
 844:ff.c          **** 	DWORD clst	/* Cluster# to get the link information */
 845:ff.c          **** )
 846:ff.c          **** {
 847:ff.c          **** 	UINT wc, bc;
 848:ff.c          **** 	BYTE *p;
 849:ff.c          **** 
 850:ff.c          **** 
 851:ff.c          **** 	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 852:ff.c          **** 		return 1;
 853:ff.c          **** 
 854:ff.c          **** 	switch (fs->fs_type) {
 855:ff.c          **** 	case FS_FAT12 :
 856:ff.c          **** 		bc = (UINT)clst; bc += bc / 2;
 857:ff.c          **** 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 858:ff.c          **** 		wc = fs->win[bc % SS(fs)]; bc++;
 859:ff.c          **** 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 860:ff.c          **** 		wc |= fs->win[bc % SS(fs)] << 8;
 861:ff.c          **** 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 862:ff.c          **** 
 863:ff.c          **** 	case FS_FAT16 :
 864:ff.c          **** 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 865:ff.c          **** 		p = &fs->win[clst * 2 % SS(fs)];
 866:ff.c          **** 		return LD_WORD(p);
 867:ff.c          **** 
 868:ff.c          **** 	case FS_FAT32 :
 869:ff.c          **** 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 870:ff.c          **** 		p = &fs->win[clst * 4 % SS(fs)];
 871:ff.c          **** 		return LD_DWORD(p) & 0x0FFFFFFF;
 872:ff.c          **** 	}
 873:ff.c          **** 
 874:ff.c          **** 	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
 875:ff.c          **** }
 876:ff.c          **** 
 877:ff.c          **** 
 878:ff.c          **** 
 879:ff.c          **** 
 880:ff.c          **** /*-----------------------------------------------------------------------*/
 881:ff.c          **** /* FAT access - Change value of a FAT entry                              */
 882:ff.c          **** /*-----------------------------------------------------------------------*/
 883:ff.c          **** #if !_FS_READONLY
 884:ff.c          **** 
 885:ff.c          **** FRESULT put_fat (
 886:ff.c          **** 	FATFS *fs,	/* File system object */
 887:ff.c          **** 	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
 888:ff.c          **** 	DWORD val	/* New value to mark the cluster */
 889:ff.c          **** )
 890:ff.c          **** {
 891:ff.c          **** 	UINT bc;
 892:ff.c          **** 	BYTE *p;
 893:ff.c          **** 	FRESULT res;
 894:ff.c          **** 
 895:ff.c          **** 
 896:ff.c          **** 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 897:ff.c          **** 		res = FR_INT_ERR;
 898:ff.c          **** 
 899:ff.c          **** 	} else {
 900:ff.c          **** 		switch (fs->fs_type) {
 901:ff.c          **** 		case FS_FAT12 :
 902:ff.c          **** 			bc = (UINT)clst; bc += bc / 2;
 903:ff.c          **** 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 904:ff.c          **** 			if (res != FR_OK) break;
 905:ff.c          **** 			p = &fs->win[bc % SS(fs)];
 906:ff.c          **** 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 907:ff.c          **** 			bc++;
 908:ff.c          **** 			fs->wflag = 1;
 909:ff.c          **** 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 910:ff.c          **** 			if (res != FR_OK) break;
 911:ff.c          **** 			p = &fs->win[bc % SS(fs)];
 912:ff.c          **** 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 913:ff.c          **** 			break;
 914:ff.c          **** 
 915:ff.c          **** 		case FS_FAT16 :
 916:ff.c          **** 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 917:ff.c          **** 			if (res != FR_OK) break;
 918:ff.c          **** 			p = &fs->win[clst * 2 % SS(fs)];
 919:ff.c          **** 			ST_WORD(p, (WORD)val);
 920:ff.c          **** 			break;
 921:ff.c          **** 
 922:ff.c          **** 		case FS_FAT32 :
 923:ff.c          **** 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 924:ff.c          **** 			if (res != FR_OK) break;
 925:ff.c          **** 			p = &fs->win[clst * 4 % SS(fs)];
 926:ff.c          **** 			val |= LD_DWORD(p) & 0xF0000000;
 927:ff.c          **** 			ST_DWORD(p, val);
 928:ff.c          **** 			break;
 929:ff.c          **** 
 930:ff.c          **** 		default :
 931:ff.c          **** 			res = FR_INT_ERR;
 932:ff.c          **** 		}
 933:ff.c          **** 		fs->wflag = 1;
 934:ff.c          **** 	}
 935:ff.c          **** 
 936:ff.c          **** 	return res;
 937:ff.c          **** }
 938:ff.c          **** #endif /* !_FS_READONLY */
 939:ff.c          **** 
 940:ff.c          **** 
 941:ff.c          **** 
 942:ff.c          **** 
 943:ff.c          **** /*-----------------------------------------------------------------------*/
 944:ff.c          **** /* FAT handling - Remove a cluster chain                                 */
 945:ff.c          **** /*-----------------------------------------------------------------------*/
 946:ff.c          **** #if !_FS_READONLY
 947:ff.c          **** static
 948:ff.c          **** FRESULT remove_chain (
 949:ff.c          **** 	FATFS *fs,			/* File system object */
 950:ff.c          **** 	DWORD clst			/* Cluster# to remove a chain from */
 951:ff.c          **** )
 952:ff.c          **** {
 953:ff.c          **** 	FRESULT res;
 954:ff.c          **** 	DWORD nxt;
 955:ff.c          **** #if _USE_ERASE
 956:ff.c          **** 	DWORD scl = clst, ecl = clst, rt[2];
 957:ff.c          **** #endif
 958:ff.c          **** 
 959:ff.c          **** 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 960:ff.c          **** 		res = FR_INT_ERR;
 961:ff.c          **** 
 962:ff.c          **** 	} else {
 963:ff.c          **** 		res = FR_OK;
 964:ff.c          **** 		while (clst < fs->n_fatent) {			/* Not a last link? */
 965:ff.c          **** 			nxt = get_fat(fs, clst);			/* Get cluster status */
 966:ff.c          **** 			if (nxt == 0) break;				/* Empty cluster? */
 967:ff.c          **** 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 968:ff.c          **** 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 969:ff.c          **** 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 970:ff.c          **** 			if (res != FR_OK) break;
 971:ff.c          **** 			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
 972:ff.c          **** 				fs->free_clust++;
 973:ff.c          **** 				fs->fsi_flag = 1;
 974:ff.c          **** 			}
 975:ff.c          **** #if _USE_ERASE
 976:ff.c          **** 			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
 977:ff.c          **** 				ecl = nxt;
 978:ff.c          **** 			} else {				/* End of contiguous clusters */ 
 979:ff.c          **** 				rt[0] = clust2sect(fs, scl);					/* Start sector */
 980:ff.c          **** 				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
 981:ff.c          **** 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, rt);		/* Erase the block */
 982:ff.c          **** 				scl = ecl = nxt;
 983:ff.c          **** 			}
 984:ff.c          **** #endif
 985:ff.c          **** 			clst = nxt;	/* Next cluster */
 986:ff.c          **** 		}
 987:ff.c          **** 	}
 988:ff.c          **** 
 989:ff.c          **** 	return res;
 990:ff.c          **** }
 991:ff.c          **** #endif
 992:ff.c          **** 
 993:ff.c          **** 
 994:ff.c          **** 
 995:ff.c          **** 
 996:ff.c          **** /*-----------------------------------------------------------------------*/
 997:ff.c          **** /* FAT handling - Stretch or Create a cluster chain                      */
 998:ff.c          **** /*-----------------------------------------------------------------------*/
 999:ff.c          **** #if !_FS_READONLY
1000:ff.c          **** static
1001:ff.c          **** DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster
1002:ff.c          **** 	FATFS *fs,			/* File system object */
1003:ff.c          **** 	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
1004:ff.c          **** )
1005:ff.c          **** {
1006:ff.c          **** 	DWORD cs, ncl, scl;
1007:ff.c          **** 	FRESULT res;
1008:ff.c          **** 
1009:ff.c          **** 
1010:ff.c          **** 	if (clst == 0) {		/* Create a new chain */
1011:ff.c          **** 		scl = fs->last_clust;			/* Get suggested start point */
1012:ff.c          **** 		if (!scl || scl >= fs->n_fatent) scl = 1;
1013:ff.c          **** 	}
1014:ff.c          **** 	else {					/* Stretch the current chain */
1015:ff.c          **** 		cs = get_fat(fs, clst);			/* Check the cluster status */
1016:ff.c          **** 		if (cs < 2) return 1;			/* It is an invalid cluster */
1017:ff.c          **** 		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
1018:ff.c          **** 		scl = clst;
1019:ff.c          **** 	}
1020:ff.c          **** 
1021:ff.c          **** 	ncl = scl;				/* Start cluster */
1022:ff.c          **** 	for (;;) {
1023:ff.c          **** 		ncl++;							/* Next cluster */
1024:ff.c          **** 		if (ncl >= fs->n_fatent) {		/* Wrap around */
1025:ff.c          **** 			ncl = 2;
1026:ff.c          **** 			if (ncl > scl) return 0;	/* No free cluster */
1027:ff.c          **** 		}
1028:ff.c          **** 		cs = get_fat(fs, ncl);			/* Get the cluster status */
1029:ff.c          **** 		if (cs == 0) break;				/* Found a free cluster */
1030:ff.c          **** 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
1031:ff.c          **** 			return cs;
1032:ff.c          **** 		if (ncl == scl) return 0;		/* No free cluster */
1033:ff.c          **** 	}
1034:ff.c          **** 
1035:ff.c          **** 	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
1036:ff.c          **** 	if (res == FR_OK && clst != 0) {
1037:ff.c          **** 		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
1038:ff.c          **** 	}
1039:ff.c          **** 	if (res == FR_OK) {
1040:ff.c          **** 		fs->last_clust = ncl;			/* Update FSINFO */
1041:ff.c          **** 		if (fs->free_clust != 0xFFFFFFFF) {
1042:ff.c          **** 			fs->free_clust--;
1043:ff.c          **** 			fs->fsi_flag = 1;
1044:ff.c          **** 		}
1045:ff.c          **** 	} else {
1046:ff.c          **** 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
1047:ff.c          **** 	}
1048:ff.c          **** 
1049:ff.c          **** 	return ncl;		/* Return new cluster number or error code */
1050:ff.c          **** }
1051:ff.c          **** #endif /* !_FS_READONLY */
1052:ff.c          **** 
1053:ff.c          **** 
1054:ff.c          **** 
1055:ff.c          **** /*-----------------------------------------------------------------------*/
1056:ff.c          **** /* FAT handling - Convert offset into cluster with link map table        */
1057:ff.c          **** /*-----------------------------------------------------------------------*/
1058:ff.c          **** 
1059:ff.c          **** #if _USE_FASTSEEK
1060:ff.c          **** static
1061:ff.c          **** DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
1062:ff.c          **** 	FIL* fp,		/* Pointer to the file object */
1063:ff.c          **** 	DWORD ofs		/* File offset to be converted to cluster# */
1064:ff.c          **** )
1065:ff.c          **** {
1066:ff.c          **** 	DWORD cl, ncl, *tbl;
1067:ff.c          **** 
1068:ff.c          **** 
1069:ff.c          **** 	tbl = fp->cltbl + 1;	/* Top of CLMT */
1070:ff.c          **** 	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
1071:ff.c          **** 	for (;;) {
1072:ff.c          **** 		ncl = *tbl++;			/* Number of cluters in the fragment */
1073:ff.c          **** 		if (!ncl) return 0;		/* End of table? (error) */
1074:ff.c          **** 		if (cl < ncl) break;	/* In this fragment? */
1075:ff.c          **** 		cl -= ncl; tbl++;		/* Next fragment */
1076:ff.c          **** 	}
1077:ff.c          **** 	return cl + *tbl;	/* Return the cluster number */
1078:ff.c          **** }
1079:ff.c          **** #endif	/* _USE_FASTSEEK */
1080:ff.c          **** 
1081:ff.c          **** 
1082:ff.c          **** 
1083:ff.c          **** /*-----------------------------------------------------------------------*/
1084:ff.c          **** /* Directory handling - Set directory index                              */
1085:ff.c          **** /*-----------------------------------------------------------------------*/
1086:ff.c          **** 
1087:ff.c          **** static
1088:ff.c          **** FRESULT dir_sdi (
1089:ff.c          **** 	DIR *dj,		/* Pointer to directory object */
1090:ff.c          **** 	WORD idx		/* Index of directory table */
1091:ff.c          **** )
1092:ff.c          **** {
1093:ff.c          **** 	DWORD clst;
1094:ff.c          **** 	WORD ic;
1095:ff.c          **** 
1096:ff.c          **** 
1097:ff.c          **** 	dj->index = idx;
1098:ff.c          **** 	clst = dj->sclust;
1099:ff.c          **** 	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
1100:ff.c          **** 		return FR_INT_ERR;
1101:ff.c          **** 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
1102:ff.c          **** 		clst = dj->fs->dirbase;
1103:ff.c          **** 
1104:ff.c          **** 	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
1105:ff.c          **** 		dj->clust = clst;
1106:ff.c          **** 		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
1107:ff.c          **** 			return FR_INT_ERR;
1108:ff.c          **** 		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
1109:ff.c          **** 	}
1110:ff.c          **** 	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
1111:ff.c          **** 		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
1112:ff.c          **** 		while (idx >= ic) {	/* Follow cluster chain */
1113:ff.c          **** 			clst = get_fat(dj->fs, clst);				/* Get next cluster */
1114:ff.c          **** 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
1115:ff.c          **** 			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
1116:ff.c          **** 				return FR_INT_ERR;
1117:ff.c          **** 			idx -= ic;
1118:ff.c          **** 		}
1119:ff.c          **** 		dj->clust = clst;
1120:ff.c          **** 		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
1121:ff.c          **** 	}
1122:ff.c          **** 
1123:ff.c          **** 	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector 
1124:ff.c          **** 
1125:ff.c          **** 	return FR_OK;	/* Seek succeeded */
1126:ff.c          **** }
1127:ff.c          **** 
1128:ff.c          **** 
1129:ff.c          **** 
1130:ff.c          **** 
1131:ff.c          **** /*-----------------------------------------------------------------------*/
1132:ff.c          **** /* Directory handling - Move directory table index next                  */
1133:ff.c          **** /*-----------------------------------------------------------------------*/
1134:ff.c          **** 
1135:ff.c          **** static
1136:ff.c          **** FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
1137:ff.c          **** 	DIR *dj,		/* Pointer to the directory object */
1138:ff.c          **** 	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
1139:ff.c          **** )
1140:ff.c          **** {
1141:ff.c          **** 	DWORD clst;
1142:ff.c          **** 	WORD i;
1143:ff.c          **** 
1144:ff.c          **** 
1145:ff.c          **** 	stretch = stretch;		/* To suppress warning on read-only cfg. */
1146:ff.c          **** 	i = dj->index + 1;
1147:ff.c          **** 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
1148:ff.c          **** 		return FR_NO_FILE;
1149:ff.c          **** 
1150:ff.c          **** 	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
1151:ff.c          **** 		dj->sect++;					/* Next sector */
1152:ff.c          **** 
1153:ff.c          **** 		if (dj->clust == 0) {	/* Static table */
1154:ff.c          **** 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
1155:ff.c          **** 				return FR_NO_FILE;
1156:ff.c          **** 		}
1157:ff.c          **** 		else {					/* Dynamic table */
1158:ff.c          **** 			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
1159:ff.c          **** 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
1160:ff.c          **** 				if (clst <= 1) return FR_INT_ERR;
1161:ff.c          **** 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
1162:ff.c          **** 				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
1163:ff.c          **** #if !_FS_READONLY
1164:ff.c          **** 					BYTE c;
1165:ff.c          **** 					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
1166:ff.c          **** 					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
1167:ff.c          **** 					if (clst == 0) return FR_DENIED;			/* No free cluster */
1168:ff.c          **** 					if (clst == 1) return FR_INT_ERR;
1169:ff.c          **** 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
1170:ff.c          **** 					/* Clean-up stretched table */
1171:ff.c          **** 					if (sync_window(dj->fs)) return FR_DISK_ERR;	/* Flush active window */
1172:ff.c          **** 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
1173:ff.c          **** 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
1174:ff.c          **** 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
1175:ff.c          **** 						dj->fs->wflag = 1;
1176:ff.c          **** 						if (sync_window(dj->fs)) return FR_DISK_ERR;
1177:ff.c          **** 						dj->fs->winsect++;
1178:ff.c          **** 					}
1179:ff.c          **** 					dj->fs->winsect -= c;						/* Rewind window address */
1180:ff.c          **** #else
1181:ff.c          **** 					return FR_NO_FILE;			/* Report EOT */
1182:ff.c          **** #endif
1183:ff.c          **** 				}
1184:ff.c          **** 				dj->clust = clst;				/* Initialize data for new cluster */
1185:ff.c          **** 				dj->sect = clust2sect(dj->fs, clst);
1186:ff.c          **** 			}
1187:ff.c          **** 		}
1188:ff.c          **** 	}
1189:ff.c          **** 
1190:ff.c          **** 	dj->index = i;
1191:ff.c          **** 	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
1192:ff.c          **** 
1193:ff.c          **** 	return FR_OK;
1194:ff.c          **** }
1195:ff.c          **** 
1196:ff.c          **** 
1197:ff.c          **** 
1198:ff.c          **** 
1199:ff.c          **** /*-----------------------------------------------------------------------*/
1200:ff.c          **** /* Directory handling - Reserve directory entry                          */
1201:ff.c          **** /*-----------------------------------------------------------------------*/
1202:ff.c          **** 
1203:ff.c          **** #if !_FS_READONLY
1204:ff.c          **** static
1205:ff.c          **** FRESULT dir_alloc (
1206:ff.c          **** 	DIR* dj,	/* Pointer to the directory object */
1207:ff.c          **** 	UINT nent	/* Number of contiguous entries to allocate (1-21) */
1208:ff.c          **** )
1209:ff.c          **** {
1210:ff.c          **** 	FRESULT res;
1211:ff.c          **** 	UINT n;
1212:ff.c          **** 
1213:ff.c          **** 
1214:ff.c          **** 	res = dir_sdi(dj, 0);
1215:ff.c          **** 	if (res == FR_OK) {
1216:ff.c          **** 		n = 0;
1217:ff.c          **** 		do {
1218:ff.c          **** 			res = move_window(dj->fs, dj->sect);
1219:ff.c          **** 			if (res != FR_OK) break;
1220:ff.c          **** 			if (dj->dir[0] == DDE || dj->dir[0] == 0) {	/* Is it a blank entry? */
1221:ff.c          **** 				if (++n == nent) break;	/* A block of contiguous entry is found */
1222:ff.c          **** 			} else {
1223:ff.c          **** 				n = 0;					/* Not a blank entry. Restart to search */
1224:ff.c          **** 			}
1225:ff.c          **** 			res = dir_next(dj, 1);		/* Next entry with table stretch enabled */
1226:ff.c          **** 		} while (res == FR_OK);
1227:ff.c          **** 	}
1228:ff.c          **** 	return res;
1229:ff.c          **** }
1230:ff.c          **** #endif
1231:ff.c          **** 
1232:ff.c          **** 
1233:ff.c          **** 
1234:ff.c          **** /*-----------------------------------------------------------------------*/
1235:ff.c          **** /* Directory handling - Load/Store start cluster number                  */
1236:ff.c          **** /*-----------------------------------------------------------------------*/
1237:ff.c          **** 
1238:ff.c          **** static
1239:ff.c          **** DWORD ld_clust (
1240:ff.c          **** 	FATFS *fs,	/* Pointer to the fs object */
1241:ff.c          **** 	BYTE *dir	/* Pointer to the directory entry */
1242:ff.c          **** )
1243:ff.c          **** {
1244:ff.c          **** 	DWORD cl;
1245:ff.c          **** 
1246:ff.c          **** 	cl = LD_WORD(dir+DIR_FstClusLO);
1247:ff.c          **** 	if (fs->fs_type == FS_FAT32)
1248:ff.c          **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
1249:ff.c          **** 
1250:ff.c          **** 	return cl;
1251:ff.c          **** }
1252:ff.c          **** 
1253:ff.c          **** 
1254:ff.c          **** #if !_FS_READONLY
1255:ff.c          **** static
1256:ff.c          **** void st_clust (
1257:ff.c          **** 	BYTE *dir,	/* Pointer to the directory entry */
1258:ff.c          **** 	DWORD cl	/* Value to be set */
1259:ff.c          **** )
1260:ff.c          **** {
1261:ff.c          **** 	ST_WORD(dir+DIR_FstClusLO, cl);
1262:ff.c          **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
1263:ff.c          **** }
1264:ff.c          **** #endif
1265:ff.c          **** 
1266:ff.c          **** 
1267:ff.c          **** 
1268:ff.c          **** /*-----------------------------------------------------------------------*/
1269:ff.c          **** /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
1270:ff.c          **** /*-----------------------------------------------------------------------*/
1271:ff.c          **** #if _USE_LFN
1272:ff.c          **** static
1273:ff.c          **** const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory 
1274:ff.c          **** 
1275:ff.c          **** 
1276:ff.c          **** static
1277:ff.c          **** int cmp_lfn (			/* 1:Matched, 0:Not matched */
1278:ff.c          **** 	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
1279:ff.c          **** 	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
1280:ff.c          **** )
1281:ff.c          **** {
1282:ff.c          **** 	UINT i, s;
1283:ff.c          **** 	WCHAR wc, uc;
1284:ff.c          **** 
1285:ff.c          **** 
1286:ff.c          **** 	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
1287:ff.c          **** 	s = 0; wc = 1;
1288:ff.c          **** 	do {
1289:ff.c          **** 		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
1290:ff.c          **** 		if (wc) {	/* Last char has not been processed */
1291:ff.c          **** 			wc = ff_wtoupper(uc);		/* Convert it to upper case */
1292:ff.c          **** 			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
1293:ff.c          **** 				return 0;				/* Not matched */
1294:ff.c          **** 		} else {
1295:ff.c          **** 			if (uc != 0xFFFF) return 0;	/* Check filler */
1296:ff.c          **** 		}
1297:ff.c          **** 	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
1298:ff.c          **** 
1299:ff.c          **** 	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
1300:ff.c          **** 		return 0;
1301:ff.c          **** 
1302:ff.c          **** 	return 1;						/* The part of LFN matched */
1303:ff.c          **** }
1304:ff.c          **** 
1305:ff.c          **** 
1306:ff.c          **** 
1307:ff.c          **** static
1308:ff.c          **** int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
1309:ff.c          **** 	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
1310:ff.c          **** 	BYTE *dir			/* Pointer to the directory entry */
1311:ff.c          **** )
1312:ff.c          **** {
1313:ff.c          **** 	UINT i, s;
1314:ff.c          **** 	WCHAR wc, uc;
1315:ff.c          **** 
1316:ff.c          **** 
1317:ff.c          **** 	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
1318:ff.c          **** 
1319:ff.c          **** 	s = 0; wc = 1;
1320:ff.c          **** 	do {
1321:ff.c          **** 		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
1322:ff.c          **** 		if (wc) {	/* Last char has not been processed */
1323:ff.c          **** 			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
1324:ff.c          **** 			lfnbuf[i++] = wc = uc;			/* Store it */
1325:ff.c          **** 		} else {
1326:ff.c          **** 			if (uc != 0xFFFF) return 0;		/* Check filler */
1327:ff.c          **** 		}
1328:ff.c          **** 	} while (++s < 13);						/* Read all character in the entry */
1329:ff.c          **** 
1330:ff.c          **** 	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
1331:ff.c          **** 		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
1332:ff.c          **** 		lfnbuf[i] = 0;
1333:ff.c          **** 	}
1334:ff.c          **** 
1335:ff.c          **** 	return 1;
1336:ff.c          **** }
1337:ff.c          **** 
1338:ff.c          **** 
1339:ff.c          **** #if !_FS_READONLY
1340:ff.c          **** static
1341:ff.c          **** void fit_lfn (
1342:ff.c          **** 	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
1343:ff.c          **** 	BYTE *dir,				/* Pointer to the directory entry */
1344:ff.c          **** 	BYTE ord,				/* LFN order (1-20) */
1345:ff.c          **** 	BYTE sum				/* SFN sum */
1346:ff.c          **** )
1347:ff.c          **** {
1348:ff.c          **** 	UINT i, s;
1349:ff.c          **** 	WCHAR wc;
1350:ff.c          **** 
1351:ff.c          **** 
1352:ff.c          **** 	dir[LDIR_Chksum] = sum;			/* Set check sum */
1353:ff.c          **** 	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
1354:ff.c          **** 	dir[LDIR_Type] = 0;
1355:ff.c          **** 	ST_WORD(dir+LDIR_FstClusLO, 0);
1356:ff.c          **** 
1357:ff.c          **** 	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
1358:ff.c          **** 	s = wc = 0;
1359:ff.c          **** 	do {
1360:ff.c          **** 		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
1361:ff.c          **** 		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
1362:ff.c          **** 		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
1363:ff.c          **** 	} while (++s < 13);
1364:ff.c          **** 	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
1365:ff.c          **** 	dir[LDIR_Ord] = ord;			/* Set the LFN order */
1366:ff.c          **** }
1367:ff.c          **** 
1368:ff.c          **** #endif
1369:ff.c          **** #endif
1370:ff.c          **** 
1371:ff.c          **** 
1372:ff.c          **** 
1373:ff.c          **** /*-----------------------------------------------------------------------*/
1374:ff.c          **** /* Create numbered name                                                  */
1375:ff.c          **** /*-----------------------------------------------------------------------*/
1376:ff.c          **** #if _USE_LFN
1377:ff.c          **** void gen_numname (
1378:ff.c          **** 	BYTE *dst,			/* Pointer to generated SFN */
1379:ff.c          **** 	const BYTE *src,	/* Pointer to source SFN to be modified */
1380:ff.c          **** 	const WCHAR *lfn,	/* Pointer to LFN */
1381:ff.c          **** 	WORD seq			/* Sequence number */
1382:ff.c          **** )
1383:ff.c          **** {
1384:ff.c          **** 	BYTE ns[8], c;
1385:ff.c          **** 	UINT i, j;
1386:ff.c          **** 
1387:ff.c          **** 
1388:ff.c          **** 	mem_cpy(dst, src, 11);
1389:ff.c          **** 
1390:ff.c          **** 	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
1391:ff.c          **** 		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
1392:ff.c          **** 	}
1393:ff.c          **** 
1394:ff.c          **** 	/* itoa (hexdecimal) */
1395:ff.c          **** 	i = 7;
1396:ff.c          **** 	do {
1397:ff.c          **** 		c = (seq % 16) + '0';
1398:ff.c          **** 		if (c > '9') c += 7;
1399:ff.c          **** 		ns[i--] = c;
1400:ff.c          **** 		seq /= 16;
1401:ff.c          **** 	} while (seq);
1402:ff.c          **** 	ns[i] = '~';
1403:ff.c          **** 
1404:ff.c          **** 	/* Append the number */
1405:ff.c          **** 	for (j = 0; j < i && dst[j] != ' '; j++) {
1406:ff.c          **** 		if (IsDBCS1(dst[j])) {
1407:ff.c          **** 			if (j == i - 1) break;
1408:ff.c          **** 			j++;
1409:ff.c          **** 		}
1410:ff.c          **** 	}
1411:ff.c          **** 	do {
1412:ff.c          **** 		dst[j++] = (i < 8) ? ns[i++] : ' ';
1413:ff.c          **** 	} while (j < 8);
1414:ff.c          **** }
1415:ff.c          **** #endif
1416:ff.c          **** 
1417:ff.c          **** 
1418:ff.c          **** 
1419:ff.c          **** 
1420:ff.c          **** /*-----------------------------------------------------------------------*/
1421:ff.c          **** /* Calculate sum of an SFN                                               */
1422:ff.c          **** /*-----------------------------------------------------------------------*/
1423:ff.c          **** #if _USE_LFN
1424:ff.c          **** static
1425:ff.c          **** BYTE sum_sfn (
1426:ff.c          **** 	const BYTE *dir		/* Ptr to directory entry */
1427:ff.c          **** )
1428:ff.c          **** {
1429:ff.c          **** 	BYTE sum = 0;
1430:ff.c          **** 	UINT n = 11;
1431:ff.c          **** 
1432:ff.c          **** 	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
1433:ff.c          **** 	return sum;
1434:ff.c          **** }
1435:ff.c          **** #endif
1436:ff.c          **** 
1437:ff.c          **** 
1438:ff.c          **** 
1439:ff.c          **** 
1440:ff.c          **** /*-----------------------------------------------------------------------*/
1441:ff.c          **** /* Directory handling - Find an object in the directory                  */
1442:ff.c          **** /*-----------------------------------------------------------------------*/
1443:ff.c          **** 
1444:ff.c          **** static
1445:ff.c          **** FRESULT dir_find (
1446:ff.c          **** 	DIR *dj			/* Pointer to the directory object linked to the file name */
1447:ff.c          **** )
1448:ff.c          **** {
1449:ff.c          **** 	FRESULT res;
1450:ff.c          **** 	BYTE c, *dir;
1451:ff.c          **** #if _USE_LFN
1452:ff.c          **** 	BYTE a, ord, sum;
1453:ff.c          **** #endif
1454:ff.c          **** 
1455:ff.c          **** 	res = dir_sdi(dj, 0);			/* Rewind directory object */
1456:ff.c          **** 	if (res != FR_OK) return res;
1457:ff.c          **** 
1458:ff.c          **** #if _USE_LFN
1459:ff.c          **** 	ord = sum = 0xFF;
1460:ff.c          **** #endif
1461:ff.c          **** 	do {
1462:ff.c          **** 		res = move_window(dj->fs, dj->sect);
1463:ff.c          **** 		if (res != FR_OK) break;
1464:ff.c          **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
1465:ff.c          **** 		c = dir[DIR_Name];
1466:ff.c          **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
1467:ff.c          **** #if _USE_LFN	/* LFN configuration */
1468:ff.c          **** 		a = dir[DIR_Attr] & AM_MASK;
1469:ff.c          **** 		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
1470:ff.c          **** 			ord = 0xFF;
1471:ff.c          **** 		} else {
1472:ff.c          **** 			if (a == AM_LFN) {			/* An LFN entry is found */
1473:ff.c          **** 				if (dj->lfn) {
1474:ff.c          **** 					if (c & LLE) {		/* Is it start of LFN sequence? */
1475:ff.c          **** 						sum = dir[LDIR_Chksum];
1476:ff.c          **** 						c &= ~LLE; ord = c;	/* LFN start order */
1477:ff.c          **** 						dj->lfn_idx = dj->index;
1478:ff.c          **** 					}
1479:ff.c          **** 					/* Check validity of the LFN entry and compare it with given name */
1480:ff.c          **** 					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1481:ff.c          **** 				}
1482:ff.c          **** 			} else {					/* An SFN entry is found */
1483:ff.c          **** 				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
1484:ff.c          **** 				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
1485:ff.c          **** 				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
1486:ff.c          **** 			}
1487:ff.c          **** 		}
1488:ff.c          **** #else		/* Non LFN configuration */
1489:ff.c          **** 		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
1490:ff.c          **** 			break;
1491:ff.c          **** #endif
1492:ff.c          **** 		res = dir_next(dj, 0);		/* Next entry */
1493:ff.c          **** 	} while (res == FR_OK);
1494:ff.c          **** 
1495:ff.c          **** 	return res;
1496:ff.c          **** }
1497:ff.c          **** 
1498:ff.c          **** 
1499:ff.c          **** 
1500:ff.c          **** 
1501:ff.c          **** /*-----------------------------------------------------------------------*/
1502:ff.c          **** /* Read an object from the directory                                     */
1503:ff.c          **** /*-----------------------------------------------------------------------*/
1504:ff.c          **** #if _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2
1505:ff.c          **** static
1506:ff.c          **** FRESULT dir_read (
1507:ff.c          **** 	DIR *dj,		/* Pointer to the directory object */
1508:ff.c          **** 	int vol			/* Filtered by 0:file/dir or 1:volume label */
1509:ff.c          **** )
1510:ff.c          **** {
1511:ff.c          **** 	FRESULT res;
1512:ff.c          **** 	BYTE a, c, *dir;
1513:ff.c          **** #if _USE_LFN
1514:ff.c          **** 	BYTE ord = 0xFF, sum = 0xFF;
1515:ff.c          **** #endif
1516:ff.c          **** 
1517:ff.c          **** 	res = FR_NO_FILE;
1518:ff.c          **** 	while (dj->sect) {
1519:ff.c          **** 		res = move_window(dj->fs, dj->sect);
1520:ff.c          **** 		if (res != FR_OK) break;
1521:ff.c          **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
1522:ff.c          **** 		c = dir[DIR_Name];
1523:ff.c          **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
1524:ff.c          **** 		a = dir[DIR_Attr] & AM_MASK;
1525:ff.c          **** #if _USE_LFN	/* LFN configuration */
1526:ff.c          **** 		if (c == DDE || (!_FS_RPATH && c == '.') || (a == AM_VOL) != vol) {	/* An entry without valid dat
1527:ff.c          **** 			ord = 0xFF;
1528:ff.c          **** 		} else {
1529:ff.c          **** 			if (a == AM_LFN) {			/* An LFN entry is found */
1530:ff.c          **** 				if (c & LLE) {			/* Is it start of LFN sequence? */
1531:ff.c          **** 					sum = dir[LDIR_Chksum];
1532:ff.c          **** 					c &= ~LLE; ord = c;
1533:ff.c          **** 					dj->lfn_idx = dj->index;
1534:ff.c          **** 				}
1535:ff.c          **** 				/* Check LFN validity and capture it */
1536:ff.c          **** 				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1537:ff.c          **** 			} else {					/* An SFN entry is found */
1538:ff.c          **** 				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
1539:ff.c          **** 					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
1540:ff.c          **** 				break;
1541:ff.c          **** 			}
1542:ff.c          **** 		}
1543:ff.c          **** #else		/* Non LFN configuration */
1544:ff.c          **** 		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (a == AM_VOL) == vol)	/* Is it a valid 
1545:ff.c          **** 			break;
1546:ff.c          **** #endif
1547:ff.c          **** 		res = dir_next(dj, 0);				/* Next entry */
1548:ff.c          **** 		if (res != FR_OK) break;
1549:ff.c          **** 	}
1550:ff.c          **** 
1551:ff.c          **** 	if (res != FR_OK) dj->sect = 0;
1552:ff.c          **** 
1553:ff.c          **** 	return res;
1554:ff.c          **** }
1555:ff.c          **** #endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
1556:ff.c          **** 
1557:ff.c          **** 
1558:ff.c          **** 
1559:ff.c          **** /*-----------------------------------------------------------------------*/
1560:ff.c          **** /* Register an object to the directory                                   */
1561:ff.c          **** /*-----------------------------------------------------------------------*/
1562:ff.c          **** #if !_FS_READONLY
1563:ff.c          **** static
1564:ff.c          **** FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_D
1565:ff.c          **** 	DIR *dj				/* Target directory with object name to be created */
1566:ff.c          **** )
1567:ff.c          **** {
1568:ff.c          **** 	FRESULT res;
1569:ff.c          **** #if _USE_LFN	/* LFN configuration */
1570:ff.c          **** 	WORD n, ne;
1571:ff.c          **** 	BYTE sn[12], *fn, sum;
1572:ff.c          **** 	WCHAR *lfn;
1573:ff.c          **** 
1574:ff.c          **** 
1575:ff.c          **** 	fn = dj->fn; lfn = dj->lfn;
1576:ff.c          **** 	mem_cpy(sn, fn, 12);
1577:ff.c          **** 
1578:ff.c          **** 	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
1579:ff.c          **** 		return FR_INVALID_NAME;
1580:ff.c          **** 
1581:ff.c          **** 	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
1582:ff.c          **** 		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
1583:ff.c          **** 		for (n = 1; n < 100; n++) {
1584:ff.c          **** 			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
1585:ff.c          **** 			res = dir_find(dj);				/* Check if the name collides with existing SFN */
1586:ff.c          **** 			if (res != FR_OK) break;
1587:ff.c          **** 		}
1588:ff.c          **** 		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
1589:ff.c          **** 		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
1590:ff.c          **** 		fn[NS] = sn[NS]; dj->lfn = lfn;
1591:ff.c          **** 	}
1592:ff.c          **** 
1593:ff.c          **** 	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
1594:ff.c          **** 		for (n = 0; lfn[n]; n++) ;
1595:ff.c          **** 		ne = (n + 25) / 13;
1596:ff.c          **** 	} else {						/* Otherwise allocate an entry for an SFN  */
1597:ff.c          **** 		ne = 1;
1598:ff.c          **** 	}
1599:ff.c          **** 	res = dir_alloc(dj, ne);		/* Allocate entries */
1600:ff.c          **** 
1601:ff.c          **** 	if (res == FR_OK && --ne) {		/* Set LFN entry if needed */
1602:ff.c          **** 		res = dir_sdi(dj, (WORD)(dj->index - ne));
1603:ff.c          **** 		if (res == FR_OK) {
1604:ff.c          **** 			sum = sum_sfn(dj->fn);	/* Sum value of the SFN tied to the LFN */
1605:ff.c          **** 			do {					/* Store LFN entries in bottom first */
1606:ff.c          **** 				res = move_window(dj->fs, dj->sect);
1607:ff.c          **** 				if (res != FR_OK) break;
1608:ff.c          **** 				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
1609:ff.c          **** 				dj->fs->wflag = 1;
1610:ff.c          **** 				res = dir_next(dj, 0);	/* Next entry */
1611:ff.c          **** 			} while (res == FR_OK && --ne);
1612:ff.c          **** 		}
1613:ff.c          **** 	}
1614:ff.c          **** #else	/* Non LFN configuration */
1615:ff.c          **** 	res = dir_alloc(dj, 1);		/* Allocate an entry for SFN */
1616:ff.c          **** #endif
1617:ff.c          **** 
1618:ff.c          **** 	if (res == FR_OK) {				/* Set SFN entry */
1619:ff.c          **** 		res = move_window(dj->fs, dj->sect);
1620:ff.c          **** 		if (res == FR_OK) {
1621:ff.c          **** 			mem_set(dj->dir, 0, SZ_DIR);	/* Clean the entry */
1622:ff.c          **** 			mem_cpy(dj->dir, dj->fn, 11);	/* Put SFN */
1623:ff.c          **** #if _USE_LFN
1624:ff.c          **** 			dj->dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
1625:ff.c          **** #endif
1626:ff.c          **** 			dj->fs->wflag = 1;
1627:ff.c          **** 		}
1628:ff.c          **** 	}
1629:ff.c          **** 
1630:ff.c          **** 	return res;
1631:ff.c          **** }
1632:ff.c          **** #endif /* !_FS_READONLY */
1633:ff.c          **** 
1634:ff.c          **** 
1635:ff.c          **** 
1636:ff.c          **** 
1637:ff.c          **** /*-----------------------------------------------------------------------*/
1638:ff.c          **** /* Remove an object from the directory                                   */
1639:ff.c          **** /*-----------------------------------------------------------------------*/
1640:ff.c          **** #if !_FS_READONLY && !_FS_MINIMIZE
1641:ff.c          **** static
1642:ff.c          **** FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
1643:ff.c          **** 	DIR *dj				/* Directory object pointing the entry to be removed */
1644:ff.c          **** )
1645:ff.c          **** {
1646:ff.c          **** 	FRESULT res;
1647:ff.c          **** #if _USE_LFN	/* LFN configuration */
1648:ff.c          **** 	WORD i;
1649:ff.c          **** 
1650:ff.c          **** 	i = dj->index;	/* SFN index */
1651:ff.c          **** 	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of th
1652:ff.c          **** 	if (res == FR_OK) {
1653:ff.c          **** 		do {
1654:ff.c          **** 			res = move_window(dj->fs, dj->sect);
1655:ff.c          **** 			if (res != FR_OK) break;
1656:ff.c          **** 			*dj->dir = DDE;			/* Mark the entry "deleted" */
1657:ff.c          **** 			dj->fs->wflag = 1;
1658:ff.c          **** 			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
1659:ff.c          **** 			res = dir_next(dj, 0);		/* Next entry */
1660:ff.c          **** 		} while (res == FR_OK);
1661:ff.c          **** 		if (res == FR_NO_FILE) res = FR_INT_ERR;
1662:ff.c          **** 	}
1663:ff.c          **** 
1664:ff.c          **** #else			/* Non LFN configuration */
1665:ff.c          **** 	res = dir_sdi(dj, dj->index);
1666:ff.c          **** 	if (res == FR_OK) {
1667:ff.c          **** 		res = move_window(dj->fs, dj->sect);
1668:ff.c          **** 		if (res == FR_OK) {
1669:ff.c          **** 			*dj->dir = DDE;			/* Mark the entry "deleted" */
1670:ff.c          **** 			dj->fs->wflag = 1;
1671:ff.c          **** 		}
1672:ff.c          **** 	}
1673:ff.c          **** #endif
1674:ff.c          **** 
1675:ff.c          **** 	return res;
1676:ff.c          **** }
1677:ff.c          **** #endif /* !_FS_READONLY */
1678:ff.c          **** 
1679:ff.c          **** 
1680:ff.c          **** 
1681:ff.c          **** 
1682:ff.c          **** /*-----------------------------------------------------------------------*/
1683:ff.c          **** /* Pick a segment and create the object name in directory form           */
1684:ff.c          **** /*-----------------------------------------------------------------------*/
1685:ff.c          **** 
1686:ff.c          **** static
1687:ff.c          **** FRESULT create_name (
1688:ff.c          **** 	DIR *dj,			/* Pointer to the directory object */
1689:ff.c          **** 	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
1690:ff.c          **** )
1691:ff.c          **** {
1692:ff.c          **** #if _USE_LFN	/* LFN configuration */
1693:ff.c          **** 	BYTE b, cf;
1694:ff.c          **** 	WCHAR w, *lfn;
1695:ff.c          **** 	UINT i, ni, si, di;
1696:ff.c          **** 	const TCHAR *p;
1697:ff.c          **** 
1698:ff.c          **** 	/* Create LFN in Unicode */
1699:ff.c          **** 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
1700:ff.c          **** 	lfn = dj->lfn;
1701:ff.c          **** 	si = di = 0;
1702:ff.c          **** 	for (;;) {
1703:ff.c          **** 		w = p[si++];					/* Get a character */
1704:ff.c          **** 		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
1705:ff.c          **** 		if (di >= _MAX_LFN)				/* Reject too long name */
1706:ff.c          **** 			return FR_INVALID_NAME;
1707:ff.c          **** #if !_LFN_UNICODE
1708:ff.c          **** 		w &= 0xFF;
1709:ff.c          **** 		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
1710:ff.c          **** 			b = (BYTE)p[si++];			/* Get 2nd byte */
1711:ff.c          **** 			if (!IsDBCS2(b))
1712:ff.c          **** 				return FR_INVALID_NAME;	/* Reject invalid sequence */
1713:ff.c          **** 			w = (w << 8) + b;			/* Create a DBC */
1714:ff.c          **** 		}
1715:ff.c          **** 		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
1716:ff.c          **** 		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
1717:ff.c          **** #endif
1718:ff.c          **** 		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
1719:ff.c          **** 			return FR_INVALID_NAME;
1720:ff.c          **** 		lfn[di++] = w;					/* Store the Unicode char */
1721:ff.c          **** 	}
1722:ff.c          **** 	*path = &p[si];						/* Return pointer to the next segment */
1723:ff.c          **** 	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
1724:ff.c          **** #if _FS_RPATH
1725:ff.c          **** 	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
1726:ff.c          **** 		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
1727:ff.c          **** 		lfn[di] = 0;
1728:ff.c          **** 		for (i = 0; i < 11; i++)
1729:ff.c          **** 			dj->fn[i] = (i < di) ? '.' : ' ';
1730:ff.c          **** 		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
1731:ff.c          **** 		return FR_OK;
1732:ff.c          **** 	}
1733:ff.c          **** #endif
1734:ff.c          **** 	while (di) {						/* Strip trailing spaces and dots */
1735:ff.c          **** 		w = lfn[di-1];
1736:ff.c          **** 		if (w != ' ' && w != '.') break;
1737:ff.c          **** 		di--;
1738:ff.c          **** 	}
1739:ff.c          **** 	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
1740:ff.c          **** 
1741:ff.c          **** 	lfn[di] = 0;						/* LFN is created */
1742:ff.c          **** 
1743:ff.c          **** 	/* Create SFN in directory form */
1744:ff.c          **** 	mem_set(dj->fn, ' ', 11);
1745:ff.c          **** 	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
1746:ff.c          **** 	if (si) cf |= NS_LOSS | NS_LFN;
1747:ff.c          **** 	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
1748:ff.c          **** 
1749:ff.c          **** 	b = i = 0; ni = 8;
1750:ff.c          **** 	for (;;) {
1751:ff.c          **** 		w = lfn[si++];					/* Get an LFN char */
1752:ff.c          **** 		if (!w) break;					/* Break on end of the LFN */
1753:ff.c          **** 		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
1754:ff.c          **** 			cf |= NS_LOSS | NS_LFN; continue;
1755:ff.c          **** 		}
1756:ff.c          **** 
1757:ff.c          **** 		if (i >= ni || si == di) {		/* Extension or end of SFN */
1758:ff.c          **** 			if (ni == 11) {				/* Long extension */
1759:ff.c          **** 				cf |= NS_LOSS | NS_LFN; break;
1760:ff.c          **** 			}
1761:ff.c          **** 			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
1762:ff.c          **** 			if (si > di) break;			/* No extension */
1763:ff.c          **** 			si = di; i = 8; ni = 11;	/* Enter extension section */
1764:ff.c          **** 			b <<= 2; continue;
1765:ff.c          **** 		}
1766:ff.c          **** 
1767:ff.c          **** 		if (w >= 0x80) {				/* Non ASCII char */
1768:ff.c          **** #ifdef _EXCVT
1769:ff.c          **** 			w = ff_convert(w, 0);		/* Unicode -> OEM code */
1770:ff.c          **** 			if (w) w = ExCvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
1771:ff.c          **** #else
1772:ff.c          **** 			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
1773:ff.c          **** #endif
1774:ff.c          **** 			cf |= NS_LFN;				/* Force create LFN entry */
1775:ff.c          **** 		}
1776:ff.c          **** 
1777:ff.c          **** 		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
1778:ff.c          **** 			if (i >= ni - 1) {
1779:ff.c          **** 				cf |= NS_LOSS | NS_LFN; i = ni; continue;
1780:ff.c          **** 			}
1781:ff.c          **** 			dj->fn[i++] = (BYTE)(w >> 8);
1782:ff.c          **** 		} else {						/* Single byte char */
1783:ff.c          **** 			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
1784:ff.c          **** 				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
1785:ff.c          **** 			} else {
1786:ff.c          **** 				if (IsUpper(w)) {		/* ASCII large capital */
1787:ff.c          **** 					b |= 2;
1788:ff.c          **** 				} else {
1789:ff.c          **** 					if (IsLower(w)) {	/* ASCII small capital */
1790:ff.c          **** 						b |= 1; w -= 0x20;
1791:ff.c          **** 					}
1792:ff.c          **** 				}
1793:ff.c          **** 			}
1794:ff.c          **** 		}
1795:ff.c          **** 		dj->fn[i++] = (BYTE)w;
1796:ff.c          **** 	}
1797:ff.c          **** 
1798:ff.c          **** 	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace i
1799:ff.c          **** 
1800:ff.c          **** 	if (ni == 8) b <<= 2;
1801:ff.c          **** 	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capital
1802:ff.c          **** 		cf |= NS_LFN;
1803:ff.c          **** 	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are create
1804:ff.c          **** 		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
1805:ff.c          **** 		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
1806:ff.c          **** 	}
1807:ff.c          **** 
1808:ff.c          **** 	dj->fn[NS] = cf;	/* SFN is created */
1809:ff.c          **** 
1810:ff.c          **** 	return FR_OK;
1811:ff.c          **** 
1812:ff.c          **** 
1813:ff.c          **** #else	/* Non-LFN configuration */
1814:ff.c          **** 	BYTE b, c, d, *sfn;
1815:ff.c          **** 	UINT ni, si, i;
1816:ff.c          **** 	const char *p;
1817:ff.c          **** 
1818:ff.c          **** 	/* Create file name in directory form */
1819:ff.c          **** 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
1820:ff.c          **** 	sfn = dj->fn;
1821:ff.c          **** 	mem_set(sfn, ' ', 11);
1822:ff.c          **** 	si = i = b = 0; ni = 8;
1823:ff.c          **** #if _FS_RPATH
1824:ff.c          **** 	if (p[si] == '.') { /* Is this a dot entry? */
1825:ff.c          **** 		for (;;) {
1826:ff.c          **** 			c = (BYTE)p[si++];
1827:ff.c          **** 			if (c != '.' || si >= 3) break;
1828:ff.c          **** 			sfn[i++] = c;
1829:ff.c          **** 		}
1830:ff.c          **** 		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
1831:ff.c          **** 		*path = &p[si];									/* Return pointer to the next segment */
1832:ff.c          **** 		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
1833:ff.c          **** 		return FR_OK;
1834:ff.c          **** 	}
1835:ff.c          **** #endif
1836:ff.c          **** 	for (;;) {
1837:ff.c          **** 		c = (BYTE)p[si++];
1838:ff.c          **** 		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
1839:ff.c          **** 		if (c == '.' || i >= ni) {
1840:ff.c          **** 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
1841:ff.c          **** 			i = 8; ni = 11;
1842:ff.c          **** 			b <<= 2; continue;
1843:ff.c          **** 		}
1844:ff.c          **** 		if (c >= 0x80) {				/* Extended char? */
1845:ff.c          **** 			b |= 3;						/* Eliminate NT flag */
1846:ff.c          **** #ifdef _EXCVT
1847:ff.c          **** 			c = ExCvt[c - 0x80];		/* To upper extended chars (SBCS cfg) */
1848:ff.c          **** #else
1849:ff.c          **** #if !_DF1S
1850:ff.c          **** 			return FR_INVALID_NAME;		/* Reject extended chars (ASCII cfg) */
1851:ff.c          **** #endif
1852:ff.c          **** #endif
1853:ff.c          **** 		}
1854:ff.c          **** 		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
1855:ff.c          **** 			d = (BYTE)p[si++];			/* Get 2nd byte */
1856:ff.c          **** 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
1857:ff.c          **** 				return FR_INVALID_NAME;
1858:ff.c          **** 			sfn[i++] = c;
1859:ff.c          **** 			sfn[i++] = d;
1860:ff.c          **** 		} else {						/* Single byte code */
1861:ff.c          **** 			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
1862:ff.c          **** 				return FR_INVALID_NAME;
1863:ff.c          **** 			if (IsUpper(c)) {			/* ASCII large capital? */
1864:ff.c          **** 				b |= 2;
1865:ff.c          **** 			} else {
1866:ff.c          **** 				if (IsLower(c)) {		/* ASCII small capital? */
1867:ff.c          **** 					b |= 1; c -= 0x20;
1868:ff.c          **** 				}
1869:ff.c          **** 			}
1870:ff.c          **** 			sfn[i++] = c;
1871:ff.c          **** 		}
1872:ff.c          **** 	}
1873:ff.c          **** 	*path = &p[si];						/* Return pointer to the next segment */
1874:ff.c          **** 	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
1875:ff.c          **** 
1876:ff.c          **** 	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
1877:ff.c          **** 	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
1878:ff.c          **** 
1879:ff.c          **** 	if (ni == 8) b <<= 2;
1880:ff.c          **** 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
1881:ff.c          **** 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
1882:ff.c          **** 
1883:ff.c          **** 	sfn[NS] = c;		/* Store NT flag, File name is created */
1884:ff.c          **** 
1885:ff.c          **** 	return FR_OK;
1886:ff.c          **** #endif
1887:ff.c          **** }
1888:ff.c          **** 
1889:ff.c          **** 
1890:ff.c          **** 
1891:ff.c          **** 
1892:ff.c          **** /*-----------------------------------------------------------------------*/
1893:ff.c          **** /* Get file information from directory entry                             */
1894:ff.c          **** /*-----------------------------------------------------------------------*/
1895:ff.c          **** #if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2
1896:ff.c          **** static
1897:ff.c          **** void get_fileinfo (		/* No return code */
1898:ff.c          **** 	DIR *dj,			/* Pointer to the directory object */
1899:ff.c          **** 	FILINFO *fno	 	/* Pointer to the file information to be filled */
1900:ff.c          **** )
1901:ff.c          **** {
 108               	.LM7:
 109               	.LFBB2:
 110 0016 0F93      		push r16
 111 0018 1F93      		push r17
 112 001a CF93      		push r28
 113 001c DF93      		push r29
 114               	/* prologue: function */
 115               	/* frame size = 0 */
 116               	/* stack size = 4 */
 117               	.L__stack_usage = 4
 118 001e 9B01      		movw r18,r22
1902:ff.c          **** 	UINT i;
1903:ff.c          **** 	BYTE nt, *dir;
1904:ff.c          **** 	TCHAR *p, c;
1905:ff.c          **** 
1906:ff.c          **** 
1907:ff.c          **** 	p = fno->fname;
 120               	.LM8:
 121 0020 8B01      		movw r16,r22
 122 0022 075F      		subi r16,-9
 123 0024 1F4F      		sbci r17,-1
1908:ff.c          **** 	if (dj->sect) {
 125               	.LM9:
 126 0026 DC01      		movw r26,r24
 127 0028 1E96      		adiw r26,14
 128 002a 4D91      		ld r20,X+
 129 002c 5D91      		ld r21,X+
 130 002e 6D91      		ld r22,X+
 131 0030 7C91      		ld r23,X
 132 0032 5197      		sbiw r26,14+3
 133 0034 452B      		or r20,r21
 134 0036 462B      		or r20,r22
 135 0038 472B      		or r20,r23
 136 003a 01F4      		brne .+2
 137 003c 00C0      		rjmp .L5
1909:ff.c          **** 		dir = dj->dir;
 139               	.LM10:
 140 003e 5296      		adiw r26,18
 141 0040 ED91      		ld r30,X+
 142 0042 FC91      		ld r31,X
 143 0044 5397      		sbiw r26,18+1
 144 0046 DF01      		movw r26,r30
 145 0048 C801      		movw r24,r16
1910:ff.c          **** 		nt = dir[DIR_NTres];		/* NT flag */
1911:ff.c          **** 		for (i = 0; i < 8; i++) {	/* Copy name body */
 147               	.LM11:
 148 004a 40E0      		ldi r20,0
 149 004c 50E0      		ldi r21,0
 150               	.L8:
 151 004e 8C01      		movw r16,r24
1912:ff.c          **** 			c = dir[i];
 153               	.LM12:
 154 0050 6D91      		ld r22,X+
1913:ff.c          **** 			if (c == ' ') break;
 156               	.LM13:
 157 0052 6032      		cpi r22,lo8(32)
 158 0054 01F0      		breq .L6
1914:ff.c          **** 			if (c == NDDE) c = (TCHAR)DDE;
 160               	.LM14:
 161 0056 6530      		cpi r22,lo8(5)
 162 0058 01F4      		brne .L7
 163 005a 65EE      		ldi r22,lo8(-27)
 164               	.L7:
1915:ff.c          **** 			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
1916:ff.c          **** #if _LFN_UNICODE
1917:ff.c          **** 			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
1918:ff.c          **** 				c = (c << 8) | dir[++i];
1919:ff.c          **** 			c = ff_convert(c, 1);
1920:ff.c          **** 			if (!c) c = '?';
1921:ff.c          **** #endif
1922:ff.c          **** 			*p++ = c;
 166               	.LM15:
 167 005c EC01      		movw r28,r24
 168 005e 6993      		st Y+,r22
 169 0060 CE01      		movw r24,r28
 170 0062 8E01      		movw r16,r28
1911:ff.c          **** 		for (i = 0; i < 8; i++) {	/* Copy name body */
 172               	.LM16:
 173 0064 4F5F      		subi r20,-1
 174 0066 5F4F      		sbci r21,-1
 175 0068 4830      		cpi r20,8
 176 006a 5105      		cpc r21,__zero_reg__
 177 006c 01F4      		brne .L8
 178               	.L6:
1923:ff.c          **** 		}
1924:ff.c          **** 		if (dir[8] != ' ') {		/* Copy name extension */
 180               	.LM17:
 181 006e 4085      		ldd r20,Z+8
 182 0070 4032      		cpi r20,lo8(32)
 183 0072 01F0      		breq .L9
1925:ff.c          **** 			*p++ = '.';
 185               	.LM18:
 186 0074 DC01      		movw r26,r24
 187 0076 4EE2      		ldi r20,lo8(46)
 188 0078 4D93      		st X+,r20
1897:ff.c          **** void get_fileinfo (		/* No return code */
 190               	.LM19:
 191 007a AF01      		movw r20,r30
 192 007c 485F      		subi r20,-8
 193 007e 5F4F      		sbci r21,-1
 194 0080 0496      		adiw r24,4
 195               	.L10:
 196 0082 8D01      		movw r16,r26
1926:ff.c          **** 			for (i = 8; i < 11; i++) {
1927:ff.c          **** 				c = dir[i];
 198               	.LM20:
 199 0084 EA01      		movw r28,r20
 200 0086 6991      		ld r22,Y+
 201 0088 AE01      		movw r20,r28
1928:ff.c          **** 				if (c == ' ') break;
 203               	.LM21:
 204 008a 6032      		cpi r22,lo8(32)
 205 008c 01F0      		breq .L9
1929:ff.c          **** 				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
1930:ff.c          **** #if _LFN_UNICODE
1931:ff.c          **** 				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
1932:ff.c          **** 					c = (c << 8) | dir[++i];
1933:ff.c          **** 				c = ff_convert(c, 1);
1934:ff.c          **** 				if (!c) c = '?';
1935:ff.c          **** #endif
1936:ff.c          **** 				*p++ = c;
 207               	.LM22:
 208 008e 6D93      		st X+,r22
 209 0090 8D01      		movw r16,r26
1926:ff.c          **** 			for (i = 8; i < 11; i++) {
 211               	.LM23:
 212 0092 A817      		cp r26,r24
 213 0094 B907      		cpc r27,r25
 214 0096 01F4      		brne .L10
 215               	.L9:
1937:ff.c          **** 			}
1938:ff.c          **** 		}
1939:ff.c          **** 		fno->fattrib = dir[DIR_Attr];				/* Attribute */
 217               	.LM24:
 218 0098 8385      		ldd r24,Z+11
 219 009a D901      		movw r26,r18
 220 009c 1896      		adiw r26,8
 221 009e 8C93      		st X,r24
1940:ff.c          **** 		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
 223               	.LM25:
 224 00a0 478D      		ldd r20,Z+31
 225 00a2 868D      		ldd r24,Z+30
 226 00a4 90E0      		ldi r25,0
 227 00a6 A0E0      		ldi r26,0
 228 00a8 B0E0      		ldi r27,0
 229 00aa DC01      		movw r26,r24
 230 00ac 9927      		clr r25
 231 00ae 8827      		clr r24
 232 00b0 B42B      		or r27,r20
 233 00b2 448D      		ldd r20,Z+28
 234 00b4 842B      		or r24,r20
 235 00b6 558D      		ldd r21,Z+29
 236 00b8 40E0      		ldi r20,0
 237 00ba 60E0      		ldi r22,0
 238 00bc 70E0      		ldi r23,0
 239 00be 842B      		or r24,r20
 240 00c0 952B      		or r25,r21
 241 00c2 A62B      		or r26,r22
 242 00c4 B72B      		or r27,r23
 243 00c6 E901      		movw r28,r18
 244 00c8 8883      		st Y,r24
 245 00ca 9983      		std Y+1,r25
 246 00cc AA83      		std Y+2,r26
 247 00ce BB83      		std Y+3,r27
1941:ff.c          **** 		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
 249               	.LM26:
 250 00d0 918D      		ldd r25,Z+25
 251 00d2 80E0      		ldi r24,0
 252 00d4 408D      		ldd r20,Z+24
 253 00d6 842B      		or r24,r20
 254 00d8 9D83      		std Y+5,r25
 255 00da 8C83      		std Y+4,r24
1942:ff.c          **** 		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
 257               	.LM27:
 258 00dc 9789      		ldd r25,Z+23
 259 00de 80E0      		ldi r24,0
 260 00e0 4689      		ldd r20,Z+22
 261 00e2 842B      		or r24,r20
 262 00e4 9F83      		std Y+7,r25
 263 00e6 8E83      		std Y+6,r24
 264               	.L5:
1943:ff.c          **** 	}
1944:ff.c          **** 	*p = 0;		/* Terminate SFN str by a \0 */
 266               	.LM28:
 267 00e8 F801      		movw r30,r16
 268 00ea 1082      		st Z,__zero_reg__
 269               	/* epilogue start */
1945:ff.c          **** 
1946:ff.c          **** #if _USE_LFN
1947:ff.c          **** 	if (fno->lfname && fno->lfsize) {
1948:ff.c          **** 		TCHAR *tp = fno->lfname;
1949:ff.c          **** 		WCHAR w, *lfn;
1950:ff.c          **** 
1951:ff.c          **** 		i = 0;
1952:ff.c          **** 		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
1953:ff.c          **** 			lfn = dj->lfn;
1954:ff.c          **** 			while ((w = *lfn++) != 0) {			/* Get an LFN char */
1955:ff.c          **** #if !_LFN_UNICODE
1956:ff.c          **** 				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
1957:ff.c          **** 				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
1958:ff.c          **** 				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
1959:ff.c          **** 					tp[i++] = (TCHAR)(w >> 8);
1960:ff.c          **** #endif
1961:ff.c          **** 				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
1962:ff.c          **** 				tp[i++] = (TCHAR)w;
1963:ff.c          **** 			}
1964:ff.c          **** 		}
1965:ff.c          **** 		tp[i] = 0;	/* Terminate the LFN str by a \0 */
1966:ff.c          **** 	}
1967:ff.c          **** #endif
1968:ff.c          **** }
 271               	.LM29:
 272 00ec DF91      		pop r29
 273 00ee CF91      		pop r28
 274 00f0 1F91      		pop r17
 275 00f2 0F91      		pop r16
 276 00f4 0895      		ret
 282               	.Lscope2:
 284               		.stabd	78,0,0
 288               	validate:
 289               		.stabd	46,0,0
1969:ff.c          **** #endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2*/
1970:ff.c          **** 
1971:ff.c          **** 
1972:ff.c          **** 
1973:ff.c          **** 
1974:ff.c          **** /*-----------------------------------------------------------------------*/
1975:ff.c          **** /* Follow a file path                                                    */
1976:ff.c          **** /*-----------------------------------------------------------------------*/
1977:ff.c          **** 
1978:ff.c          **** static
1979:ff.c          **** FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
1980:ff.c          **** 	DIR *dj,			/* Directory object to return last directory and found object */
1981:ff.c          **** 	const TCHAR *path	/* Full-path string to find a file or directory */
1982:ff.c          **** )
1983:ff.c          **** {
1984:ff.c          **** 	FRESULT res;
1985:ff.c          **** 	BYTE *dir, ns;
1986:ff.c          **** 
1987:ff.c          **** 
1988:ff.c          **** #if _FS_RPATH
1989:ff.c          **** 	if (*path == '/' || *path == '\\') { /* There is a heading separator */
1990:ff.c          **** 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
1991:ff.c          **** 	} else {							/* No heading separator */
1992:ff.c          **** 		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
1993:ff.c          **** 	}
1994:ff.c          **** #else
1995:ff.c          **** 	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
1996:ff.c          **** 		path++;
1997:ff.c          **** 	dj->sclust = 0;						/* Start from the root dir */
1998:ff.c          **** #endif
1999:ff.c          **** 
2000:ff.c          **** 	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
2001:ff.c          **** 		res = dir_sdi(dj, 0);
2002:ff.c          **** 		dj->dir = 0;
2003:ff.c          **** 	} else {							/* Follow path */
2004:ff.c          **** 		for (;;) {
2005:ff.c          **** 			res = create_name(dj, &path);	/* Get a segment */
2006:ff.c          **** 			if (res != FR_OK) break;
2007:ff.c          **** 			res = dir_find(dj);				/* Find it */
2008:ff.c          **** 			ns = *(dj->fn+NS);
2009:ff.c          **** 			if (res != FR_OK) {				/* Failed to find the object */
2010:ff.c          **** 				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
2011:ff.c          **** 				/* Object not found */
2012:ff.c          **** 				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
2013:ff.c          **** 					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
2014:ff.c          **** 					res = FR_OK;
2015:ff.c          **** 					if (!(ns & NS_LAST)) continue;
2016:ff.c          **** 				} else {							/* Could not find the object */
2017:ff.c          **** 					if (!(ns & NS_LAST)) res = FR_NO_PATH;
2018:ff.c          **** 				}
2019:ff.c          **** 				break;
2020:ff.c          **** 			}
2021:ff.c          **** 			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
2022:ff.c          **** 			dir = dj->dir;						/* There is next segment. Follow the sub directory */
2023:ff.c          **** 			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
2024:ff.c          **** 				res = FR_NO_PATH; break;
2025:ff.c          **** 			}
2026:ff.c          **** 			dj->sclust = ld_clust(dj->fs, dir);
2027:ff.c          **** 		}
2028:ff.c          **** 	}
2029:ff.c          **** 
2030:ff.c          **** 	return res;
2031:ff.c          **** }
2032:ff.c          **** 
2033:ff.c          **** 
2034:ff.c          **** 
2035:ff.c          **** 
2036:ff.c          **** /*-----------------------------------------------------------------------*/
2037:ff.c          **** /* Load a sector and check if it is an FAT Volume Boot Record            */
2038:ff.c          **** /*-----------------------------------------------------------------------*/
2039:ff.c          **** 
2040:ff.c          **** static
2041:ff.c          **** BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
2042:ff.c          **** 	FATFS *fs,	/* File system object */
2043:ff.c          **** 	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
2044:ff.c          **** )
2045:ff.c          **** {
2046:ff.c          **** 	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
2047:ff.c          **** 		return 3;
2048:ff.c          **** 	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 
2049:ff.c          **** 		return 2;
2050:ff.c          **** 
2051:ff.c          **** 	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
2052:ff.c          **** 		return 0;
2053:ff.c          **** 	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
2054:ff.c          **** 		return 0;
2055:ff.c          **** 
2056:ff.c          **** 	return 1;
2057:ff.c          **** }
2058:ff.c          **** 
2059:ff.c          **** 
2060:ff.c          **** 
2061:ff.c          **** 
2062:ff.c          **** /*-----------------------------------------------------------------------*/
2063:ff.c          **** /* Check if the file system object is valid or not                       */
2064:ff.c          **** /*-----------------------------------------------------------------------*/
2065:ff.c          **** 
2066:ff.c          **** static
2067:ff.c          **** FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
2068:ff.c          **** 	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
2069:ff.c          **** 	FATFS **rfs,		/* Pointer to pointer to the found file system object */
2070:ff.c          **** 	BYTE wmode			/* !=0: Check write protection for write access */
2071:ff.c          **** )
2072:ff.c          **** {
2073:ff.c          **** 	BYTE fmt, b, pi, *tbl;
2074:ff.c          **** 	UINT vol;
2075:ff.c          **** 	DSTATUS stat;
2076:ff.c          **** 	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
2077:ff.c          **** 	WORD nrsv;
2078:ff.c          **** 	const TCHAR *p = *path;
2079:ff.c          **** 	FATFS *fs;
2080:ff.c          **** 
2081:ff.c          **** 
2082:ff.c          **** 	/* Get logical drive number from the path name */
2083:ff.c          **** 	vol = p[0] - '0';					/* Is there a drive number? */
2084:ff.c          **** 	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
2085:ff.c          **** 		p += 2; *path = p;				/* Return pointer to the path name */
2086:ff.c          **** 	} else {							/* No drive number, use default drive */
2087:ff.c          **** #if _FS_RPATH
2088:ff.c          **** 		vol = CurrVol;					/* Use current drive */
2089:ff.c          **** #else
2090:ff.c          **** 		vol = 0;						/* Use drive 0 */
2091:ff.c          **** #endif
2092:ff.c          **** 	}
2093:ff.c          **** 
2094:ff.c          **** 	/* Check if the file system object is valid or not */
2095:ff.c          **** 	*rfs = 0;
2096:ff.c          **** 	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
2097:ff.c          **** 		return FR_INVALID_DRIVE;
2098:ff.c          **** 	fs = FatFs[vol];					/* Get corresponding file system object */
2099:ff.c          **** 	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
2100:ff.c          **** 
2101:ff.c          **** 	ENTER_FF(fs);						/* Lock volume */
2102:ff.c          **** 
2103:ff.c          **** 	*rfs = fs;							/* Return pointer to the corresponding file system object */
2104:ff.c          **** 	if (fs->fs_type) {					/* If the volume has been mounted */
2105:ff.c          **** 		stat = disk_status(fs->drv);
2106:ff.c          **** 		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed)
2107:ff.c          **** 			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
2108:ff.c          **** 				return FR_WRITE_PROTECTED;
2109:ff.c          **** 			return FR_OK;				/* The file system object is valid */
2110:ff.c          **** 		}
2111:ff.c          **** 	}
2112:ff.c          **** 
2113:ff.c          **** 	/* The file system object is not valid. */
2114:ff.c          **** 	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
2115:ff.c          **** 
2116:ff.c          **** 	fs->fs_type = 0;					/* Clear the file system object */
2117:ff.c          **** 	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
2118:ff.c          **** 	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
2119:ff.c          **** 	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
2120:ff.c          **** 		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
2121:ff.c          **** 	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
2122:ff.c          **** 		return FR_WRITE_PROTECTED;
2123:ff.c          **** #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
2124:ff.c          **** 	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
2125:ff.c          **** 		return FR_DISK_ERR;
2126:ff.c          **** #endif
2127:ff.c          **** 	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
2128:ff.c          **** 	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
2129:ff.c          **** 	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
2130:ff.c          **** 	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
2131:ff.c          **** 		/* Check the partition listed in the partition table */
2132:ff.c          **** 		pi = LD2PT(vol);
2133:ff.c          **** 		if (pi) pi--;
2134:ff.c          **** 		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
2135:ff.c          **** 		if (tbl[4]) {						/* Is the partition existing? */
2136:ff.c          **** 			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
2137:ff.c          **** 			fmt = check_fs(fs, bsect);		/* Check the partition */
2138:ff.c          **** 		}
2139:ff.c          **** 	}
2140:ff.c          **** 	if (fmt == 3) return FR_DISK_ERR;
2141:ff.c          **** 	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
2142:ff.c          **** 
2143:ff.c          **** 	/* An FAT volume is found. Following code initializes the file system object */
2144:ff.c          **** 
2145:ff.c          **** 	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical s
2146:ff.c          **** 		return FR_NO_FILESYSTEM;
2147:ff.c          **** 
2148:ff.c          **** 	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
2149:ff.c          **** 	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
2150:ff.c          **** 	fs->fsize = fasize;
2151:ff.c          **** 
2152:ff.c          **** 	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
2153:ff.c          **** 	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
2154:ff.c          **** 	fasize *= b;										/* Number of sectors for FAT area */
2155:ff.c          **** 
2156:ff.c          **** 	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
2157:ff.c          **** 	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
2158:ff.c          **** 
2159:ff.c          **** 	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
2160:ff.c          **** 	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector 
2161:ff.c          **** 
2162:ff.c          **** 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
2163:ff.c          **** 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
2164:ff.c          **** 
2165:ff.c          **** 	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
2166:ff.c          **** 	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
2167:ff.c          **** 
2168:ff.c          **** 	/* Determine the FAT sub type */
2169:ff.c          **** 	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
2170:ff.c          **** 	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
2171:ff.c          **** 	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
2172:ff.c          **** 	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
2173:ff.c          **** 	fmt = FS_FAT12;
2174:ff.c          **** 	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
2175:ff.c          **** 	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
2176:ff.c          **** 
2177:ff.c          **** 	/* Boundaries and Limits */
2178:ff.c          **** 	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
2179:ff.c          **** 	fs->volbase = bsect;								/* Volume start sector */
2180:ff.c          **** 	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
2181:ff.c          **** 	fs->database = bsect + sysect;						/* Data start sector */
2182:ff.c          **** 	if (fmt == FS_FAT32) {
2183:ff.c          **** 		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
2184:ff.c          **** 		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
2185:ff.c          **** 		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
2186:ff.c          **** 	} else {
2187:ff.c          **** 		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
2188:ff.c          **** 		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
2189:ff.c          **** 		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
2190:ff.c          **** 			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
2191:ff.c          **** 	}
2192:ff.c          **** 	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
2193:ff.c          **** 		return FR_NO_FILESYSTEM;
2194:ff.c          **** 
2195:ff.c          **** #if !_FS_READONLY
2196:ff.c          **** 	/* Initialize cluster allocation information */
2197:ff.c          **** 	fs->free_clust = 0xFFFFFFFF;
2198:ff.c          **** 	fs->last_clust = 0;
2199:ff.c          **** 
2200:ff.c          **** 	/* Get fsinfo if available */
2201:ff.c          **** 	if (fmt == FS_FAT32) {
2202:ff.c          **** 	 	fs->fsi_flag = 0;
2203:ff.c          **** 		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
2204:ff.c          **** 		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
2205:ff.c          **** 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
2206:ff.c          **** 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
2207:ff.c          **** 			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
2208:ff.c          **** 				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
2209:ff.c          **** 				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
2210:ff.c          **** 		}
2211:ff.c          **** 	}
2212:ff.c          **** #endif
2213:ff.c          **** 	fs->fs_type = fmt;		/* FAT sub-type */
2214:ff.c          **** 	fs->id = ++Fsid;		/* File system mount ID */
2215:ff.c          **** 	fs->winsect = 0;		/* Invalidate sector cache */
2216:ff.c          **** 	fs->wflag = 0;
2217:ff.c          **** #if _FS_RPATH
2218:ff.c          **** 	fs->cdir = 0;			/* Current directory (root dir) */
2219:ff.c          **** #endif
2220:ff.c          **** #if _FS_LOCK				/* Clear file lock semaphores */
2221:ff.c          **** 	clear_lock(fs);
2222:ff.c          **** #endif
2223:ff.c          **** 
2224:ff.c          **** 	return FR_OK;
2225:ff.c          **** }
2226:ff.c          **** 
2227:ff.c          **** 
2228:ff.c          **** 
2229:ff.c          **** 
2230:ff.c          **** /*-----------------------------------------------------------------------*/
2231:ff.c          **** /* Check if the file/dir object is valid or not                          */
2232:ff.c          **** /*-----------------------------------------------------------------------*/
2233:ff.c          **** 
2234:ff.c          **** static
2235:ff.c          **** FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
2236:ff.c          **** 	void* obj		/* Pointer to the object FIL/DIR to check validity */
2237:ff.c          **** )
2238:ff.c          **** {
 291               	.LM30:
 292               	.LFBB3:
 293               	/* prologue: function */
 294               	/* frame size = 0 */
 295               	/* stack size = 0 */
 296               	.L__stack_usage = 0
2239:ff.c          **** 	FIL *fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
2240:ff.c          **** 
2241:ff.c          **** 
2242:ff.c          **** 	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 298               	.LM31:
 299 00f6 0097      		sbiw r24,0
 300 00f8 01F0      		breq .L31
 302               	.LM32:
 303 00fa DC01      		movw r26,r24
 304 00fc ED91      		ld r30,X+
 305 00fe FC91      		ld r31,X
 306 0100 1197      		sbiw r26,1
 307 0102 3097      		sbiw r30,0
 308 0104 01F0      		breq .L31
 309 0106 2081      		ld r18,Z
 310 0108 2223      		tst r18
 311 010a 01F0      		breq .L31
 312 010c 2681      		ldd r18,Z+6
 313 010e 3781      		ldd r19,Z+7
 314 0110 1296      		adiw r26,2
 315 0112 8D91      		ld r24,X+
 316 0114 9C91      		ld r25,X
 317 0116 1397      		sbiw r26,2+1
 318 0118 2817      		cp r18,r24
 319 011a 3907      		cpc r19,r25
 320 011c 01F4      		brne .L31
2243:ff.c          **** 		return FR_INVALID_OBJECT;
2244:ff.c          **** 
2245:ff.c          **** 	ENTER_FF(fil->fs);		/* Lock file system */
2246:ff.c          **** 
2247:ff.c          **** 	if (disk_status(fil->fs->drv) & STA_NOINIT)
 322               	.LM33:
 323 011e 8181      		ldd r24,Z+1
 324 0120 0E94 0000 		call disk_status
 325 0124 80FF      		sbrs r24,0
 326 0126 00C0      		rjmp .L32
2248:ff.c          **** 		return FR_NOT_READY;
 328               	.LM34:
 329 0128 83E0      		ldi r24,lo8(3)
 330 012a 0895      		ret
 331               	.L31:
2243:ff.c          **** 		return FR_INVALID_OBJECT;
 333               	.LM35:
 334 012c 89E0      		ldi r24,lo8(9)
 335 012e 0895      		ret
 336               	.L32:
2249:ff.c          **** 
2250:ff.c          **** 	return FR_OK;
 338               	.LM36:
 339 0130 80E0      		ldi r24,0
2251:ff.c          **** }
 341               	.LM37:
 342 0132 0895      		ret
 344               	.Lscope3:
 346               		.stabd	78,0,0
 351               	ld_clust.isra.0:
 352               		.stabd	46,0,0
1239:ff.c          **** DWORD ld_clust (
 354               	.LM38:
 355               	.LFBB4:
 356 0134 0F93      		push r16
 357 0136 1F93      		push r17
 358               	/* prologue: function */
 359               	/* frame size = 0 */
 360               	/* stack size = 2 */
 361               	.L__stack_usage = 2
 362 0138 FB01      		movw r30,r22
1246:ff.c          **** 	cl = LD_WORD(dir+DIR_FstClusLO);
 364               	.LM39:
 365 013a 338D      		ldd r19,Z+27
 366 013c 20E0      		ldi r18,0
 367 013e 928D      		ldd r25,Z+26
 368 0140 8901      		movw r16,r18
 369 0142 092B      		or r16,r25
 370 0144 20E0      		ldi r18,0
 371 0146 30E0      		ldi r19,0
1247:ff.c          **** 	if (fs->fs_type == FS_FAT32)
 373               	.LM40:
 374 0148 8330      		cpi r24,lo8(3)
 375 014a 01F4      		brne .L34
1248:ff.c          **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 377               	.LM41:
 378 014c 9589      		ldd r25,Z+21
 379 014e 80E0      		ldi r24,0
 380 0150 4489      		ldd r20,Z+20
 381 0152 842B      		or r24,r20
 382 0154 A0E0      		ldi r26,0
 383 0156 B0E0      		ldi r27,0
 384 0158 DC01      		movw r26,r24
 385 015a 9927      		clr r25
 386 015c 8827      		clr r24
 387 015e 082B      		or r16,r24
 388 0160 192B      		or r17,r25
 389 0162 2A2B      		or r18,r26
 390 0164 3B2B      		or r19,r27
 391               	.L34:
1251:ff.c          **** }
 393               	.LM42:
 394 0166 B801      		movw r22,r16
 395 0168 C901      		movw r24,r18
 396               	/* epilogue start */
 397 016a 1F91      		pop r17
 398 016c 0F91      		pop r16
 399 016e 0895      		ret
 404               	.Lscope4:
 406               		.stabd	78,0,0
 411               	check_fs:
 412               		.stabd	46,0,0
2045:ff.c          **** {
 414               	.LM43:
 415               	.LFBB5:
 416 0170 0F93      		push r16
 417 0172 CF93      		push r28
 418 0174 DF93      		push r29
 419               	/* prologue: function */
 420               	/* frame size = 0 */
 421               	/* stack size = 3 */
 422               	.L__stack_usage = 3
 423 0176 EC01      		movw r28,r24
2046:ff.c          **** 	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 425               	.LM44:
 426 0178 C296      		adiw r24,50
 427 017a 01E0      		ldi r16,lo8(1)
 428 017c 9A01      		movw r18,r20
 429 017e AB01      		movw r20,r22
 430 0180 BC01      		movw r22,r24
 431 0182 8981      		ldd r24,Y+1
 432 0184 0E94 0000 		call disk_read
 433 0188 8111      		cpse r24,__zero_reg__
 434 018a 00C0      		rjmp .L38
2048:ff.c          **** 	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 
 436               	.LM45:
 437 018c FE01      		movw r30,r28
 438 018e EF5C      		subi r30,-49
 439 0190 FD4F      		sbci r31,-3
 440 0192 9081      		ld r25,Z
 441 0194 80E0      		ldi r24,0
 442 0196 FE01      		movw r30,r28
 443 0198 E05D      		subi r30,-48
 444 019a FD4F      		sbci r31,-3
 445 019c 2081      		ld r18,Z
 446 019e 822B      		or r24,r18
 447 01a0 8535      		cpi r24,85
 448 01a2 9A4A      		sbci r25,-86
 449 01a4 01F0      		breq .+2
 450 01a6 00C0      		rjmp .L39
2051:ff.c          **** 	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 452               	.LM46:
 453 01a8 FE01      		movw r30,r28
 454 01aa E559      		subi r30,-107
 455 01ac FF4F      		sbci r31,-1
 456 01ae 8081      		ld r24,Z
 457 01b0 FE01      		movw r30,r28
 458 01b2 E659      		subi r30,-106
 459 01b4 FF4F      		sbci r31,-1
 460 01b6 4081      		ld r20,Z
 461 01b8 50E0      		ldi r21,0
 462 01ba 60E0      		ldi r22,0
 463 01bc 70E0      		ldi r23,0
 464 01be BA01      		movw r22,r20
 465 01c0 5527      		clr r21
 466 01c2 4427      		clr r20
 467 01c4 782B      		or r23,r24
 468 01c6 FE01      		movw r30,r28
 469 01c8 E859      		subi r30,-104
 470 01ca FF4F      		sbci r31,-1
 471 01cc 8081      		ld r24,Z
 472 01ce 482B      		or r20,r24
 473 01d0 FE01      		movw r30,r28
 474 01d2 E759      		subi r30,-105
 475 01d4 FF4F      		sbci r31,-1
 476 01d6 9081      		ld r25,Z
 477 01d8 80E0      		ldi r24,0
 478 01da A0E0      		ldi r26,0
 479 01dc B0E0      		ldi r27,0
 480 01de 482B      		or r20,r24
 481 01e0 592B      		or r21,r25
 482 01e2 6A2B      		or r22,r26
 483 01e4 7B2B      		or r23,r27
 484 01e6 7727      		clr r23
 485 01e8 4634      		cpi r20,70
 486 01ea 5144      		sbci r21,65
 487 01ec 6445      		sbci r22,84
 488 01ee 7105      		cpc r23,__zero_reg__
 489 01f0 01F0      		breq .L40
 490               	.LBB4:
 491               	.LBB5:
2053:ff.c          **** 	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 493               	.LM47:
 494 01f2 FE01      		movw r30,r28
 495 01f4 E957      		subi r30,121
 496 01f6 FF4F      		sbci r31,-1
 497 01f8 8081      		ld r24,Z
 498 01fa FE01      		movw r30,r28
 499 01fc EA57      		subi r30,122
 500 01fe FF4F      		sbci r31,-1
 501 0200 4081      		ld r20,Z
 502 0202 50E0      		ldi r21,0
 503 0204 60E0      		ldi r22,0
 504 0206 70E0      		ldi r23,0
 505 0208 BA01      		movw r22,r20
 506 020a 5527      		clr r21
 507 020c 4427      		clr r20
 508 020e 782B      		or r23,r24
 509 0210 FE01      		movw r30,r28
 510 0212 EC57      		subi r30,124
 511 0214 FF4F      		sbci r31,-1
 512 0216 8081      		ld r24,Z
 513 0218 482B      		or r20,r24
 514 021a CB57      		subi r28,123
 515 021c DF4F      		sbci r29,-1
 516 021e 9881      		ld r25,Y
 517 0220 80E0      		ldi r24,0
 518 0222 A0E0      		ldi r26,0
 519 0224 B0E0      		ldi r27,0
 520 0226 482B      		or r20,r24
 521 0228 592B      		or r21,r25
 522 022a 6A2B      		or r22,r26
 523 022c 7B2B      		or r23,r27
 524 022e 7727      		clr r23
 525               	.LBE5:
 526               	.LBE4:
 527 0230 81E0      		ldi r24,lo8(1)
 528 0232 4634      		cpi r20,70
 529 0234 5144      		sbci r21,65
 530 0236 6445      		sbci r22,84
 531 0238 7105      		cpc r23,__zero_reg__
 532 023a 01F4      		brne .L36
 533 023c 00C0      		rjmp .L40
 534               	.L38:
2047:ff.c          **** 		return 3;
 536               	.LM48:
 537 023e 83E0      		ldi r24,lo8(3)
 538 0240 00C0      		rjmp .L36
 539               	.L39:
2049:ff.c          **** 		return 2;
 541               	.LM49:
 542 0242 82E0      		ldi r24,lo8(2)
 543 0244 00C0      		rjmp .L36
 544               	.L40:
2052:ff.c          **** 		return 0;
 546               	.LM50:
 547 0246 80E0      		ldi r24,0
 548               	.L36:
 549               	/* epilogue start */
2057:ff.c          **** }
 551               	.LM51:
 552 0248 DF91      		pop r29
 553 024a CF91      		pop r28
 554 024c 0F91      		pop r16
 555 024e 0895      		ret
 557               	.Lscope5:
 559               		.stabd	78,0,0
 565               	chk_mounted:
 566               		.stabd	46,0,0
2072:ff.c          **** {
 568               	.LM52:
 569               	.LFBB6:
 570 0250 2F92      		push r2
 571 0252 3F92      		push r3
 572 0254 4F92      		push r4
 573 0256 5F92      		push r5
 574 0258 6F92      		push r6
 575 025a 7F92      		push r7
 576 025c 8F92      		push r8
 577 025e 9F92      		push r9
 578 0260 AF92      		push r10
 579 0262 BF92      		push r11
 580 0264 CF92      		push r12
 581 0266 DF92      		push r13
 582 0268 EF92      		push r14
 583 026a FF92      		push r15
 584 026c 0F93      		push r16
 585 026e 1F93      		push r17
 586 0270 CF93      		push r28
 587 0272 DF93      		push r29
 588 0274 CDB7      		in r28,__SP_L__
 589 0276 DEB7      		in r29,__SP_H__
 590 0278 2E97      		sbiw r28,14
 591 027a 0FB6      		in __tmp_reg__,__SREG__
 592 027c F894      		cli
 593 027e DEBF      		out __SP_H__,r29
 594 0280 0FBE      		out __SREG__,__tmp_reg__
 595 0282 CDBF      		out __SP_L__,r28
 596               	/* prologue: function */
 597               	/* frame size = 14 */
 598               	/* stack size = 32 */
 599               	.L__stack_usage = 32
 600 0284 142F      		mov r17,r20
2078:ff.c          **** 	const TCHAR *p = *path;
 602               	.LM53:
 603 0286 DC01      		movw r26,r24
 604 0288 ED91      		ld r30,X+
 605 028a FC91      		ld r31,X
 606 028c 1197      		sbiw r26,1
2083:ff.c          **** 	vol = p[0] - '0';					/* Is there a drive number? */
 608               	.LM54:
 609 028e 2081      		ld r18,Z
 610 0290 30E0      		ldi r19,0
 611 0292 2053      		subi r18,48
 612 0294 3109      		sbc r19,__zero_reg__
2084:ff.c          **** 	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 614               	.LM55:
 615 0296 2A30      		cpi r18,10
 616 0298 3105      		cpc r19,__zero_reg__
 617 029a 00F4      		brsh .L60
2084:ff.c          **** 	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 619               	.LM56:
 620 029c 4181      		ldd r20,Z+1
 621 029e 4A33      		cpi r20,lo8(58)
 622 02a0 01F4      		brne .L60
2085:ff.c          **** 		p += 2; *path = p;				/* Return pointer to the path name */
 624               	.LM57:
 625 02a2 3296      		adiw r30,2
 626 02a4 ED93      		st X+,r30
 627 02a6 FC93      		st X,r31
 628 02a8 00C0      		rjmp .L42
 629               	.L60:
2090:ff.c          **** 		vol = 0;						/* Use drive 0 */
 631               	.LM58:
 632 02aa 20E0      		ldi r18,0
 633 02ac 30E0      		ldi r19,0
 634               	.L42:
2095:ff.c          **** 	*rfs = 0;
 636               	.LM59:
 637 02ae FB01      		movw r30,r22
 638 02b0 1182      		std Z+1,__zero_reg__
 639 02b2 1082      		st Z,__zero_reg__
2096:ff.c          **** 	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
 641               	.LM60:
 642 02b4 232B      		or r18,r19
 643 02b6 01F0      		breq .+2
 644 02b8 00C0      		rjmp .L61
2098:ff.c          **** 	fs = FatFs[vol];					/* Get corresponding file system object */
 646               	.LM61:
 647 02ba 2091 0000 		lds r18,FatFs
 648 02be 3091 0000 		lds r19,FatFs+1
 649 02c2 3E87      		std Y+14,r19
 650 02c4 2D87      		std Y+13,r18
2099:ff.c          **** 	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 652               	.LM62:
 653 02c6 2115      		cp r18,__zero_reg__
 654 02c8 3105      		cpc r19,__zero_reg__
 655 02ca 01F4      		brne .+2
 656 02cc 00C0      		rjmp .L62
2103:ff.c          **** 	*rfs = fs;							/* Return pointer to the corresponding file system object */
 658               	.LM63:
 659 02ce 3183      		std Z+1,r19
 660 02d0 2083      		st Z,r18
2104:ff.c          **** 	if (fs->fs_type) {					/* If the volume has been mounted */
 662               	.LM64:
 663 02d2 D901      		movw r26,r18
 664 02d4 8C91      		ld r24,X
 665 02d6 8823      		tst r24
 666 02d8 01F0      		breq .L44
2105:ff.c          **** 		stat = disk_status(fs->drv);
 668               	.LM65:
 669 02da 1196      		adiw r26,1
 670 02dc 8C91      		ld r24,X
 671 02de 0E94 0000 		call disk_status
2106:ff.c          **** 		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed)
 673               	.LM66:
 674 02e2 80FD      		sbrc r24,0
 675 02e4 00C0      		rjmp .L44
2107:ff.c          **** 			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 677               	.LM67:
 678 02e6 1123      		tst r17
 679 02e8 01F4      		brne .+2
 680 02ea 00C0      		rjmp .L64
2107:ff.c          **** 			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 682               	.LM68:
 683 02ec 82FF      		sbrs r24,2
 684 02ee 00C0      		rjmp .L64
 685 02f0 00C0      		rjmp .L66
 686               	.L44:
2116:ff.c          **** 	fs->fs_type = 0;					/* Clear the file system object */
 688               	.LM69:
 689 02f2 ED85      		ldd r30,Y+13
 690 02f4 FE85      		ldd r31,Y+14
 691 02f6 1082      		st Z,__zero_reg__
2117:ff.c          **** 	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 693               	.LM70:
 694 02f8 1182      		std Z+1,__zero_reg__
2118:ff.c          **** 	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 696               	.LM71:
 697 02fa 80E0      		ldi r24,0
 698 02fc 0E94 0000 		call disk_initialize
2119:ff.c          **** 	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 700               	.LM72:
 701 0300 80FD      		sbrc r24,0
 702 0302 00C0      		rjmp .L65
2121:ff.c          **** 	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 704               	.LM73:
 705 0304 1123      		tst r17
 706 0306 01F0      		breq .L45
2121:ff.c          **** 	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 708               	.LM74:
 709 0308 82FD      		sbrc r24,2
 710 030a 00C0      		rjmp .L66
 711               	.L45:
2128:ff.c          **** 	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
 713               	.LM75:
 714 030c 40E0      		ldi r20,0
 715 030e 50E0      		ldi r21,0
 716 0310 BA01      		movw r22,r20
 717 0312 8D85      		ldd r24,Y+13
 718 0314 9E85      		ldd r25,Y+14
 719 0316 0E94 0000 		call check_fs
2130:ff.c          **** 	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
 721               	.LM76:
 722 031a 8130      		cpi r24,lo8(1)
 723 031c 01F4      		brne .L67
2135:ff.c          **** 		if (tbl[4]) {						/* Is the partition existing? */
 725               	.LM77:
 726 031e ED85      		ldd r30,Y+13
 727 0320 FE85      		ldd r31,Y+14
 728 0322 EC50      		subi r30,12
 729 0324 FE4F      		sbci r31,-2
 730 0326 8081      		ld r24,Z
 731 0328 8111      		cpse r24,__zero_reg__
 732 032a 00C0      		rjmp .L47
 733               	.L48:
2141:ff.c          **** 	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 735               	.LM78:
 736 032c 8DE0      		ldi r24,lo8(13)
 737 032e 00C0      		rjmp .L43
 738               	.L47:
2136:ff.c          **** 			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
 740               	.LM79:
 741 0330 ED85      		ldd r30,Y+13
 742 0332 FE85      		ldd r31,Y+14
 743 0334 E550      		subi r30,5
 744 0336 FE4F      		sbci r31,-2
 745 0338 2081      		ld r18,Z
 746 033a ED85      		ldd r30,Y+13
 747 033c FE85      		ldd r31,Y+14
 748 033e E650      		subi r30,6
 749 0340 FE4F      		sbci r31,-2
 750 0342 8081      		ld r24,Z
 751 0344 90E0      		ldi r25,0
 752 0346 A0E0      		ldi r26,0
 753 0348 B0E0      		ldi r27,0
 754 034a 3C01      		movw r6,r24
 755 034c 5524      		clr r5
 756 034e 4424      		clr r4
 757 0350 722A      		or r7,r18
 758 0352 ED85      		ldd r30,Y+13
 759 0354 FE85      		ldd r31,Y+14
 760 0356 E850      		subi r30,8
 761 0358 FE4F      		sbci r31,-2
 762 035a 8081      		ld r24,Z
 763 035c 482A      		or r4,r24
 764 035e ED85      		ldd r30,Y+13
 765 0360 FE85      		ldd r31,Y+14
 766 0362 E750      		subi r30,7
 767 0364 FE4F      		sbci r31,-2
 768 0366 9081      		ld r25,Z
 769 0368 80E0      		ldi r24,0
 770 036a A0E0      		ldi r26,0
 771 036c B0E0      		ldi r27,0
 772 036e 482A      		or r4,r24
 773 0370 592A      		or r5,r25
 774 0372 6A2A      		or r6,r26
 775 0374 7B2A      		or r7,r27
2137:ff.c          **** 			fmt = check_fs(fs, bsect);		/* Check the partition */
 777               	.LM80:
 778 0376 B301      		movw r22,r6
 779 0378 A201      		movw r20,r4
 780 037a 8D85      		ldd r24,Y+13
 781 037c 9E85      		ldd r25,Y+14
 782 037e 0E94 0000 		call check_fs
 783 0382 00C0      		rjmp .L46
 784               	.L67:
2128:ff.c          **** 	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
 786               	.LM81:
 787 0384 412C      		mov r4,__zero_reg__
 788 0386 512C      		mov r5,__zero_reg__
 789 0388 3201      		movw r6,r4
 790               	.L46:
2140:ff.c          **** 	if (fmt == 3) return FR_DISK_ERR;
 792               	.LM82:
 793 038a 8330      		cpi r24,lo8(3)
 794 038c 01F4      		brne .+2
 795 038e 00C0      		rjmp .L68
2141:ff.c          **** 	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 797               	.LM83:
 798 0390 8111      		cpse r24,__zero_reg__
 799 0392 00C0      		rjmp .L48
2145:ff.c          **** 	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical s
 801               	.LM84:
 802 0394 AD85      		ldd r26,Y+13
 803 0396 BE85      		ldd r27,Y+14
 804 0398 DE96      		adiw r26,62
 805 039a 9C91      		ld r25,X
 806 039c DE97      		sbiw r26,62
 807 039e 80E0      		ldi r24,0
 808 03a0 DD96      		adiw r26,61
 809 03a2 2C91      		ld r18,X
 810 03a4 822B      		or r24,r18
 811 03a6 8115      		cp r24,__zero_reg__
 812 03a8 9240      		sbci r25,2
 813 03aa 01F0      		breq .+2
 814 03ac 00C0      		rjmp .L48
2148:ff.c          **** 	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 816               	.LM85:
 817 03ae ED85      		ldd r30,Y+13
 818 03b0 FE85      		ldd r31,Y+14
 819 03b2 E75B      		subi r30,-73
 820 03b4 FF4F      		sbci r31,-1
 821 03b6 9081      		ld r25,Z
 822 03b8 80E0      		ldi r24,0
 823 03ba ED85      		ldd r30,Y+13
 824 03bc FE85      		ldd r31,Y+14
 825 03be E85B      		subi r30,-72
 826 03c0 FF4F      		sbci r31,-1
 827 03c2 2081      		ld r18,Z
 828 03c4 6C01      		movw r12,r24
 829 03c6 C22A      		or r12,r18
 830 03c8 E12C      		mov r14,__zero_reg__
 831 03ca F12C      		mov r15,__zero_reg__
2149:ff.c          **** 	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 833               	.LM86:
 834 03cc C114      		cp r12,__zero_reg__
 835 03ce D104      		cpc r13,__zero_reg__
 836 03d0 E104      		cpc r14,__zero_reg__
 837 03d2 F104      		cpc r15,__zero_reg__
 838 03d4 01F4      		brne .L49
2149:ff.c          **** 	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 840               	.LM87:
 841 03d6 ED85      		ldd r30,Y+13
 842 03d8 FE85      		ldd r31,Y+14
 843 03da E75A      		subi r30,-89
 844 03dc FF4F      		sbci r31,-1
 845 03de 8081      		ld r24,Z
 846 03e0 ED85      		ldd r30,Y+13
 847 03e2 FE85      		ldd r31,Y+14
 848 03e4 E85A      		subi r30,-88
 849 03e6 FF4F      		sbci r31,-1
 850 03e8 C080      		ld r12,Z
 851 03ea D12C      		mov r13,__zero_reg__
 852 03ec E12C      		mov r14,__zero_reg__
 853 03ee F12C      		mov r15,__zero_reg__
 854 03f0 7601      		movw r14,r12
 855 03f2 DD24      		clr r13
 856 03f4 CC24      		clr r12
 857 03f6 F82A      		or r15,r24
 858 03f8 ED85      		ldd r30,Y+13
 859 03fa FE85      		ldd r31,Y+14
 860 03fc EA5A      		subi r30,-86
 861 03fe FF4F      		sbci r31,-1
 862 0400 8081      		ld r24,Z
 863 0402 C82A      		or r12,r24
 864 0404 ED85      		ldd r30,Y+13
 865 0406 FE85      		ldd r31,Y+14
 866 0408 E95A      		subi r30,-87
 867 040a FF4F      		sbci r31,-1
 868 040c 9081      		ld r25,Z
 869 040e 80E0      		ldi r24,0
 870 0410 A0E0      		ldi r26,0
 871 0412 B0E0      		ldi r27,0
 872 0414 C82A      		or r12,r24
 873 0416 D92A      		or r13,r25
 874 0418 EA2A      		or r14,r26
 875 041a FB2A      		or r15,r27
 876               	.L49:
2150:ff.c          **** 	fs->fsize = fasize;
 878               	.LM88:
 879 041c ED85      		ldd r30,Y+13
 880 041e FE85      		ldd r31,Y+14
 881 0420 C28E      		std Z+26,r12
 882 0422 D38E      		std Z+27,r13
 883 0424 E48E      		std Z+28,r14
 884 0426 F58E      		std Z+29,r15
2152:ff.c          **** 	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
 886               	.LM89:
 887 0428 EE5B      		subi r30,-66
 888 042a FF4F      		sbci r31,-1
 889 042c A081      		ld r26,Z
 890 042e ED85      		ldd r30,Y+13
 891 0430 FE85      		ldd r31,Y+14
 892 0432 A383      		std Z+3,r26
2153:ff.c          **** 	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 894               	.LM90:
 895 0434 8A2F      		mov r24,r26
 896 0436 8150      		subi r24,lo8(-(-1))
 897 0438 8230      		cpi r24,lo8(2)
 898 043a 00F0      		brlo .+2
 899 043c 00C0      		rjmp .L48
2156:ff.c          **** 	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
 901               	.LM91:
 902 043e 17AD      		ldd r17,Z+63
 903 0440 1283      		std Z+2,r17
2157:ff.c          **** 	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 905               	.LM92:
 906 0442 1123      		tst r17
 907 0444 01F4      		brne .+2
 908 0446 00C0      		rjmp .L48
2157:ff.c          **** 	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 910               	.LM93:
 911 0448 212F      		mov r18,r17
 912 044a 30E0      		ldi r19,0
 913 044c C901      		movw r24,r18
 914 044e 0197      		sbiw r24,1
 915 0450 8223      		and r24,r18
 916 0452 9323      		and r25,r19
 917 0454 892B      		or r24,r25
 918 0456 01F0      		breq .+2
 919 0458 00C0      		rjmp .L48
2159:ff.c          **** 	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 921               	.LM94:
 922 045a EC5B      		subi r30,-68
 923 045c FF4F      		sbci r31,-1
 924 045e 3080      		ld r3,Z
 925 0460 212C      		mov r2,__zero_reg__
 926 0462 ED85      		ldd r30,Y+13
 927 0464 FE85      		ldd r31,Y+14
 928 0466 ED5B      		subi r30,-67
 929 0468 FF4F      		sbci r31,-1
 930 046a 8081      		ld r24,Z
 931 046c 282A      		or r2,r24
 932 046e ED85      		ldd r30,Y+13
 933 0470 FE85      		ldd r31,Y+14
 934 0472 3186      		std Z+9,r3
 935 0474 2086      		std Z+8,r2
2160:ff.c          **** 	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector 
 937               	.LM95:
 938 0476 C101      		movw r24,r2
 939 0478 8F70      		andi r24,15
 940 047a 9927      		clr r25
 941 047c 892B      		or r24,r25
 942 047e 01F0      		breq .+2
 943 0480 00C0      		rjmp .L48
2162:ff.c          **** 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
 945               	.LM96:
 946 0482 EA5B      		subi r30,-70
 947 0484 FF4F      		sbci r31,-1
 948 0486 9081      		ld r25,Z
 949 0488 80E0      		ldi r24,0
 950 048a ED85      		ldd r30,Y+13
 951 048c FE85      		ldd r31,Y+14
 952 048e EB5B      		subi r30,-69
 953 0490 FF4F      		sbci r31,-1
 954 0492 2081      		ld r18,Z
 955 0494 4C01      		movw r8,r24
 956 0496 822A      		or r8,r18
 957 0498 A12C      		mov r10,__zero_reg__
 958 049a B12C      		mov r11,__zero_reg__
2163:ff.c          **** 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 960               	.LM97:
 961 049c 8114      		cp r8,__zero_reg__
 962 049e 9104      		cpc r9,__zero_reg__
 963 04a0 A104      		cpc r10,__zero_reg__
 964 04a2 B104      		cpc r11,__zero_reg__
 965 04a4 01F4      		brne .L50
2163:ff.c          **** 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 967               	.LM98:
 968 04a6 ED85      		ldd r30,Y+13
 969 04a8 FE85      		ldd r31,Y+14
 970 04aa EB5A      		subi r30,-85
 971 04ac FF4F      		sbci r31,-1
 972 04ae 8081      		ld r24,Z
 973 04b0 ED85      		ldd r30,Y+13
 974 04b2 FE85      		ldd r31,Y+14
 975 04b4 EC5A      		subi r30,-84
 976 04b6 FF4F      		sbci r31,-1
 977 04b8 8080      		ld r8,Z
 978 04ba 912C      		mov r9,__zero_reg__
 979 04bc A12C      		mov r10,__zero_reg__
 980 04be B12C      		mov r11,__zero_reg__
 981 04c0 5401      		movw r10,r8
 982 04c2 9924      		clr r9
 983 04c4 8824      		clr r8
 984 04c6 B82A      		or r11,r24
 985 04c8 ED85      		ldd r30,Y+13
 986 04ca FE85      		ldd r31,Y+14
 987 04cc EE5A      		subi r30,-82
 988 04ce FF4F      		sbci r31,-1
 989 04d0 8081      		ld r24,Z
 990 04d2 882A      		or r8,r24
 991 04d4 ED85      		ldd r30,Y+13
 992 04d6 FE85      		ldd r31,Y+14
 993 04d8 ED5A      		subi r30,-83
 994 04da FF4F      		sbci r31,-1
 995 04dc 9081      		ld r25,Z
 996 04de 80E0      		ldi r24,0
 997 04e0 AC01      		movw r20,r24
 998 04e2 60E0      		ldi r22,0
 999 04e4 70E0      		ldi r23,0
 1000 04e6 842A      		or r8,r20
 1001 04e8 952A      		or r9,r21
 1002 04ea A62A      		or r10,r22
 1003 04ec B72A      		or r11,r23
 1004               	.L50:
2165:ff.c          **** 	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 1006               	.LM99:
 1007 04ee ED85      		ldd r30,Y+13
 1008 04f0 FE85      		ldd r31,Y+14
 1009 04f2 EF5B      		subi r30,-65
 1010 04f4 FF4F      		sbci r31,-1
 1011 04f6 3081      		ld r19,Z
 1012 04f8 20E0      		ldi r18,0
 1013 04fa ED85      		ldd r30,Y+13
 1014 04fc FE85      		ldd r31,Y+14
 1015 04fe E05C      		subi r30,-64
 1016 0500 FF4F      		sbci r31,-1
 1017 0502 8081      		ld r24,Z
 1018 0504 F901      		movw r30,r18
 1019 0506 E82B      		or r30,r24
2166:ff.c          **** 	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
 1021               	.LM100:
 1022 0508 3097      		sbiw r30,0
 1023 050a 01F4      		brne .+2
 1024 050c 00C0      		rjmp .L48
2154:ff.c          **** 	fasize *= b;										/* Number of sectors for FAT area */
 1026               	.LM101:
 1027 050e B0E0      		ldi r27,0
 1028 0510 A701      		movw r20,r14
 1029 0512 9601      		movw r18,r12
 1030 0514 0E94 0000 		call __muluhisi3
 1031 0518 6D83      		std Y+5,r22
 1032 051a 7E83      		std Y+6,r23
 1033 051c 8F83      		std Y+7,r24
 1034 051e 9887      		std Y+8,r25
2169:ff.c          **** 	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
 1036               	.LM102:
 1037 0520 AF01      		movw r20,r30
 1038 0522 9A01      		movw r18,r20
 1039 0524 40E0      		ldi r20,0
 1040 0526 50E0      		ldi r21,0
 1041 0528 2987      		std Y+9,r18
 1042 052a 3A87      		std Y+10,r19
 1043 052c 4B87      		std Y+11,r20
 1044 052e 5C87      		std Y+12,r21
 1045 0530 C101      		movw r24,r2
 1046 0532 64E0      		ldi r22,4
 1047               		1:
 1048 0534 9695      		lsr r25
 1049 0536 8795      		ror r24
 1050 0538 6A95      		dec r22
 1051 053a 01F4      		brne 1b
 1052 053c 280F      		add r18,r24
 1053 053e 391F      		adc r19,r25
 1054 0540 411D      		adc r20,__zero_reg__
 1055 0542 511D      		adc r21,__zero_reg__
 1056 0544 8D81      		ldd r24,Y+5
 1057 0546 9E81      		ldd r25,Y+6
 1058 0548 AF81      		ldd r26,Y+7
 1059 054a B885      		ldd r27,Y+8
 1060 054c 280F      		add r18,r24
 1061 054e 391F      		adc r19,r25
 1062 0550 4A1F      		adc r20,r26
 1063 0552 5B1F      		adc r21,r27
 1064 0554 2983      		std Y+1,r18
 1065 0556 3A83      		std Y+2,r19
 1066 0558 4B83      		std Y+3,r20
 1067 055a 5C83      		std Y+4,r21
2170:ff.c          **** 	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 1069               	.LM103:
 1070 055c 8216      		cp r8,r18
 1071 055e 9306      		cpc r9,r19
 1072 0560 A406      		cpc r10,r20
 1073 0562 B506      		cpc r11,r21
 1074 0564 00F4      		brsh .+2
 1075 0566 00C0      		rjmp .L48
2171:ff.c          **** 	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 1077               	.LM104:
 1078 0568 C501      		movw r24,r10
 1079 056a B401      		movw r22,r8
 1080 056c 621B      		sub r22,r18
 1081 056e 730B      		sbc r23,r19
 1082 0570 840B      		sbc r24,r20
 1083 0572 950B      		sbc r25,r21
 1084 0574 212F      		mov r18,r17
 1085 0576 30E0      		ldi r19,0
 1086 0578 40E0      		ldi r20,0
 1087 057a 50E0      		ldi r21,0
 1088 057c 0E94 0000 		call __udivmodsi4
2172:ff.c          **** 	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 1090               	.LM105:
 1091 0580 2115      		cp r18,__zero_reg__
 1092 0582 3105      		cpc r19,__zero_reg__
 1093 0584 4105      		cpc r20,__zero_reg__
 1094 0586 5105      		cpc r21,__zero_reg__
 1095 0588 01F4      		brne .+2
 1096 058a 00C0      		rjmp .L48
2174:ff.c          **** 	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 1098               	.LM106:
 1099 058c 263F      		cpi r18,-10
 1100 058e 9FE0      		ldi r25,15
 1101 0590 3907      		cpc r19,r25
 1102 0592 4105      		cpc r20,__zero_reg__
 1103 0594 5105      		cpc r21,__zero_reg__
 1104 0596 00F0      		brlo .L69
2175:ff.c          **** 	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 1106               	.LM107:
 1107 0598 263F      		cpi r18,-10
 1108 059a AFEF      		ldi r26,-1
 1109 059c 3A07      		cpc r19,r26
 1110 059e 4105      		cpc r20,__zero_reg__
 1111 05a0 5105      		cpc r21,__zero_reg__
 1112 05a2 00F4      		brsh .L70
2174:ff.c          **** 	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 1114               	.LM108:
 1115 05a4 12E0      		ldi r17,lo8(2)
 1116 05a6 00C0      		rjmp .L52
 1117               	.L69:
2173:ff.c          **** 	fmt = FS_FAT12;
 1119               	.LM109:
 1120 05a8 11E0      		ldi r17,lo8(1)
 1121 05aa 00C0      		rjmp .L52
 1122               	.L70:
2175:ff.c          **** 	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 1124               	.LM110:
 1125 05ac 13E0      		ldi r17,lo8(3)
 1126               	.L52:
2178:ff.c          **** 	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 1128               	.LM111:
 1129 05ae 02E0      		ldi r16,lo8(2)
 1130 05b0 802E      		mov r8,r16
 1131 05b2 912C      		mov r9,__zero_reg__
 1132 05b4 A12C      		mov r10,__zero_reg__
 1133 05b6 B12C      		mov r11,__zero_reg__
 1134 05b8 820E      		add r8,r18
 1135 05ba 931E      		adc r9,r19
 1136 05bc A41E      		adc r10,r20
 1137 05be B51E      		adc r11,r21
 1138 05c0 ED85      		ldd r30,Y+13
 1139 05c2 FE85      		ldd r31,Y+14
 1140 05c4 868A      		std Z+22,r8
 1141 05c6 978A      		std Z+23,r9
 1142 05c8 A08E      		std Z+24,r10
 1143 05ca B18E      		std Z+25,r11
2179:ff.c          **** 	fs->volbase = bsect;								/* Volume start sector */
 1145               	.LM112:
 1146 05cc 468E      		std Z+30,r4
 1147 05ce 578E      		std Z+31,r5
 1148 05d0 60A2      		std Z+32,r6
 1149 05d2 71A2      		std Z+33,r7
2180:ff.c          **** 	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 1151               	.LM113:
 1152 05d4 8985      		ldd r24,Y+9
 1153 05d6 9A85      		ldd r25,Y+10
 1154 05d8 AB85      		ldd r26,Y+11
 1155 05da BC85      		ldd r27,Y+12
 1156 05dc 840D      		add r24,r4
 1157 05de 951D      		adc r25,r5
 1158 05e0 A61D      		adc r26,r6
 1159 05e2 B71D      		adc r27,r7
 1160 05e4 82A3      		std Z+34,r24
 1161 05e6 93A3      		std Z+35,r25
 1162 05e8 A4A3      		std Z+36,r26
 1163 05ea B5A3      		std Z+37,r27
2181:ff.c          **** 	fs->database = bsect + sysect;						/* Data start sector */
 1165               	.LM114:
 1166 05ec 4981      		ldd r20,Y+1
 1167 05ee 5A81      		ldd r21,Y+2
 1168 05f0 6B81      		ldd r22,Y+3
 1169 05f2 7C81      		ldd r23,Y+4
 1170 05f4 440D      		add r20,r4
 1171 05f6 551D      		adc r21,r5
 1172 05f8 661D      		adc r22,r6
 1173 05fa 771D      		adc r23,r7
 1174 05fc 42A7      		std Z+42,r20
 1175 05fe 53A7      		std Z+43,r21
 1176 0600 64A7      		std Z+44,r22
 1177 0602 75A7      		std Z+45,r23
2182:ff.c          **** 	if (fmt == FS_FAT32) {
 1179               	.LM115:
 1180 0604 1330      		cpi r17,lo8(3)
 1181 0606 01F4      		brne .L53
2183:ff.c          **** 		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 1183               	.LM116:
 1184 0608 2328      		or r2,r3
 1185 060a 01F0      		breq .+2
 1186 060c 00C0      		rjmp .L48
2184:ff.c          **** 		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 1188               	.LM117:
 1189 060e EF59      		subi r30,-97
 1190 0610 FF4F      		sbci r31,-1
 1191 0612 8081      		ld r24,Z
 1192 0614 ED85      		ldd r30,Y+13
 1193 0616 FE85      		ldd r31,Y+14
 1194 0618 E05A      		subi r30,-96
 1195 061a FF4F      		sbci r31,-1
 1196 061c 4081      		ld r20,Z
 1197 061e 50E0      		ldi r21,0
 1198 0620 60E0      		ldi r22,0
 1199 0622 70E0      		ldi r23,0
 1200 0624 BA01      		movw r22,r20
 1201 0626 5527      		clr r21
 1202 0628 4427      		clr r20
 1203 062a 782B      		or r23,r24
 1204 062c ED85      		ldd r30,Y+13
 1205 062e FE85      		ldd r31,Y+14
 1206 0630 E25A      		subi r30,-94
 1207 0632 FF4F      		sbci r31,-1
 1208 0634 8081      		ld r24,Z
 1209 0636 482B      		or r20,r24
 1210 0638 ED85      		ldd r30,Y+13
 1211 063a FE85      		ldd r31,Y+14
 1212 063c E15A      		subi r30,-95
 1213 063e FF4F      		sbci r31,-1
 1214 0640 9081      		ld r25,Z
 1215 0642 80E0      		ldi r24,0
 1216 0644 A0E0      		ldi r26,0
 1217 0646 B0E0      		ldi r27,0
 1218 0648 482B      		or r20,r24
 1219 064a 592B      		or r21,r25
 1220 064c 6A2B      		or r22,r26
 1221 064e 7B2B      		or r23,r27
 1222 0650 AD85      		ldd r26,Y+13
 1223 0652 BE85      		ldd r27,Y+14
 1224 0654 9696      		adiw r26,38
 1225 0656 4D93      		st X+,r20
 1226 0658 5D93      		st X+,r21
 1227 065a 6D93      		st X+,r22
 1228 065c 7C93      		st X,r23
 1229 065e 9997      		sbiw r26,38+3
2185:ff.c          **** 		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
 1231               	.LM118:
 1232 0660 C501      		movw r24,r10
 1233 0662 B401      		movw r22,r8
 1234 0664 B2E0      		ldi r27,2
 1235               		1:
 1236 0666 660F      		lsl r22
 1237 0668 771F      		rol r23
 1238 066a 881F      		rol r24
 1239 066c 991F      		rol r25
 1240 066e BA95      		dec r27
 1241 0670 01F4      		brne 1b
 1242 0672 00C0      		rjmp .L54
 1243               	.L53:
2187:ff.c          **** 		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 1245               	.LM119:
 1246 0674 2328      		or r2,r3
 1247 0676 01F4      		brne .+2
 1248 0678 00C0      		rjmp .L48
2188:ff.c          **** 		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 1250               	.LM120:
 1251 067a 2D81      		ldd r18,Y+5
 1252 067c 3E81      		ldd r19,Y+6
 1253 067e 4F81      		ldd r20,Y+7
 1254 0680 5885      		ldd r21,Y+8
 1255 0682 820F      		add r24,r18
 1256 0684 931F      		adc r25,r19
 1257 0686 A41F      		adc r26,r20
 1258 0688 B51F      		adc r27,r21
 1259 068a ED85      		ldd r30,Y+13
 1260 068c FE85      		ldd r31,Y+14
 1261 068e 86A3      		std Z+38,r24
 1262 0690 97A3      		std Z+39,r25
 1263 0692 A0A7      		std Z+40,r26
 1264 0694 B1A7      		std Z+41,r27
2190:ff.c          **** 			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 1266               	.LM121:
 1267 0696 1230      		cpi r17,lo8(2)
 1268 0698 01F4      		brne .L55
2190:ff.c          **** 			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 1270               	.LM122:
 1271 069a C501      		movw r24,r10
 1272 069c B401      		movw r22,r8
 1273 069e 660F      		lsl r22
 1274 06a0 771F      		rol r23
 1275 06a2 881F      		rol r24
 1276 06a4 991F      		rol r25
 1277 06a6 00C0      		rjmp .L54
 1278               	.L55:
2190:ff.c          **** 			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 1280               	.LM123:
 1281 06a8 A3E0      		ldi r26,lo8(3)
 1282 06aa B0E0      		ldi r27,0
 1283 06ac A501      		movw r20,r10
 1284 06ae 9401      		movw r18,r8
 1285 06b0 0E94 0000 		call __muluhisi3
 1286 06b4 9695      		lsr r25
 1287 06b6 8795      		ror r24
 1288 06b8 7795      		ror r23
 1289 06ba 6795      		ror r22
 1290 06bc F1E0      		ldi r31,1
 1291 06be 8F22      		and r8,r31
 1292 06c0 9924      		clr r9
 1293 06c2 AA24      		clr r10
 1294 06c4 BB24      		clr r11
 1295 06c6 680D      		add r22,r8
 1296 06c8 791D      		adc r23,r9
 1297 06ca 8A1D      		adc r24,r10
 1298 06cc 9B1D      		adc r25,r11
 1299               	.L54:
2192:ff.c          **** 	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 1301               	.LM124:
 1302 06ce DC01      		movw r26,r24
 1303 06d0 CB01      		movw r24,r22
 1304 06d2 8150      		subi r24,1
 1305 06d4 9E4F      		sbci r25,-2
 1306 06d6 AF4F      		sbci r26,-1
 1307 06d8 BF4F      		sbci r27,-1
 1308 06da 69E0      		ldi r22,9
 1309               		1:
 1310 06dc B695      		lsr r27
 1311 06de A795      		ror r26
 1312 06e0 9795      		ror r25
 1313 06e2 8795      		ror r24
 1314 06e4 6A95      		dec r22
 1315 06e6 01F4      		brne 1b
 1316 06e8 C816      		cp r12,r24
 1317 06ea D906      		cpc r13,r25
 1318 06ec EA06      		cpc r14,r26
 1319 06ee FB06      		cpc r15,r27
 1320 06f0 00F4      		brsh .+2
 1321 06f2 00C0      		rjmp .L48
2197:ff.c          **** 	fs->free_clust = 0xFFFFFFFF;
 1323               	.LM125:
 1324 06f4 8FEF      		ldi r24,lo8(-1)
 1325 06f6 9FEF      		ldi r25,lo8(-1)
 1326 06f8 DC01      		movw r26,r24
 1327 06fa ED85      		ldd r30,Y+13
 1328 06fc FE85      		ldd r31,Y+14
 1329 06fe 8687      		std Z+14,r24
 1330 0700 9787      		std Z+15,r25
 1331 0702 A08B      		std Z+16,r26
 1332 0704 B18B      		std Z+17,r27
2198:ff.c          **** 	fs->last_clust = 0;
 1334               	.LM126:
 1335 0706 DF01      		movw r26,r30
 1336 0708 1286      		std Z+10,__zero_reg__
 1337 070a 1386      		std Z+11,__zero_reg__
 1338 070c 1486      		std Z+12,__zero_reg__
 1339 070e 1586      		std Z+13,__zero_reg__
2201:ff.c          **** 	if (fmt == FS_FAT32) {
 1341               	.LM127:
 1342 0710 1330      		cpi r17,lo8(3)
 1343 0712 01F0      		breq .+2
 1344 0714 00C0      		rjmp .L57
2202:ff.c          **** 	 	fs->fsi_flag = 0;
 1346               	.LM128:
 1347 0716 1582      		std Z+5,__zero_reg__
2203:ff.c          **** 		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 1349               	.LM129:
 1350 0718 ED59      		subi r30,-99
 1351 071a FF4F      		sbci r31,-1
 1352 071c 9081      		ld r25,Z
 1353 071e 80E0      		ldi r24,0
 1354 0720 FD01      		movw r30,r26
 1355 0722 EE59      		subi r30,-98
 1356 0724 FF4F      		sbci r31,-1
 1357 0726 2081      		ld r18,Z
 1358 0728 822B      		or r24,r18
 1359 072a A301      		movw r20,r6
 1360 072c 9201      		movw r18,r4
 1361 072e 280F      		add r18,r24
 1362 0730 391F      		adc r19,r25
 1363 0732 411D      		adc r20,__zero_reg__
 1364 0734 511D      		adc r21,__zero_reg__
 1365 0736 5296      		adiw r26,18
 1366 0738 2D93      		st X+,r18
 1367 073a 3D93      		st X+,r19
 1368 073c 4D93      		st X+,r20
 1369 073e 5C93      		st X,r21
 1370 0740 5597      		sbiw r26,18+3
2204:ff.c          **** 		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 1372               	.LM130:
 1373 0742 BD01      		movw r22,r26
 1374 0744 6E5C      		subi r22,-50
 1375 0746 7F4F      		sbci r23,-1
 1376 0748 01E0      		ldi r16,lo8(1)
 1377 074a 1196      		adiw r26,1
 1378 074c 8C91      		ld r24,X
 1379 074e 0E94 0000 		call disk_read
 1380 0752 8111      		cpse r24,__zero_reg__
 1381 0754 00C0      		rjmp .L57
2205:ff.c          **** 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 1383               	.LM131:
 1384 0756 ED85      		ldd r30,Y+13
 1385 0758 FE85      		ldd r31,Y+14
 1386 075a EF5C      		subi r30,-49
 1387 075c FD4F      		sbci r31,-3
 1388 075e 9081      		ld r25,Z
 1389 0760 80E0      		ldi r24,0
 1390 0762 ED85      		ldd r30,Y+13
 1391 0764 FE85      		ldd r31,Y+14
 1392 0766 E05D      		subi r30,-48
 1393 0768 FD4F      		sbci r31,-3
 1394 076a 2081      		ld r18,Z
 1395 076c 822B      		or r24,r18
2204:ff.c          **** 		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 1397               	.LM132:
 1398 076e 8535      		cpi r24,85
 1399 0770 9A4A      		sbci r25,-86
 1400 0772 01F0      		breq .+2
 1401 0774 00C0      		rjmp .L57
2206:ff.c          **** 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 1403               	.LM133:
 1404 0776 ED85      		ldd r30,Y+13
 1405 0778 FE85      		ldd r31,Y+14
 1406 077a 25A9      		ldd r18,Z+53
 1407 077c 84A9      		ldd r24,Z+52
 1408 077e 90E0      		ldi r25,0
 1409 0780 A0E0      		ldi r26,0
 1410 0782 B0E0      		ldi r27,0
 1411 0784 DC01      		movw r26,r24
 1412 0786 9927      		clr r25
 1413 0788 8827      		clr r24
 1414 078a B22B      		or r27,r18
 1415 078c 22A9      		ldd r18,Z+50
 1416 078e 822B      		or r24,r18
 1417 0790 53A9      		ldd r21,Z+51
 1418 0792 40E0      		ldi r20,0
 1419 0794 60E0      		ldi r22,0
 1420 0796 70E0      		ldi r23,0
 1421 0798 842B      		or r24,r20
 1422 079a 952B      		or r25,r21
 1423 079c A62B      		or r26,r22
 1424 079e B72B      		or r27,r23
2205:ff.c          **** 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 1426               	.LM134:
 1427 07a0 8235      		cpi r24,82
 1428 07a2 9245      		sbci r25,82
 1429 07a4 A146      		sbci r26,97
 1430 07a6 B144      		sbci r27,65
 1431 07a8 01F0      		breq .+2
 1432 07aa 00C0      		rjmp .L57
2207:ff.c          **** 			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
 1434               	.LM135:
 1435 07ac ED85      		ldd r30,Y+13
 1436 07ae FE85      		ldd r31,Y+14
 1437 07b0 E75E      		subi r30,-25
 1438 07b2 FD4F      		sbci r31,-3
 1439 07b4 2081      		ld r18,Z
 1440 07b6 ED85      		ldd r30,Y+13
 1441 07b8 FE85      		ldd r31,Y+14
 1442 07ba E85E      		subi r30,-24
 1443 07bc FD4F      		sbci r31,-3
 1444 07be 8081      		ld r24,Z
 1445 07c0 90E0      		ldi r25,0
 1446 07c2 A0E0      		ldi r26,0
 1447 07c4 B0E0      		ldi r27,0
 1448 07c6 DC01      		movw r26,r24
 1449 07c8 9927      		clr r25
 1450 07ca 8827      		clr r24
 1451 07cc B22B      		or r27,r18
 1452 07ce ED85      		ldd r30,Y+13
 1453 07d0 FE85      		ldd r31,Y+14
 1454 07d2 EA5E      		subi r30,-22
 1455 07d4 FD4F      		sbci r31,-3
 1456 07d6 2081      		ld r18,Z
 1457 07d8 822B      		or r24,r18
 1458 07da ED85      		ldd r30,Y+13
 1459 07dc FE85      		ldd r31,Y+14
 1460 07de E95E      		subi r30,-23
 1461 07e0 FD4F      		sbci r31,-3
 1462 07e2 5081      		ld r21,Z
 1463 07e4 40E0      		ldi r20,0
 1464 07e6 60E0      		ldi r22,0
 1465 07e8 70E0      		ldi r23,0
 1466 07ea 842B      		or r24,r20
 1467 07ec 952B      		or r25,r21
 1468 07ee A62B      		or r26,r22
 1469 07f0 B72B      		or r27,r23
2206:ff.c          **** 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 1471               	.LM136:
 1472 07f2 8237      		cpi r24,114
 1473 07f4 9247      		sbci r25,114
 1474 07f6 A144      		sbci r26,65
 1475 07f8 B146      		sbci r27,97
 1476 07fa 01F0      		breq .+2
 1477 07fc 00C0      		rjmp .L57
2208:ff.c          **** 				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 1479               	.LM137:
 1480 07fe ED85      		ldd r30,Y+13
 1481 0800 FE85      		ldd r31,Y+14
 1482 0802 EF5D      		subi r30,-33
 1483 0804 FD4F      		sbci r31,-3
 1484 0806 2081      		ld r18,Z
 1485 0808 ED85      		ldd r30,Y+13
 1486 080a FE85      		ldd r31,Y+14
 1487 080c E05E      		subi r30,-32
 1488 080e FD4F      		sbci r31,-3
 1489 0810 8081      		ld r24,Z
 1490 0812 90E0      		ldi r25,0
 1491 0814 A0E0      		ldi r26,0
 1492 0816 B0E0      		ldi r27,0
 1493 0818 DC01      		movw r26,r24
 1494 081a 9927      		clr r25
 1495 081c 8827      		clr r24
 1496 081e B22B      		or r27,r18
 1497 0820 ED85      		ldd r30,Y+13
 1498 0822 FE85      		ldd r31,Y+14
 1499 0824 E25E      		subi r30,-30
 1500 0826 FD4F      		sbci r31,-3
 1501 0828 2081      		ld r18,Z
 1502 082a 822B      		or r24,r18
 1503 082c ED85      		ldd r30,Y+13
 1504 082e FE85      		ldd r31,Y+14
 1505 0830 E15E      		subi r30,-31
 1506 0832 FD4F      		sbci r31,-3
 1507 0834 5081      		ld r21,Z
 1508 0836 40E0      		ldi r20,0
 1509 0838 60E0      		ldi r22,0
 1510 083a 70E0      		ldi r23,0
 1511 083c 842B      		or r24,r20
 1512 083e 952B      		or r25,r21
 1513 0840 A62B      		or r26,r22
 1514 0842 B72B      		or r27,r23
 1515 0844 ED85      		ldd r30,Y+13
 1516 0846 FE85      		ldd r31,Y+14
 1517 0848 8287      		std Z+10,r24
 1518 084a 9387      		std Z+11,r25
 1519 084c A487      		std Z+12,r26
 1520 084e B587      		std Z+13,r27
2209:ff.c          **** 				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 1522               	.LM138:
 1523 0850 E35E      		subi r30,-29
 1524 0852 FD4F      		sbci r31,-3
 1525 0854 2081      		ld r18,Z
 1526 0856 ED85      		ldd r30,Y+13
 1527 0858 FE85      		ldd r31,Y+14
 1528 085a E45E      		subi r30,-28
 1529 085c FD4F      		sbci r31,-3
 1530 085e 8081      		ld r24,Z
 1531 0860 90E0      		ldi r25,0
 1532 0862 A0E0      		ldi r26,0
 1533 0864 B0E0      		ldi r27,0
 1534 0866 DC01      		movw r26,r24
 1535 0868 9927      		clr r25
 1536 086a 8827      		clr r24
 1537 086c B22B      		or r27,r18
 1538 086e ED85      		ldd r30,Y+13
 1539 0870 FE85      		ldd r31,Y+14
 1540 0872 E65E      		subi r30,-26
 1541 0874 FD4F      		sbci r31,-3
 1542 0876 2081      		ld r18,Z
 1543 0878 822B      		or r24,r18
 1544 087a ED85      		ldd r30,Y+13
 1545 087c FE85      		ldd r31,Y+14
 1546 087e E55E      		subi r30,-27
 1547 0880 FD4F      		sbci r31,-3
 1548 0882 5081      		ld r21,Z
 1549 0884 40E0      		ldi r20,0
 1550 0886 60E0      		ldi r22,0
 1551 0888 70E0      		ldi r23,0
 1552 088a 842B      		or r24,r20
 1553 088c 952B      		or r25,r21
 1554 088e A62B      		or r26,r22
 1555 0890 B72B      		or r27,r23
 1556 0892 ED85      		ldd r30,Y+13
 1557 0894 FE85      		ldd r31,Y+14
 1558 0896 8687      		std Z+14,r24
 1559 0898 9787      		std Z+15,r25
 1560 089a A08B      		std Z+16,r26
 1561 089c B18B      		std Z+17,r27
 1562               	.L57:
2213:ff.c          **** 	fs->fs_type = fmt;		/* FAT sub-type */
 1564               	.LM139:
 1565 089e AD85      		ldd r26,Y+13
 1566 08a0 BE85      		ldd r27,Y+14
 1567 08a2 1C93      		st X,r17
2214:ff.c          **** 	fs->id = ++Fsid;		/* File system mount ID */
 1569               	.LM140:
 1570 08a4 8091 0000 		lds r24,Fsid
 1571 08a8 9091 0000 		lds r25,Fsid+1
 1572 08ac 0196      		adiw r24,1
 1573 08ae 9093 0000 		sts Fsid+1,r25
 1574 08b2 8093 0000 		sts Fsid,r24
 1575 08b6 1796      		adiw r26,6+1
 1576 08b8 9C93      		st X,r25
 1577 08ba 8E93      		st -X,r24
 1578 08bc 1697      		sbiw r26,6
2215:ff.c          **** 	fs->winsect = 0;		/* Invalidate sector cache */
 1580               	.LM141:
 1581 08be FD01      		movw r30,r26
 1582 08c0 16A6      		std Z+46,__zero_reg__
 1583 08c2 17A6      		std Z+47,__zero_reg__
 1584 08c4 10AA      		std Z+48,__zero_reg__
 1585 08c6 11AA      		std Z+49,__zero_reg__
2216:ff.c          **** 	fs->wflag = 0;
 1587               	.LM142:
 1588 08c8 1482      		std Z+4,__zero_reg__
 1589 08ca 00C0      		rjmp .L64
 1590               	.L61:
2097:ff.c          **** 		return FR_INVALID_DRIVE;
 1592               	.LM143:
 1593 08cc 8BE0      		ldi r24,lo8(11)
 1594 08ce 00C0      		rjmp .L43
 1595               	.L62:
2099:ff.c          **** 	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 1597               	.LM144:
 1598 08d0 8CE0      		ldi r24,lo8(12)
 1599 08d2 00C0      		rjmp .L43
 1600               	.L64:
2109:ff.c          **** 			return FR_OK;				/* The file system object is valid */
 1602               	.LM145:
 1603 08d4 80E0      		ldi r24,0
 1604 08d6 00C0      		rjmp .L43
 1605               	.L65:
2120:ff.c          **** 		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 1607               	.LM146:
 1608 08d8 83E0      		ldi r24,lo8(3)
 1609 08da 00C0      		rjmp .L43
 1610               	.L66:
2122:ff.c          **** 		return FR_WRITE_PROTECTED;
 1612               	.LM147:
 1613 08dc 8AE0      		ldi r24,lo8(10)
 1614 08de 00C0      		rjmp .L43
 1615               	.L68:
2140:ff.c          **** 	if (fmt == 3) return FR_DISK_ERR;
 1617               	.LM148:
 1618 08e0 81E0      		ldi r24,lo8(1)
 1619               	.L43:
 1620               	/* epilogue start */
2225:ff.c          **** }
 1622               	.LM149:
 1623 08e2 2E96      		adiw r28,14
 1624 08e4 0FB6      		in __tmp_reg__,__SREG__
 1625 08e6 F894      		cli
 1626 08e8 DEBF      		out __SP_H__,r29
 1627 08ea 0FBE      		out __SREG__,__tmp_reg__
 1628 08ec CDBF      		out __SP_L__,r28
 1629 08ee DF91      		pop r29
 1630 08f0 CF91      		pop r28
 1631 08f2 1F91      		pop r17
 1632 08f4 0F91      		pop r16
 1633 08f6 FF90      		pop r15
 1634 08f8 EF90      		pop r14
 1635 08fa DF90      		pop r13
 1636 08fc CF90      		pop r12
 1637 08fe BF90      		pop r11
 1638 0900 AF90      		pop r10
 1639 0902 9F90      		pop r9
 1640 0904 8F90      		pop r8
 1641 0906 7F90      		pop r7
 1642 0908 6F90      		pop r6
 1643 090a 5F90      		pop r5
 1644 090c 4F90      		pop r4
 1645 090e 3F90      		pop r3
 1646 0910 2F90      		pop r2
 1647 0912 0895      		ret
 1658               	.Lscope6:
 1660               		.stabd	78,0,0
 1664               	sync_window:
 1665               		.stabd	46,0,0
 735:ff.c          **** {
 1667               	.LM150:
 1668               	.LFBB7:
 1669 0914 4F92      		push r4
 1670 0916 5F92      		push r5
 1671 0918 6F92      		push r6
 1672 091a 7F92      		push r7
 1673 091c AF92      		push r10
 1674 091e BF92      		push r11
 1675 0920 CF92      		push r12
 1676 0922 DF92      		push r13
 1677 0924 EF92      		push r14
 1678 0926 FF92      		push r15
 1679 0928 0F93      		push r16
 1680 092a CF93      		push r28
 1681 092c DF93      		push r29
 1682               	/* prologue: function */
 1683               	/* frame size = 0 */
 1684               	/* stack size = 13 */
 1685               	.L__stack_usage = 13
 1686 092e EC01      		movw r28,r24
 740:ff.c          **** 	if (fs->wflag) {	/* Write back the sector if it is dirty */
 1688               	.LM151:
 1689 0930 8C81      		ldd r24,Y+4
 1690 0932 8823      		tst r24
 1691 0934 01F4      		brne .+2
 1692 0936 00C0      		rjmp .L96
 1693               	.LBB8:
 1694               	.LBB9:
 741:ff.c          **** 		wsect = fs->winsect;	/* Current sector number */
 1696               	.LM152:
 1697 0938 4EA4      		ldd r4,Y+46
 1698 093a 5FA4      		ldd r5,Y+47
 1699 093c 68A8      		ldd r6,Y+48
 1700 093e 79A8      		ldd r7,Y+49
 742:ff.c          **** 		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 1702               	.LM153:
 1703 0940 6E01      		movw r12,r28
 1704 0942 82E3      		ldi r24,50
 1705 0944 C80E      		add r12,r24
 1706 0946 D11C      		adc r13,__zero_reg__
 1707 0948 01E0      		ldi r16,lo8(1)
 1708 094a A301      		movw r20,r6
 1709 094c 9201      		movw r18,r4
 1710 094e B601      		movw r22,r12
 1711 0950 8981      		ldd r24,Y+1
 1712 0952 0E94 0000 		call disk_write
 1713 0956 8111      		cpse r24,__zero_reg__
 1714 0958 00C0      		rjmp .L97
 744:ff.c          **** 		fs->wflag = 0;
 1716               	.LM154:
 1717 095a 1C82      		std Y+4,__zero_reg__
 745:ff.c          **** 		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 1719               	.LM155:
 1720 095c 4AA1      		ldd r20,Y+34
 1721 095e 5BA1      		ldd r21,Y+35
 1722 0960 6CA1      		ldd r22,Y+36
 1723 0962 7DA1      		ldd r23,Y+37
 1724 0964 4416      		cp r4,r20
 1725 0966 5506      		cpc r5,r21
 1726 0968 6606      		cpc r6,r22
 1727 096a 7706      		cpc r7,r23
 1728 096c 00F4      		brsh .L92
 1729 096e 00C0      		rjmp .L96
 1730               	.L92:
 1731 0970 8A8D      		ldd r24,Y+26
 1732 0972 9B8D      		ldd r25,Y+27
 1733 0974 AC8D      		ldd r26,Y+28
 1734 0976 BD8D      		ldd r27,Y+29
 1735 0978 840F      		add r24,r20
 1736 097a 951F      		adc r25,r21
 1737 097c A61F      		adc r26,r22
 1738 097e B71F      		adc r27,r23
 1739 0980 4816      		cp r4,r24
 1740 0982 5906      		cpc r5,r25
 1741 0984 6A06      		cpc r6,r26
 1742 0986 7B06      		cpc r7,r27
 1743 0988 00F4      		brsh .L96
 746:ff.c          **** 			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 1745               	.LM156:
 1746 098a AB80      		ldd r10,Y+3
 1747 098c B12C      		mov r11,__zero_reg__
 1748 098e E12C      		mov r14,__zero_reg__
 1749 0990 F12C      		mov r15,__zero_reg__
 1750 0992 00C0      		rjmp .L94
 1751               	.L95:
 747:ff.c          **** 				wsect += fs->fsize;
 1753               	.LM157:
 1754 0994 8A8D      		ldd r24,Y+26
 1755 0996 9B8D      		ldd r25,Y+27
 1756 0998 AC8D      		ldd r26,Y+28
 1757 099a BD8D      		ldd r27,Y+29
 1758 099c 480E      		add r4,r24
 1759 099e 591E      		adc r5,r25
 1760 09a0 6A1E      		adc r6,r26
 1761 09a2 7B1E      		adc r7,r27
 748:ff.c          **** 				disk_write(fs->drv, fs->win, wsect, 1);
 1763               	.LM158:
 1764 09a4 01E0      		ldi r16,lo8(1)
 1765 09a6 A301      		movw r20,r6
 1766 09a8 9201      		movw r18,r4
 1767 09aa B601      		movw r22,r12
 1768 09ac 8981      		ldd r24,Y+1
 1769 09ae 0E94 0000 		call disk_write
 1770 09b2 8FEF      		ldi r24,-1
 1771 09b4 E81A      		sub r14,r24
 1772 09b6 F80A      		sbc r15,r24
 1773               	.L94:
 746:ff.c          **** 			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 1775               	.LM159:
 1776 09b8 C501      		movw r24,r10
 1777 09ba 8E19      		sub r24,r14
 1778 09bc 9F09      		sbc r25,r15
 1779 09be 0297      		sbiw r24,2
 1780 09c0 00F4      		brsh .L95
 1781 09c2 00C0      		rjmp .L96
 1782               	.L97:
 743:ff.c          **** 			return FR_DISK_ERR;
 1784               	.LM160:
 1785 09c4 81E0      		ldi r24,lo8(1)
 1786 09c6 00C0      		rjmp .L90
 1787               	.L96:
 1788               	.LBE9:
 1789               	.LBE8:
 752:ff.c          **** 	return FR_OK;
 1791               	.LM161:
 1792 09c8 80E0      		ldi r24,0
 1793               	.L90:
 1794               	/* epilogue start */
 753:ff.c          **** }
 1796               	.LM162:
 1797 09ca DF91      		pop r29
 1798 09cc CF91      		pop r28
 1799 09ce 0F91      		pop r16
 1800 09d0 FF90      		pop r15
 1801 09d2 EF90      		pop r14
 1802 09d4 DF90      		pop r13
 1803 09d6 CF90      		pop r12
 1804 09d8 BF90      		pop r11
 1805 09da AF90      		pop r10
 1806 09dc 7F90      		pop r7
 1807 09de 6F90      		pop r6
 1808 09e0 5F90      		pop r5
 1809 09e2 4F90      		pop r4
 1810 09e4 0895      		ret
 1815               	.Lscope7:
 1817               		.stabd	78,0,0
 1821               	sync_fs:
 1822               		.stabd	46,0,0
 787:ff.c          **** {
 1824               	.LM163:
 1825               	.LFBB8:
 1826 09e6 0F93      		push r16
 1827 09e8 CF93      		push r28
 1828 09ea DF93      		push r29
 1829               	/* prologue: function */
 1830               	/* frame size = 0 */
 1831               	/* stack size = 3 */
 1832               	.L__stack_usage = 3
 1833 09ec EC01      		movw r28,r24
 791:ff.c          **** 	res = sync_window(fs);
 1835               	.LM164:
 1836 09ee 0E94 0000 		call sync_window
 1837 09f2 982F      		mov r25,r24
 792:ff.c          **** 	if (res == FR_OK) {
 1839               	.LM165:
 1840 09f4 8111      		cpse r24,__zero_reg__
 1841 09f6 00C0      		rjmp .L99
 794:ff.c          **** 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
 1843               	.LM166:
 1844 09f8 8881      		ld r24,Y
 1845 09fa 8330      		cpi r24,lo8(3)
 1846 09fc 01F0      		breq .+2
 1847 09fe 00C0      		rjmp .L100
 794:ff.c          **** 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
 1849               	.LM167:
 1850 0a00 8D81      		ldd r24,Y+5
 1851 0a02 8823      		tst r24
 1852 0a04 01F4      		brne .+2
 1853 0a06 00C0      		rjmp .L100
 795:ff.c          **** 			fs->winsect = 0;
 1855               	.LM168:
 1856 0a08 1EA6      		std Y+46,__zero_reg__
 1857 0a0a 1FA6      		std Y+47,__zero_reg__
 1858 0a0c 18AA      		std Y+48,__zero_reg__
 1859 0a0e 19AA      		std Y+49,__zero_reg__
 797:ff.c          **** 			mem_set(fs->win, 0, 512);
 1861               	.LM169:
 1862 0a10 BE01      		movw r22,r28
 1863 0a12 6E5C      		subi r22,-50
 1864 0a14 7F4F      		sbci r23,-1
 784:ff.c          **** FRESULT sync_fs (	/* FR_OK: successful, FR_DISK_ERR: failed */
 1866               	.LM170:
 1867 0a16 CE01      		movw r24,r28
 1868 0a18 8E5C      		subi r24,-50
 1869 0a1a 9D4F      		sbci r25,-3
 557:ff.c          **** 	BYTE *d = (BYTE*)dst;
 1871               	.LM171:
 1872 0a1c FB01      		movw r30,r22
 1873 0a1e 00C0      		rjmp .L101
 1874               	.L102:
 1875               	.LBB12:
 1876               	.LBB13:
 560:ff.c          **** 		*d++ = (BYTE)val;
 1878               	.LM172:
 1879 0a20 1192      		st Z+,__zero_reg__
 1880               	.L101:
 559:ff.c          **** 	while (cnt--)
 1882               	.LM173:
 1883 0a22 E817      		cp r30,r24
 1884 0a24 F907      		cpc r31,r25
 1885 0a26 01F4      		brne .L102
 1886               	.LBE13:
 1887               	.LBE12:
 798:ff.c          **** 			ST_WORD(fs->win+BS_55AA, 0xAA55);
 1889               	.LM174:
 1890 0a28 FE01      		movw r30,r28
 1891 0a2a E05D      		subi r30,-48
 1892 0a2c FD4F      		sbci r31,-3
 1893 0a2e 85E5      		ldi r24,lo8(85)
 1894 0a30 8083      		st Z,r24
 1895 0a32 FE01      		movw r30,r28
 1896 0a34 EF5C      		subi r30,-49
 1897 0a36 FD4F      		sbci r31,-3
 1898 0a38 8AEA      		ldi r24,lo8(-86)
 1899 0a3a 8083      		st Z,r24
 799:ff.c          **** 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 1901               	.LM175:
 1902 0a3c 82E5      		ldi r24,lo8(82)
 1903 0a3e 8AAB      		std Y+50,r24
 1904 0a40 8BAB      		std Y+51,r24
 1905 0a42 81E6      		ldi r24,lo8(97)
 1906 0a44 8CAB      		std Y+52,r24
 1907 0a46 91E4      		ldi r25,lo8(65)
 1908 0a48 9DAB      		std Y+53,r25
 800:ff.c          **** 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 1910               	.LM176:
 1911 0a4a FE01      		movw r30,r28
 1912 0a4c EA5E      		subi r30,-22
 1913 0a4e FD4F      		sbci r31,-3
 1914 0a50 22E7      		ldi r18,lo8(114)
 1915 0a52 2083      		st Z,r18
 1916 0a54 FE01      		movw r30,r28
 1917 0a56 E95E      		subi r30,-23
 1918 0a58 FD4F      		sbci r31,-3
 1919 0a5a 2083      		st Z,r18
 1920 0a5c FE01      		movw r30,r28
 1921 0a5e E85E      		subi r30,-24
 1922 0a60 FD4F      		sbci r31,-3
 1923 0a62 9083      		st Z,r25
 1924 0a64 FE01      		movw r30,r28
 1925 0a66 E75E      		subi r30,-25
 1926 0a68 FD4F      		sbci r31,-3
 1927 0a6a 8083      		st Z,r24
 801:ff.c          **** 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 1929               	.LM177:
 1930 0a6c 3E85      		ldd r19,Y+14
 1931 0a6e 2F85      		ldd r18,Y+15
 1932 0a70 9889      		ldd r25,Y+16
 1933 0a72 8989      		ldd r24,Y+17
 1934 0a74 FE01      		movw r30,r28
 1935 0a76 E65E      		subi r30,-26
 1936 0a78 FD4F      		sbci r31,-3
 1937 0a7a 3083      		st Z,r19
 1938 0a7c FE01      		movw r30,r28
 1939 0a7e E55E      		subi r30,-27
 1940 0a80 FD4F      		sbci r31,-3
 1941 0a82 2083      		st Z,r18
 1942 0a84 FE01      		movw r30,r28
 1943 0a86 E45E      		subi r30,-28
 1944 0a88 FD4F      		sbci r31,-3
 1945 0a8a 9083      		st Z,r25
 1946 0a8c FE01      		movw r30,r28
 1947 0a8e E35E      		subi r30,-29
 1948 0a90 FD4F      		sbci r31,-3
 1949 0a92 8083      		st Z,r24
 802:ff.c          **** 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 1951               	.LM178:
 1952 0a94 3A85      		ldd r19,Y+10
 1953 0a96 2B85      		ldd r18,Y+11
 1954 0a98 9C85      		ldd r25,Y+12
 1955 0a9a 8D85      		ldd r24,Y+13
 1956 0a9c FE01      		movw r30,r28
 1957 0a9e E25E      		subi r30,-30
 1958 0aa0 FD4F      		sbci r31,-3
 1959 0aa2 3083      		st Z,r19
 1960 0aa4 FE01      		movw r30,r28
 1961 0aa6 E15E      		subi r30,-31
 1962 0aa8 FD4F      		sbci r31,-3
 1963 0aaa 2083      		st Z,r18
 1964 0aac FE01      		movw r30,r28
 1965 0aae E05E      		subi r30,-32
 1966 0ab0 FD4F      		sbci r31,-3
 1967 0ab2 9083      		st Z,r25
 1968 0ab4 FE01      		movw r30,r28
 1969 0ab6 EF5D      		subi r30,-33
 1970 0ab8 FD4F      		sbci r31,-3
 1971 0aba 8083      		st Z,r24
 804:ff.c          **** 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
 1973               	.LM179:
 1974 0abc 2A89      		ldd r18,Y+18
 1975 0abe 3B89      		ldd r19,Y+19
 1976 0ac0 4C89      		ldd r20,Y+20
 1977 0ac2 5D89      		ldd r21,Y+21
 1978 0ac4 01E0      		ldi r16,lo8(1)
 1979 0ac6 8981      		ldd r24,Y+1
 1980 0ac8 0E94 0000 		call disk_write
 805:ff.c          **** 			fs->fsi_flag = 0;
 1982               	.LM180:
 1983 0acc 1D82      		std Y+5,__zero_reg__
 1984               	.L100:
 808:ff.c          **** 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
 1986               	.LM181:
 1987 0ace 40E0      		ldi r20,0
 1988 0ad0 50E0      		ldi r21,0
 1989 0ad2 60E0      		ldi r22,0
 1990 0ad4 8981      		ldd r24,Y+1
 1991 0ad6 0E94 0000 		call disk_ioctl
 1992 0ada 91E0      		ldi r25,lo8(1)
 1993 0adc 8111      		cpse r24,__zero_reg__
 1994 0ade 00C0      		rjmp .L99
 1995 0ae0 90E0      		ldi r25,0
 1996               	.L99:
 813:ff.c          **** }
 1998               	.LM182:
 1999 0ae2 892F      		mov r24,r25
 2000               	/* epilogue start */
 2001 0ae4 DF91      		pop r29
 2002 0ae6 CF91      		pop r28
 2003 0ae8 0F91      		pop r16
 2004 0aea 0895      		ret
 2009               	.Lscope8:
 2011               		.stabd	78,0,0
 2016               	move_window:
 2017               		.stabd	46,0,0
 762:ff.c          **** {
 2019               	.LM183:
 2020               	.LFBB9:
 2021 0aec CF92      		push r12
 2022 0aee DF92      		push r13
 2023 0af0 EF92      		push r14
 2024 0af2 FF92      		push r15
 2025 0af4 0F93      		push r16
 2026 0af6 CF93      		push r28
 2027 0af8 DF93      		push r29
 2028               	/* prologue: function */
 2029               	/* frame size = 0 */
 2030               	/* stack size = 7 */
 2031               	.L__stack_usage = 7
 2032 0afa EC01      		movw r28,r24
 2033 0afc 6A01      		movw r12,r20
 2034 0afe 7B01      		movw r14,r22
 763:ff.c          **** 	if (sector != fs->winsect) {	/* Changed current window */
 2036               	.LM184:
 2037 0b00 8EA5      		ldd r24,Y+46
 2038 0b02 9FA5      		ldd r25,Y+47
 2039 0b04 A8A9      		ldd r26,Y+48
 2040 0b06 B9A9      		ldd r27,Y+49
 2041 0b08 4817      		cp r20,r24
 2042 0b0a 5907      		cpc r21,r25
 2043 0b0c 6A07      		cpc r22,r26
 2044 0b0e 7B07      		cpc r23,r27
 2045 0b10 01F0      		breq .L110
 765:ff.c          **** 		if (sync_window(fs) != FR_OK)
 2047               	.LM185:
 2048 0b12 CE01      		movw r24,r28
 2049 0b14 0E94 0000 		call sync_window
 2050 0b18 8111      		cpse r24,__zero_reg__
 2051 0b1a 00C0      		rjmp .L111
 2052               	.LBB16:
 2053               	.LBB17:
 768:ff.c          **** 		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 2055               	.LM186:
 2056 0b1c BE01      		movw r22,r28
 2057 0b1e 6E5C      		subi r22,-50
 2058 0b20 7F4F      		sbci r23,-1
 2059 0b22 01E0      		ldi r16,lo8(1)
 2060 0b24 A701      		movw r20,r14
 2061 0b26 9601      		movw r18,r12
 2062 0b28 8981      		ldd r24,Y+1
 2063 0b2a 0E94 0000 		call disk_read
 2064 0b2e 8111      		cpse r24,__zero_reg__
 2065 0b30 00C0      		rjmp .L111
 770:ff.c          **** 		fs->winsect = sector;
 2067               	.LM187:
 2068 0b32 CEA6      		std Y+46,r12
 2069 0b34 DFA6      		std Y+47,r13
 2070 0b36 E8AA      		std Y+48,r14
 2071 0b38 F9AA      		std Y+49,r15
 2072 0b3a 00C0      		rjmp .L108
 2073               	.L110:
 2074               	.LBE17:
 2075               	.LBE16:
 773:ff.c          **** 	return FR_OK;
 2077               	.LM188:
 2078 0b3c 80E0      		ldi r24,0
 2079 0b3e 00C0      		rjmp .L108
 2080               	.L111:
 766:ff.c          **** 			return FR_DISK_ERR;
 2082               	.LM189:
 2083 0b40 81E0      		ldi r24,lo8(1)
 2084               	.L108:
 2085               	/* epilogue start */
 774:ff.c          **** }
 2087               	.LM190:
 2088 0b42 DF91      		pop r29
 2089 0b44 CF91      		pop r28
 2090 0b46 0F91      		pop r16
 2091 0b48 FF90      		pop r15
 2092 0b4a EF90      		pop r14
 2093 0b4c DF90      		pop r13
 2094 0b4e CF90      		pop r12
 2095 0b50 0895      		ret
 2097               	.Lscope9:
 2099               		.stabd	78,0,0
 2103               	.global	clust2sect
 2105               	clust2sect:
 2106               		.stabd	46,0,0
 828:ff.c          **** {
 2108               	.LM191:
 2109               	.LFBB10:
 2110 0b52 0F93      		push r16
 2111 0b54 1F93      		push r17
 2112               	/* prologue: function */
 2113               	/* frame size = 0 */
 2114               	/* stack size = 2 */
 2115               	.L__stack_usage = 2
 2116 0b56 FC01      		movw r30,r24
 829:ff.c          **** 	clst -= 2;
 2118               	.LM192:
 2119 0b58 4250      		subi r20,2
 2120 0b5a 5109      		sbc r21,__zero_reg__
 2121 0b5c 6109      		sbc r22,__zero_reg__
 2122 0b5e 7109      		sbc r23,__zero_reg__
 830:ff.c          **** 	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 2124               	.LM193:
 2125 0b60 8689      		ldd r24,Z+22
 2126 0b62 9789      		ldd r25,Z+23
 2127 0b64 A08D      		ldd r26,Z+24
 2128 0b66 B18D      		ldd r27,Z+25
 2129 0b68 0297      		sbiw r24,2
 2130 0b6a A109      		sbc r26,__zero_reg__
 2131 0b6c B109      		sbc r27,__zero_reg__
 2132 0b6e 4817      		cp r20,r24
 2133 0b70 5907      		cpc r21,r25
 2134 0b72 6A07      		cpc r22,r26
 2135 0b74 7B07      		cpc r23,r27
 2136 0b76 00F4      		brsh .L115
 831:ff.c          **** 	return clst * fs->csize + fs->database;
 2138               	.LM194:
 2139 0b78 A281      		ldd r26,Z+2
 2140 0b7a B0E0      		ldi r27,0
 2141 0b7c 9A01      		movw r18,r20
 2142 0b7e AB01      		movw r20,r22
 2143 0b80 0E94 0000 		call __muluhisi3
 2144 0b84 8B01      		movw r16,r22
 2145 0b86 9C01      		movw r18,r24
 2146 0b88 82A5      		ldd r24,Z+42
 2147 0b8a 93A5      		ldd r25,Z+43
 2148 0b8c A4A5      		ldd r26,Z+44
 2149 0b8e B5A5      		ldd r27,Z+45
 2150 0b90 080F      		add r16,r24
 2151 0b92 191F      		adc r17,r25
 2152 0b94 2A1F      		adc r18,r26
 2153 0b96 3B1F      		adc r19,r27
 2154 0b98 00C0      		rjmp .L114
 2155               	.L115:
 830:ff.c          **** 	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 2157               	.LM195:
 2158 0b9a 00E0      		ldi r16,0
 2159 0b9c 10E0      		ldi r17,0
 2160 0b9e 9801      		movw r18,r16
 2161               	.L114:
 832:ff.c          **** }
 2163               	.LM196:
 2164 0ba0 B801      		movw r22,r16
 2165 0ba2 C901      		movw r24,r18
 2166               	/* epilogue start */
 2167 0ba4 1F91      		pop r17
 2168 0ba6 0F91      		pop r16
 2169 0ba8 0895      		ret
 2171               	.Lscope10:
 2173               		.stabd	78,0,0
 2177               	.global	get_fat
 2179               	get_fat:
 2180               		.stabd	46,0,0
 846:ff.c          **** {
 2182               	.LM197:
 2183               	.LFBB11:
 2184 0baa BF92      		push r11
 2185 0bac CF92      		push r12
 2186 0bae DF92      		push r13
 2187 0bb0 EF92      		push r14
 2188 0bb2 FF92      		push r15
 2189 0bb4 0F93      		push r16
 2190 0bb6 1F93      		push r17
 2191 0bb8 CF93      		push r28
 2192 0bba DF93      		push r29
 2193               	/* prologue: function */
 2194               	/* frame size = 0 */
 2195               	/* stack size = 9 */
 2196               	.L__stack_usage = 9
 2197 0bbc EC01      		movw r28,r24
 2198 0bbe 6A01      		movw r12,r20
 2199 0bc0 7B01      		movw r14,r22
 851:ff.c          **** 	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 2201               	.LM198:
 2202 0bc2 4230      		cpi r20,2
 2203 0bc4 5105      		cpc r21,__zero_reg__
 2204 0bc6 6105      		cpc r22,__zero_reg__
 2205 0bc8 7105      		cpc r23,__zero_reg__
 2206 0bca 00F4      		brsh .+2
 2207 0bcc 00C0      		rjmp .L126
 851:ff.c          **** 	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 2209               	.LM199:
 2210 0bce 8E89      		ldd r24,Y+22
 2211 0bd0 9F89      		ldd r25,Y+23
 2212 0bd2 A88D      		ldd r26,Y+24
 2213 0bd4 B98D      		ldd r27,Y+25
 2214 0bd6 4817      		cp r20,r24
 2215 0bd8 5907      		cpc r21,r25
 2216 0bda 6A07      		cpc r22,r26
 2217 0bdc 7B07      		cpc r23,r27
 2218 0bde 00F0      		brlo .+2
 2219 0be0 00C0      		rjmp .L126
 2220               	.LBB20:
 2221               	.LBB21:
 854:ff.c          **** 	switch (fs->fs_type) {
 2223               	.LM200:
 2224 0be2 8881      		ld r24,Y
 2225 0be4 8230      		cpi r24,lo8(2)
 2226 0be6 01F4      		brne .+2
 2227 0be8 00C0      		rjmp .L120
 2228 0bea 8330      		cpi r24,lo8(3)
 2229 0bec 01F4      		brne .+2
 2230 0bee 00C0      		rjmp .L121
 2231 0bf0 8130      		cpi r24,lo8(1)
 2232 0bf2 01F0      		breq .+2
 2233 0bf4 00C0      		rjmp .L128
 856:ff.c          **** 		bc = (UINT)clst; bc += bc / 2;
 2235               	.LM201:
 2236 0bf6 8A01      		movw r16,r20
 2237 0bf8 1695      		lsr r17
 2238 0bfa 0795      		ror r16
 2239 0bfc 040F      		add r16,r20
 2240 0bfe 151F      		adc r17,r21
 857:ff.c          **** 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 2242               	.LM202:
 2243 0c00 C801      		movw r24,r16
 2244 0c02 892F      		mov r24,r25
 2245 0c04 9927      		clr r25
 2246 0c06 8695      		lsr r24
 2247 0c08 4AA1      		ldd r20,Y+34
 2248 0c0a 5BA1      		ldd r21,Y+35
 2249 0c0c 6CA1      		ldd r22,Y+36
 2250 0c0e 7DA1      		ldd r23,Y+37
 2251 0c10 480F      		add r20,r24
 2252 0c12 591F      		adc r21,r25
 2253 0c14 611D      		adc r22,__zero_reg__
 2254 0c16 711D      		adc r23,__zero_reg__
 2255 0c18 CE01      		movw r24,r28
 2256 0c1a 0E94 0000 		call move_window
 2257 0c1e 8111      		cpse r24,__zero_reg__
 2258 0c20 00C0      		rjmp .L128
 2259               	.L122:
 858:ff.c          **** 		wc = fs->win[bc % SS(fs)]; bc++;
 2261               	.LM203:
 2262 0c22 F801      		movw r30,r16
 2263 0c24 F170      		andi r31,1
 2264 0c26 EC0F      		add r30,r28
 2265 0c28 FD1F      		adc r31,r29
 2266 0c2a B2A8      		ldd r11,Z+50
 2267 0c2c 0F5F      		subi r16,-1
 2268 0c2e 1F4F      		sbci r17,-1
 859:ff.c          **** 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 2270               	.LM204:
 2271 0c30 C801      		movw r24,r16
 2272 0c32 892F      		mov r24,r25
 2273 0c34 9927      		clr r25
 2274 0c36 8695      		lsr r24
 2275 0c38 4AA1      		ldd r20,Y+34
 2276 0c3a 5BA1      		ldd r21,Y+35
 2277 0c3c 6CA1      		ldd r22,Y+36
 2278 0c3e 7DA1      		ldd r23,Y+37
 2279 0c40 480F      		add r20,r24
 2280 0c42 591F      		adc r21,r25
 2281 0c44 611D      		adc r22,__zero_reg__
 2282 0c46 711D      		adc r23,__zero_reg__
 2283 0c48 CE01      		movw r24,r28
 2284 0c4a 0E94 0000 		call move_window
 2285 0c4e 8111      		cpse r24,__zero_reg__
 2286 0c50 00C0      		rjmp .L128
 860:ff.c          **** 		wc |= fs->win[bc % SS(fs)] << 8;
 2288               	.LM205:
 2289 0c52 F801      		movw r30,r16
 2290 0c54 F170      		andi r31,1
 2291 0c56 EC0F      		add r30,r28
 2292 0c58 FD1F      		adc r31,r29
 2293 0c5a 12A9      		ldd r17,Z+50
 2294 0c5c 00E0      		ldi r16,0
 2295 0c5e 0B29      		or r16,r11
 861:ff.c          **** 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 2297               	.LM206:
 2298 0c60 C0FE      		sbrs r12,0
 2299 0c62 00C0      		rjmp .L124
 2300 0c64 94E0      		ldi r25,4
 2301               		1:
 2302 0c66 1695      		lsr r17
 2303 0c68 0795      		ror r16
 2304 0c6a 9A95      		dec r25
 2305 0c6c 01F4      		brne 1b
 2306 0c6e 00C0      		rjmp .L129
 2307               	.L124:
 2308               	.LBE21:
 2309 0c70 1F70      		andi r17,15
 2310 0c72 00C0      		rjmp .L129
 2311               	.L120:
 2312               	.LBB22:
 864:ff.c          **** 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 2314               	.LM207:
 2315 0c74 452F      		mov r20,r21
 2316 0c76 562F      		mov r21,r22
 2317 0c78 672F      		mov r22,r23
 2318 0c7a 7727      		clr r23
 2319 0c7c 8AA1      		ldd r24,Y+34
 2320 0c7e 9BA1      		ldd r25,Y+35
 2321 0c80 ACA1      		ldd r26,Y+36
 2322 0c82 BDA1      		ldd r27,Y+37
 2323 0c84 480F      		add r20,r24
 2324 0c86 591F      		adc r21,r25
 2325 0c88 6A1F      		adc r22,r26
 2326 0c8a 7B1F      		adc r23,r27
 2327 0c8c CE01      		movw r24,r28
 2328 0c8e 0E94 0000 		call move_window
 2329 0c92 8111      		cpse r24,__zero_reg__
 2330 0c94 00C0      		rjmp .L128
 865:ff.c          **** 		p = &fs->win[clst * 2 % SS(fs)];
 2332               	.LM208:
 2333 0c96 CC0C      		lsl r12
 2334 0c98 DD1C      		rol r13
 2335 0c9a EE1C      		rol r14
 2336 0c9c FF1C      		rol r15
 2337 0c9e 81E0      		ldi r24,1
 2338 0ca0 D822      		and r13,r24
 2339 0ca2 EE24      		clr r14
 2340 0ca4 FF24      		clr r15
 866:ff.c          **** 		return LD_WORD(p);
 2342               	.LM209:
 2343 0ca6 FE01      		movw r30,r28
 2344 0ca8 EC0D      		add r30,r12
 2345 0caa FD1D      		adc r31,r13
 2346 0cac 22A9      		ldd r18,Z+50
 2347 0cae FE01      		movw r30,r28
 2348 0cb0 EC0D      		add r30,r12
 2349 0cb2 FD1D      		adc r31,r13
 2350 0cb4 93A9      		ldd r25,Z+51
 2351 0cb6 80E0      		ldi r24,0
 2352 0cb8 8C01      		movw r16,r24
 2353 0cba 022B      		or r16,r18
 2354               	.L129:
 2355 0cbc 20E0      		ldi r18,0
 2356 0cbe 30E0      		ldi r19,0
 2357 0cc0 00C0      		rjmp .L117
 2358               	.L121:
 869:ff.c          **** 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 2360               	.LM210:
 2361 0cc2 17E0      		ldi r17,7
 2362               		1:
 2363 0cc4 7695      		lsr r23
 2364 0cc6 6795      		ror r22
 2365 0cc8 5795      		ror r21
 2366 0cca 4795      		ror r20
 2367 0ccc 1A95      		dec r17
 2368 0cce 01F4      		brne 1b
 2369 0cd0 8AA1      		ldd r24,Y+34
 2370 0cd2 9BA1      		ldd r25,Y+35
 2371 0cd4 ACA1      		ldd r26,Y+36
 2372 0cd6 BDA1      		ldd r27,Y+37
 2373 0cd8 480F      		add r20,r24
 2374 0cda 591F      		adc r21,r25
 2375 0cdc 6A1F      		adc r22,r26
 2376 0cde 7B1F      		adc r23,r27
 2377 0ce0 CE01      		movw r24,r28
 2378 0ce2 0E94 0000 		call move_window
 2379 0ce6 8111      		cpse r24,__zero_reg__
 2380 0ce8 00C0      		rjmp .L128
 870:ff.c          **** 		p = &fs->win[clst * 4 % SS(fs)];
 2382               	.LM211:
 2383 0cea A2E0      		ldi r26,2
 2384               		1:
 2385 0cec CC0C      		lsl r12
 2386 0cee DD1C      		rol r13
 2387 0cf0 EE1C      		rol r14
 2388 0cf2 FF1C      		rol r15
 2389 0cf4 AA95      		dec r26
 2390 0cf6 01F4      		brne 1b
 2391 0cf8 81E0      		ldi r24,1
 2392 0cfa D822      		and r13,r24
 2393 0cfc EE24      		clr r14
 2394 0cfe FF24      		clr r15
 2395 0d00 F601      		movw r30,r12
 2396 0d02 F296      		adiw r30,50
 2397 0d04 EC0F      		add r30,r28
 2398 0d06 FD1F      		adc r31,r29
 871:ff.c          **** 		return LD_DWORD(p) & 0x0FFFFFFF;
 2400               	.LM212:
 2401 0d08 8281      		ldd r24,Z+2
 2402 0d0a 0381      		ldd r16,Z+3
 2403 0d0c 10E0      		ldi r17,0
 2404 0d0e 20E0      		ldi r18,0
 2405 0d10 30E0      		ldi r19,0
 2406 0d12 302F      		mov r19,r16
 2407 0d14 2227      		clr r18
 2408 0d16 1127      		clr r17
 2409 0d18 0027      		clr r16
 2410 0d1a 282B      		or r18,r24
 2411 0d1c 9181      		ldd r25,Z+1
 2412 0d1e 80E0      		ldi r24,0
 2413 0d20 A0E0      		ldi r26,0
 2414 0d22 B0E0      		ldi r27,0
 2415 0d24 082B      		or r16,r24
 2416 0d26 192B      		or r17,r25
 2417 0d28 2A2B      		or r18,r26
 2418 0d2a 3B2B      		or r19,r27
 2419 0d2c FE01      		movw r30,r28
 2420 0d2e EC0D      		add r30,r12
 2421 0d30 FD1D      		adc r31,r13
 2422 0d32 82A9      		ldd r24,Z+50
 2423 0d34 082B      		or r16,r24
 2424 0d36 3F70      		andi r19,15
 2425 0d38 00C0      		rjmp .L117
 2426               	.L128:
 874:ff.c          **** 	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
 2428               	.LM213:
 2429 0d3a 0FEF      		ldi r16,lo8(-1)
 2430 0d3c 1FEF      		ldi r17,lo8(-1)
 2431 0d3e 9801      		movw r18,r16
 2432 0d40 00C0      		rjmp .L117
 2433               	.L126:
 2434               	.LBE22:
 2435               	.LBE20:
 852:ff.c          **** 		return 1;
 2437               	.LM214:
 2438 0d42 01E0      		ldi r16,lo8(1)
 2439 0d44 10E0      		ldi r17,0
 2440 0d46 20E0      		ldi r18,0
 2441 0d48 30E0      		ldi r19,0
 2442               	.L117:
 875:ff.c          **** }
 2444               	.LM215:
 2445 0d4a B801      		movw r22,r16
 2446 0d4c C901      		movw r24,r18
 2447               	/* epilogue start */
 2448 0d4e DF91      		pop r29
 2449 0d50 CF91      		pop r28
 2450 0d52 1F91      		pop r17
 2451 0d54 0F91      		pop r16
 2452 0d56 FF90      		pop r15
 2453 0d58 EF90      		pop r14
 2454 0d5a DF90      		pop r13
 2455 0d5c CF90      		pop r12
 2456 0d5e BF90      		pop r11
 2457 0d60 0895      		ret
 2459               	.Lscope11:
 2461               		.stabd	78,0,0
 2466               	dir_sdi:
 2467               		.stabd	46,0,0
1092:ff.c          **** {
 2469               	.LM216:
 2470               	.LFBB12:
 2471 0d62 EF92      		push r14
 2472 0d64 FF92      		push r15
 2473 0d66 0F93      		push r16
 2474 0d68 1F93      		push r17
 2475 0d6a CF93      		push r28
 2476 0d6c DF93      		push r29
 2477               	/* prologue: function */
 2478               	/* frame size = 0 */
 2479               	/* stack size = 6 */
 2480               	.L__stack_usage = 6
 2481 0d6e EC01      		movw r28,r24
 2482 0d70 8B01      		movw r16,r22
1097:ff.c          **** 	dj->index = idx;
 2484               	.LM217:
 2485 0d72 7D83      		std Y+5,r23
 2486 0d74 6C83      		std Y+4,r22
1098:ff.c          **** 	clst = dj->sclust;
 2488               	.LM218:
 2489 0d76 4E81      		ldd r20,Y+6
 2490 0d78 5F81      		ldd r21,Y+7
 2491 0d7a 6885      		ldd r22,Y+8
 2492 0d7c 7985      		ldd r23,Y+9
1099:ff.c          **** 	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
 2494               	.LM219:
 2495 0d7e 4130      		cpi r20,1
 2496 0d80 5105      		cpc r21,__zero_reg__
 2497 0d82 6105      		cpc r22,__zero_reg__
 2498 0d84 7105      		cpc r23,__zero_reg__
 2499 0d86 01F4      		brne .L131
 2500               	.L133:
1100:ff.c          **** 		return FR_INT_ERR;
 2502               	.LM220:
 2503 0d88 82E0      		ldi r24,lo8(2)
 2504 0d8a 00C0      		rjmp .L132
 2505               	.L131:
1099:ff.c          **** 	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
 2507               	.LM221:
 2508 0d8c E881      		ld r30,Y
 2509 0d8e F981      		ldd r31,Y+1
 2510 0d90 8689      		ldd r24,Z+22
 2511 0d92 9789      		ldd r25,Z+23
 2512 0d94 A08D      		ldd r26,Z+24
 2513 0d96 B18D      		ldd r27,Z+25
 2514 0d98 4817      		cp r20,r24
 2515 0d9a 5907      		cpc r21,r25
 2516 0d9c 6A07      		cpc r22,r26
 2517 0d9e 7B07      		cpc r23,r27
 2518 0da0 00F4      		brsh .L133
1101:ff.c          **** 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 2520               	.LM222:
 2521 0da2 4115      		cp r20,__zero_reg__
 2522 0da4 5105      		cpc r21,__zero_reg__
 2523 0da6 6105      		cpc r22,__zero_reg__
 2524 0da8 7105      		cpc r23,__zero_reg__
 2525 0daa 01F4      		brne .L134
1101:ff.c          **** 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 2527               	.LM223:
 2528 0dac 8081      		ld r24,Z
 2529 0dae 8330      		cpi r24,lo8(3)
 2530 0db0 01F4      		brne .L135
1102:ff.c          **** 		clst = dj->fs->dirbase;
 2532               	.LM224:
 2533 0db2 46A1      		ldd r20,Z+38
 2534 0db4 57A1      		ldd r21,Z+39
 2535 0db6 60A5      		ldd r22,Z+40
 2536 0db8 71A5      		ldd r23,Z+41
1104:ff.c          **** 	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
 2538               	.LM225:
 2539 0dba 4115      		cp r20,__zero_reg__
 2540 0dbc 5105      		cpc r21,__zero_reg__
 2541 0dbe 6105      		cpc r22,__zero_reg__
 2542 0dc0 7105      		cpc r23,__zero_reg__
 2543 0dc2 01F4      		brne .L134
 2544               	.L135:
1105:ff.c          **** 		dj->clust = clst;
 2546               	.LM226:
 2547 0dc4 1A86      		std Y+10,__zero_reg__
 2548 0dc6 1B86      		std Y+11,__zero_reg__
 2549 0dc8 1C86      		std Y+12,__zero_reg__
 2550 0dca 1D86      		std Y+13,__zero_reg__
1106:ff.c          **** 		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
 2552               	.LM227:
 2553 0dcc 8085      		ldd r24,Z+8
 2554 0dce 9185      		ldd r25,Z+9
 2555 0dd0 0817      		cp r16,r24
 2556 0dd2 1907      		cpc r17,r25
 2557 0dd4 00F4      		brsh .L133
1108:ff.c          **** 		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
 2559               	.LM228:
 2560 0dd6 9801      		movw r18,r16
 2561 0dd8 A4E0      		ldi r26,4
 2562               		1:
 2563 0dda 3695      		lsr r19
 2564 0ddc 2795      		ror r18
 2565 0dde AA95      		dec r26
 2566 0de0 01F4      		brne 1b
 2567 0de2 86A1      		ldd r24,Z+38
 2568 0de4 97A1      		ldd r25,Z+39
 2569 0de6 A0A5      		ldd r26,Z+40
 2570 0de8 B1A5      		ldd r27,Z+41
 2571 0dea 820F      		add r24,r18
 2572 0dec 931F      		adc r25,r19
 2573 0dee A11D      		adc r26,__zero_reg__
 2574 0df0 B11D      		adc r27,__zero_reg__
 2575 0df2 8E87      		std Y+14,r24
 2576 0df4 9F87      		std Y+15,r25
 2577 0df6 A88B      		std Y+16,r26
 2578 0df8 B98B      		std Y+17,r27
 2579 0dfa 00C0      		rjmp .L136
 2580               	.L134:
1111:ff.c          **** 		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
 2582               	.LM229:
 2583 0dfc E280      		ldd r14,Z+2
 2584 0dfe 80E1      		ldi r24,lo8(16)
 2585 0e00 E89E      		mul r14,r24
 2586 0e02 7001      		movw r14,r0
 2587 0e04 1124      		clr __zero_reg__
1112:ff.c          **** 		while (idx >= ic) {	/* Follow cluster chain */
 2589               	.LM230:
 2590 0e06 00C0      		rjmp .L137
 2591               	.L138:
1113:ff.c          **** 			clst = get_fat(dj->fs, clst);				/* Get next cluster */
 2593               	.LM231:
 2594 0e08 0E94 0000 		call get_fat
 2595 0e0c AB01      		movw r20,r22
 2596 0e0e BC01      		movw r22,r24
1114:ff.c          **** 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 2598               	.LM232:
 2599 0e10 4F3F      		cpi r20,-1
 2600 0e12 8FEF      		ldi r24,-1
 2601 0e14 5807      		cpc r21,r24
 2602 0e16 6807      		cpc r22,r24
 2603 0e18 7807      		cpc r23,r24
 2604 0e1a 01F0      		breq .L139
1115:ff.c          **** 			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
 2606               	.LM233:
 2607 0e1c 4230      		cpi r20,2
 2608 0e1e 5105      		cpc r21,__zero_reg__
 2609 0e20 6105      		cpc r22,__zero_reg__
 2610 0e22 7105      		cpc r23,__zero_reg__
 2611 0e24 00F4      		brsh .+2
 2612 0e26 00C0      		rjmp .L133
1115:ff.c          **** 			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
 2614               	.LM234:
 2615 0e28 E881      		ld r30,Y
 2616 0e2a F981      		ldd r31,Y+1
 2617 0e2c 8689      		ldd r24,Z+22
 2618 0e2e 9789      		ldd r25,Z+23
 2619 0e30 A08D      		ldd r26,Z+24
 2620 0e32 B18D      		ldd r27,Z+25
 2621 0e34 4817      		cp r20,r24
 2622 0e36 5907      		cpc r21,r25
 2623 0e38 6A07      		cpc r22,r26
 2624 0e3a 7B07      		cpc r23,r27
 2625 0e3c 00F0      		brlo .+2
 2626 0e3e 00C0      		rjmp .L133
1117:ff.c          **** 			idx -= ic;
 2628               	.LM235:
 2629 0e40 0E19      		sub r16,r14
 2630 0e42 1F09      		sbc r17,r15
 2631               	.L137:
 2632 0e44 8881      		ld r24,Y
 2633 0e46 9981      		ldd r25,Y+1
1112:ff.c          **** 		while (idx >= ic) {	/* Follow cluster chain */
 2635               	.LM236:
 2636 0e48 0E15      		cp r16,r14
 2637 0e4a 1F05      		cpc r17,r15
 2638 0e4c 00F4      		brsh .L138
1119:ff.c          **** 		dj->clust = clst;
 2640               	.LM237:
 2641 0e4e 4A87      		std Y+10,r20
 2642 0e50 5B87      		std Y+11,r21
 2643 0e52 6C87      		std Y+12,r22
 2644 0e54 7D87      		std Y+13,r23
1120:ff.c          **** 		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
 2646               	.LM238:
 2647 0e56 0E94 0000 		call clust2sect
 2648 0e5a 9801      		movw r18,r16
 2649 0e5c E4E0      		ldi r30,4
 2650               		1:
 2651 0e5e 3695      		lsr r19
 2652 0e60 2795      		ror r18
 2653 0e62 EA95      		dec r30
 2654 0e64 01F4      		brne 1b
 2655 0e66 620F      		add r22,r18
 2656 0e68 731F      		adc r23,r19
 2657 0e6a 811D      		adc r24,__zero_reg__
 2658 0e6c 911D      		adc r25,__zero_reg__
 2659 0e6e 6E87      		std Y+14,r22
 2660 0e70 7F87      		std Y+15,r23
 2661 0e72 888B      		std Y+16,r24
 2662 0e74 998B      		std Y+17,r25
 2663               	.L136:
1123:ff.c          **** 	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector 
 2665               	.LM239:
 2666 0e76 0F70      		andi r16,15
 2667 0e78 1127      		clr r17
 2668 0e7a 55E0      		ldi r21,5
 2669               		1:
 2670 0e7c 000F      		lsl r16
 2671 0e7e 111F      		rol r17
 2672 0e80 5A95      		dec r21
 2673 0e82 01F4      		brne 1b
 2674 0e84 0E5C      		subi r16,-50
 2675 0e86 1F4F      		sbci r17,-1
 2676 0e88 8881      		ld r24,Y
 2677 0e8a 9981      		ldd r25,Y+1
 2678 0e8c 800F      		add r24,r16
 2679 0e8e 911F      		adc r25,r17
 2680 0e90 9B8B      		std Y+19,r25
 2681 0e92 8A8B      		std Y+18,r24
1125:ff.c          **** 	return FR_OK;	/* Seek succeeded */
 2683               	.LM240:
 2684 0e94 80E0      		ldi r24,0
 2685 0e96 00C0      		rjmp .L132
 2686               	.L139:
1114:ff.c          **** 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 2688               	.LM241:
 2689 0e98 81E0      		ldi r24,lo8(1)
 2690               	.L132:
 2691               	/* epilogue start */
1126:ff.c          **** }
 2693               	.LM242:
 2694 0e9a DF91      		pop r29
 2695 0e9c CF91      		pop r28
 2696 0e9e 1F91      		pop r17
 2697 0ea0 0F91      		pop r16
 2698 0ea2 FF90      		pop r15
 2699 0ea4 EF90      		pop r14
 2700 0ea6 0895      		ret
 2706               	.Lscope12:
 2708               		.stabd	78,0,0
 2712               	dir_remove:
 2713               		.stabd	46,0,0
1645:ff.c          **** {
 2715               	.LM243:
 2716               	.LFBB13:
 2717 0ea8 CF93      		push r28
 2718 0eaa DF93      		push r29
 2719               	/* prologue: function */
 2720               	/* frame size = 0 */
 2721               	/* stack size = 2 */
 2722               	.L__stack_usage = 2
 2723 0eac EC01      		movw r28,r24
1665:ff.c          **** 	res = dir_sdi(dj, dj->index);
 2725               	.LM244:
 2726 0eae 6C81      		ldd r22,Y+4
 2727 0eb0 7D81      		ldd r23,Y+5
 2728 0eb2 0E94 0000 		call dir_sdi
1666:ff.c          **** 	if (res == FR_OK) {
 2730               	.LM245:
 2731 0eb6 8111      		cpse r24,__zero_reg__
 2732 0eb8 00C0      		rjmp .L141
 2733               	.LBB25:
 2734               	.LBB26:
1667:ff.c          **** 		res = move_window(dj->fs, dj->sect);
 2736               	.LM246:
 2737 0eba 4E85      		ldd r20,Y+14
 2738 0ebc 5F85      		ldd r21,Y+15
 2739 0ebe 6889      		ldd r22,Y+16
 2740 0ec0 7989      		ldd r23,Y+17
 2741 0ec2 8881      		ld r24,Y
 2742 0ec4 9981      		ldd r25,Y+1
 2743 0ec6 0E94 0000 		call move_window
1668:ff.c          **** 		if (res == FR_OK) {
 2745               	.LM247:
 2746 0eca 8111      		cpse r24,__zero_reg__
 2747 0ecc 00C0      		rjmp .L141
1669:ff.c          **** 			*dj->dir = DDE;			/* Mark the entry "deleted" */
 2749               	.LM248:
 2750 0ece EA89      		ldd r30,Y+18
 2751 0ed0 FB89      		ldd r31,Y+19
 2752 0ed2 95EE      		ldi r25,lo8(-27)
 2753 0ed4 9083      		st Z,r25
1670:ff.c          **** 			dj->fs->wflag = 1;
 2755               	.LM249:
 2756 0ed6 E881      		ld r30,Y
 2757 0ed8 F981      		ldd r31,Y+1
 2758 0eda 91E0      		ldi r25,lo8(1)
 2759 0edc 9483      		std Z+4,r25
 2760               	.L141:
 2761               	/* epilogue start */
 2762               	.LBE26:
 2763               	.LBE25:
1676:ff.c          **** }
 2765               	.LM250:
 2766 0ede DF91      		pop r29
 2767 0ee0 CF91      		pop r28
 2768 0ee2 0895      		ret
 2773               	.Lscope13:
 2775               		.stabd	78,0,0
 2780               	.global	put_fat
 2782               	put_fat:
 2783               		.stabd	46,0,0
 890:ff.c          **** {
 2785               	.LM251:
 2786               	.LFBB14:
 2787 0ee4 4F92      		push r4
 2788 0ee6 5F92      		push r5
 2789 0ee8 6F92      		push r6
 2790 0eea 7F92      		push r7
 2791 0eec 8F92      		push r8
 2792 0eee 9F92      		push r9
 2793 0ef0 AF92      		push r10
 2794 0ef2 BF92      		push r11
 2795 0ef4 CF92      		push r12
 2796 0ef6 DF92      		push r13
 2797 0ef8 EF92      		push r14
 2798 0efa FF92      		push r15
 2799 0efc 0F93      		push r16
 2800 0efe 1F93      		push r17
 2801 0f00 CF93      		push r28
 2802 0f02 DF93      		push r29
 2803 0f04 00D0      		rcall .
 2804 0f06 00D0      		rcall .
 2805 0f08 CDB7      		in r28,__SP_L__
 2806 0f0a DEB7      		in r29,__SP_H__
 2807               	/* prologue: function */
 2808               	/* frame size = 4 */
 2809               	/* stack size = 20 */
 2810               	.L__stack_usage = 20
 2811 0f0c 4C01      		movw r8,r24
 2812 0f0e 6A01      		movw r12,r20
 2813 0f10 7B01      		movw r14,r22
 2814 0f12 2801      		movw r4,r16
 2815 0f14 3901      		movw r6,r18
 896:ff.c          **** 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 2817               	.LM252:
 2818 0f16 4230      		cpi r20,2
 2819 0f18 5105      		cpc r21,__zero_reg__
 2820 0f1a 6105      		cpc r22,__zero_reg__
 2821 0f1c 7105      		cpc r23,__zero_reg__
 2822 0f1e 00F4      		brsh .+2
 2823 0f20 00C0      		rjmp .L154
 896:ff.c          **** 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 2825               	.LM253:
 2826 0f22 FC01      		movw r30,r24
 2827 0f24 8689      		ldd r24,Z+22
 2828 0f26 9789      		ldd r25,Z+23
 2829 0f28 A08D      		ldd r26,Z+24
 2830 0f2a B18D      		ldd r27,Z+25
 2831 0f2c 4817      		cp r20,r24
 2832 0f2e 5907      		cpc r21,r25
 2833 0f30 6A07      		cpc r22,r26
 2834 0f32 7B07      		cpc r23,r27
 2835 0f34 00F0      		brlo .+2
 2836 0f36 00C0      		rjmp .L154
 2837               	.LBB29:
 2838               	.LBB30:
 900:ff.c          **** 		switch (fs->fs_type) {
 2840               	.LM254:
 2841 0f38 8081      		ld r24,Z
 2842 0f3a 8230      		cpi r24,lo8(2)
 2843 0f3c 01F4      		brne .+2
 2844 0f3e 00C0      		rjmp .L147
 2845 0f40 8330      		cpi r24,lo8(3)
 2846 0f42 01F4      		brne .+2
 2847 0f44 00C0      		rjmp .L148
 2848 0f46 8130      		cpi r24,lo8(1)
 2849 0f48 01F0      		breq .+2
 2850 0f4a 00C0      		rjmp .L156
 902:ff.c          **** 			bc = (UINT)clst; bc += bc / 2;
 2852               	.LM255:
 2853 0f4c 5A01      		movw r10,r20
 2854 0f4e B694      		lsr r11
 2855 0f50 A794      		ror r10
 2856 0f52 AC0C      		add r10,r12
 2857 0f54 BD1C      		adc r11,r13
 903:ff.c          **** 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 2859               	.LM256:
 2860 0f56 C501      		movw r24,r10
 2861 0f58 892F      		mov r24,r25
 2862 0f5a 9927      		clr r25
 2863 0f5c 8695      		lsr r24
 2864 0f5e 42A1      		ldd r20,Z+34
 2865 0f60 53A1      		ldd r21,Z+35
 2866 0f62 64A1      		ldd r22,Z+36
 2867 0f64 75A1      		ldd r23,Z+37
 2868 0f66 480F      		add r20,r24
 2869 0f68 591F      		adc r21,r25
 2870 0f6a 611D      		adc r22,__zero_reg__
 2871 0f6c 711D      		adc r23,__zero_reg__
 2872 0f6e C401      		movw r24,r8
 2873 0f70 0E94 0000 		call move_window
 904:ff.c          **** 			if (res != FR_OK) break;
 2875               	.LM257:
 2876 0f74 8111      		cpse r24,__zero_reg__
 2877 0f76 00C0      		rjmp .L145
 905:ff.c          **** 			p = &fs->win[bc % SS(fs)];
 2879               	.LM258:
 2880 0f78 A501      		movw r20,r10
 2881 0f7a 5170      		andi r21,1
 2882 0f7c 480D      		add r20,r8
 2883 0f7e 591D      		adc r21,r9
 906:ff.c          **** 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 2885               	.LM259:
 2886 0f80 D701      		movw r26,r14
 2887 0f82 C601      		movw r24,r12
 2888 0f84 8170      		andi r24,1
 2889 0f86 9927      		clr r25
 2890 0f88 AA27      		clr r26
 2891 0f8a BB27      		clr r27
 2892 0f8c 8983      		std Y+1,r24
 2893 0f8e 9A83      		std Y+2,r25
 2894 0f90 AB83      		std Y+3,r26
 2895 0f92 BC83      		std Y+4,r27
 2896 0f94 C0FE      		sbrs r12,0
 2897 0f96 00C0      		rjmp .L149
 2898               	.LBE30:
 2899 0f98 DA01      		movw r26,r20
 2900 0f9a D296      		adiw r26,50
 2901 0f9c 2C91      		ld r18,X
 2902 0f9e 2F70      		andi r18,lo8(15)
 2903               	.LBB31:
 2904 0fa0 B0E1      		ldi r27,lo8(16)
 2905 0fa2 4B9E      		mul r4,r27
 2906 0fa4 C001      		movw r24,r0
 2907 0fa6 1124      		clr __zero_reg__
 2908 0fa8 282B      		or r18,r24
 2909 0faa 00C0      		rjmp .L150
 2910               	.L149:
 2911 0fac 242D      		mov r18,r4
 2912               	.L150:
 2913 0fae FA01      		movw r30,r20
 2914 0fb0 22AB      		std Z+50,r18
 907:ff.c          **** 			bc++;
 2916               	.LM260:
 2917 0fb2 FFEF      		ldi r31,-1
 2918 0fb4 AF1A      		sub r10,r31
 2919 0fb6 BF0A      		sbc r11,r31
 908:ff.c          **** 			fs->wflag = 1;
 2921               	.LM261:
 2922 0fb8 81E0      		ldi r24,lo8(1)
 2923 0fba D401      		movw r26,r8
 2924 0fbc 1496      		adiw r26,4
 2925 0fbe 8C93      		st X,r24
 2926 0fc0 1497      		sbiw r26,4
 909:ff.c          **** 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 2928               	.LM262:
 2929 0fc2 C501      		movw r24,r10
 2930 0fc4 892F      		mov r24,r25
 2931 0fc6 9927      		clr r25
 2932 0fc8 8695      		lsr r24
 2933 0fca 9296      		adiw r26,34
 2934 0fcc 4D91      		ld r20,X+
 2935 0fce 5D91      		ld r21,X+
 2936 0fd0 6D91      		ld r22,X+
 2937 0fd2 7C91      		ld r23,X
 2938 0fd4 9597      		sbiw r26,34+3
 2939 0fd6 480F      		add r20,r24
 2940 0fd8 591F      		adc r21,r25
 2941 0fda 611D      		adc r22,__zero_reg__
 2942 0fdc 711D      		adc r23,__zero_reg__
 2943 0fde C401      		movw r24,r8
 2944 0fe0 0E94 0000 		call move_window
 910:ff.c          **** 			if (res != FR_OK) break;
 2946               	.LM263:
 2947 0fe4 8111      		cpse r24,__zero_reg__
 2948 0fe6 00C0      		rjmp .L145
 911:ff.c          **** 			p = &fs->win[bc % SS(fs)];
 2950               	.LM264:
 2951 0fe8 F501      		movw r30,r10
 2952 0fea F170      		andi r31,1
 2953 0fec E80D      		add r30,r8
 2954 0fee F91D      		adc r31,r9
 912:ff.c          **** 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 2956               	.LM265:
 2957 0ff0 2981      		ldd r18,Y+1
 2958 0ff2 3A81      		ldd r19,Y+2
 2959 0ff4 4B81      		ldd r20,Y+3
 2960 0ff6 5C81      		ldd r21,Y+4
 2961 0ff8 232B      		or r18,r19
 2962 0ffa 242B      		or r18,r20
 2963 0ffc 252B      		or r18,r21
 2964 0ffe 01F0      		breq .L151
 2965 1000 34E0      		ldi r19,4
 2966               		1:
 2967 1002 7694      		lsr r7
 2968 1004 6794      		ror r6
 2969 1006 5794      		ror r5
 2970 1008 4794      		ror r4
 2971 100a 3A95      		dec r19
 2972 100c 01F4      		brne 1b
 2973 100e 242D      		mov r18,r4
 2974 1010 00C0      		rjmp .L152
 2975               	.L151:
 2976 1012 92A9      		ldd r25,Z+50
 2977 1014 907F      		andi r25,lo8(-16)
 2978               	.LBE31:
 2979 1016 252D      		mov r18,r5
 2980 1018 2F70      		andi r18,lo8(15)
 2981               	.LBB32:
 2982 101a 292B      		or r18,r25
 2983               	.L152:
 2984 101c 22AB      		std Z+50,r18
 2985 101e 00C0      		rjmp .L145
 2986               	.L147:
 916:ff.c          **** 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 2988               	.LM266:
 2989 1020 452F      		mov r20,r21
 2990 1022 562F      		mov r21,r22
 2991 1024 672F      		mov r22,r23
 2992 1026 7727      		clr r23
 2993 1028 F401      		movw r30,r8
 2994 102a 82A1      		ldd r24,Z+34
 2995 102c 93A1      		ldd r25,Z+35
 2996 102e A4A1      		ldd r26,Z+36
 2997 1030 B5A1      		ldd r27,Z+37
 2998 1032 480F      		add r20,r24
 2999 1034 591F      		adc r21,r25
 3000 1036 6A1F      		adc r22,r26
 3001 1038 7B1F      		adc r23,r27
 3002 103a C401      		movw r24,r8
 3003 103c 0E94 0000 		call move_window
 917:ff.c          **** 			if (res != FR_OK) break;
 3005               	.LM267:
 3006 1040 8111      		cpse r24,__zero_reg__
 3007 1042 00C0      		rjmp .L145
 918:ff.c          **** 			p = &fs->win[clst * 2 % SS(fs)];
 3009               	.LM268:
 3010 1044 CC0C      		lsl r12
 3011 1046 DD1C      		rol r13
 3012 1048 EE1C      		rol r14
 3013 104a FF1C      		rol r15
 3014 104c F1E0      		ldi r31,1
 3015 104e DF22      		and r13,r31
 3016 1050 EE24      		clr r14
 3017 1052 FF24      		clr r15
 919:ff.c          **** 			ST_WORD(p, (WORD)val);
 3019               	.LM269:
 3020 1054 F401      		movw r30,r8
 3021 1056 EC0D      		add r30,r12
 3022 1058 FD1D      		adc r31,r13
 3023 105a 42AA      		std Z+50,r4
 3024 105c F401      		movw r30,r8
 3025 105e EC0D      		add r30,r12
 3026 1060 FD1D      		adc r31,r13
 3027 1062 53AA      		std Z+51,r5
 3028 1064 00C0      		rjmp .L145
 3029               	.L148:
 923:ff.c          **** 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 3031               	.LM270:
 3032 1066 07E0      		ldi r16,7
 3033               		1:
 3034 1068 7695      		lsr r23
 3035 106a 6795      		ror r22
 3036 106c 5795      		ror r21
 3037 106e 4795      		ror r20
 3038 1070 0A95      		dec r16
 3039 1072 01F4      		brne 1b
 3040 1074 F401      		movw r30,r8
 3041 1076 82A1      		ldd r24,Z+34
 3042 1078 93A1      		ldd r25,Z+35
 3043 107a A4A1      		ldd r26,Z+36
 3044 107c B5A1      		ldd r27,Z+37
 3045 107e 480F      		add r20,r24
 3046 1080 591F      		adc r21,r25
 3047 1082 6A1F      		adc r22,r26
 3048 1084 7B1F      		adc r23,r27
 3049 1086 C401      		movw r24,r8
 3050 1088 0E94 0000 		call move_window
 924:ff.c          **** 			if (res != FR_OK) break;
 3052               	.LM271:
 3053 108c 8111      		cpse r24,__zero_reg__
 3054 108e 00C0      		rjmp .L145
 925:ff.c          **** 			p = &fs->win[clst * 4 % SS(fs)];
 3056               	.LM272:
 3057 1090 B2E0      		ldi r27,2
 3058               		1:
 3059 1092 CC0C      		lsl r12
 3060 1094 DD1C      		rol r13
 3061 1096 EE1C      		rol r14
 3062 1098 FF1C      		rol r15
 3063 109a BA95      		dec r27
 3064 109c 01F4      		brne 1b
 3065 109e F1E0      		ldi r31,1
 3066 10a0 DF22      		and r13,r31
 3067 10a2 EE24      		clr r14
 3068 10a4 FF24      		clr r15
 3069 10a6 F601      		movw r30,r12
 3070 10a8 F296      		adiw r30,50
 3071 10aa E80D      		add r30,r8
 3072 10ac F91D      		adc r31,r9
 926:ff.c          **** 			val |= LD_DWORD(p) & 0xF0000000;
 3074               	.LM273:
 3075 10ae 4381      		ldd r20,Z+3
 3076 10b0 50E0      		ldi r21,0
 3077 10b2 60E0      		ldi r22,0
 3078 10b4 70E0      		ldi r23,0
 3079 10b6 742F      		mov r23,r20
 3080 10b8 6627      		clr r22
 3081 10ba 5527      		clr r21
 3082 10bc 4427      		clr r20
 3083 10be D401      		movw r26,r8
 3084 10c0 AC0D      		add r26,r12
 3085 10c2 BD1D      		adc r27,r13
 3086 10c4 4427      		clr r20
 3087 10c6 5527      		clr r21
 3088 10c8 6627      		clr r22
 3089 10ca 707F      		andi r23,240
 3090 10cc 4429      		or r20,r4
 3091 10ce 5529      		or r21,r5
 3092 10d0 6629      		or r22,r6
 3093 10d2 7729      		or r23,r7
 927:ff.c          **** 			ST_DWORD(p, val);
 3095               	.LM274:
 3096 10d4 D296      		adiw r26,50
 3097 10d6 4C93      		st X,r20
 3098 10d8 5183      		std Z+1,r21
 3099 10da 6283      		std Z+2,r22
 3100 10dc 7383      		std Z+3,r23
 3101 10de 00C0      		rjmp .L145
 3102               	.L156:
 931:ff.c          **** 			res = FR_INT_ERR;
 3104               	.LM275:
 3105 10e0 82E0      		ldi r24,lo8(2)
 3106               	.L145:
 933:ff.c          **** 		fs->wflag = 1;
 3108               	.LM276:
 3109 10e2 91E0      		ldi r25,lo8(1)
 3110 10e4 D401      		movw r26,r8
 3111 10e6 1496      		adiw r26,4
 3112 10e8 9C93      		st X,r25
 3113 10ea 00C0      		rjmp .L144
 3114               	.L154:
 3115               	.LBE32:
 3116               	.LBE29:
 897:ff.c          **** 		res = FR_INT_ERR;
 3118               	.LM277:
 3119 10ec 82E0      		ldi r24,lo8(2)
 3120               	.L144:
 3121               	/* epilogue start */
 937:ff.c          **** }
 3123               	.LM278:
 3124 10ee 0F90      		pop __tmp_reg__
 3125 10f0 0F90      		pop __tmp_reg__
 3126 10f2 0F90      		pop __tmp_reg__
 3127 10f4 0F90      		pop __tmp_reg__
 3128 10f6 DF91      		pop r29
 3129 10f8 CF91      		pop r28
 3130 10fa 1F91      		pop r17
 3131 10fc 0F91      		pop r16
 3132 10fe FF90      		pop r15
 3133 1100 EF90      		pop r14
 3134 1102 DF90      		pop r13
 3135 1104 CF90      		pop r12
 3136 1106 BF90      		pop r11
 3137 1108 AF90      		pop r10
 3138 110a 9F90      		pop r9
 3139 110c 8F90      		pop r8
 3140 110e 7F90      		pop r7
 3141 1110 6F90      		pop r6
 3142 1112 5F90      		pop r5
 3143 1114 4F90      		pop r4
 3144 1116 0895      		ret
 3152               	.Lscope14:
 3154               		.stabd	78,0,0
 3159               	create_chain:
 3160               		.stabd	46,0,0
1005:ff.c          **** {
 3162               	.LM279:
 3163               	.LFBB15:
 3164 1118 4F92      		push r4
 3165 111a 5F92      		push r5
 3166 111c 6F92      		push r6
 3167 111e 7F92      		push r7
 3168 1120 8F92      		push r8
 3169 1122 9F92      		push r9
 3170 1124 AF92      		push r10
 3171 1126 BF92      		push r11
 3172 1128 CF92      		push r12
 3173 112a DF92      		push r13
 3174 112c EF92      		push r14
 3175 112e FF92      		push r15
 3176 1130 0F93      		push r16
 3177 1132 1F93      		push r17
 3178 1134 CF93      		push r28
 3179 1136 DF93      		push r29
 3180               	/* prologue: function */
 3181               	/* frame size = 0 */
 3182               	/* stack size = 16 */
 3183               	.L__stack_usage = 16
 3184 1138 EC01      		movw r28,r24
 3185 113a 4A01      		movw r8,r20
 3186 113c 5B01      		movw r10,r22
1010:ff.c          **** 	if (clst == 0) {		/* Create a new chain */
 3188               	.LM280:
 3189 113e 4115      		cp r20,__zero_reg__
 3190 1140 5105      		cpc r21,__zero_reg__
 3191 1142 6105      		cpc r22,__zero_reg__
 3192 1144 7105      		cpc r23,__zero_reg__
 3193 1146 01F4      		brne .L158
1011:ff.c          **** 		scl = fs->last_clust;			/* Get suggested start point */
 3195               	.LM281:
 3196 1148 4A84      		ldd r4,Y+10
 3197 114a 5B84      		ldd r5,Y+11
 3198 114c 6C84      		ldd r6,Y+12
 3199 114e 7D84      		ldd r7,Y+13
1012:ff.c          **** 		if (!scl || scl >= fs->n_fatent) scl = 1;
 3201               	.LM282:
 3202 1150 4114      		cp r4,__zero_reg__
 3203 1152 5104      		cpc r5,__zero_reg__
 3204 1154 6104      		cpc r6,__zero_reg__
 3205 1156 7104      		cpc r7,__zero_reg__
 3206 1158 01F0      		breq .L174
1012:ff.c          **** 		if (!scl || scl >= fs->n_fatent) scl = 1;
 3208               	.LM283:
 3209 115a 8E89      		ldd r24,Y+22
 3210 115c 9F89      		ldd r25,Y+23
 3211 115e A88D      		ldd r26,Y+24
 3212 1160 B98D      		ldd r27,Y+25
 3213 1162 4816      		cp r4,r24
 3214 1164 5906      		cpc r5,r25
 3215 1166 6A06      		cpc r6,r26
 3216 1168 7B06      		cpc r7,r27
 3217 116a 00F4      		brsh .L174
 3218 116c 00C0      		rjmp .L159
 3219               	.L158:
1015:ff.c          **** 		cs = get_fat(fs, clst);			/* Check the cluster status */
 3221               	.LM284:
 3222 116e 0E94 0000 		call get_fat
 3223 1172 6B01      		movw r12,r22
 3224 1174 7C01      		movw r14,r24
1016:ff.c          **** 		if (cs < 2) return 1;			/* It is an invalid cluster */
 3226               	.LM285:
 3227 1176 6230      		cpi r22,2
 3228 1178 7105      		cpc r23,__zero_reg__
 3229 117a 8105      		cpc r24,__zero_reg__
 3230 117c 9105      		cpc r25,__zero_reg__
 3231 117e 00F4      		brsh .L160
 3232 1180 00C0      		rjmp .L185
 3233               	.L160:
1017:ff.c          **** 		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 3235               	.LM286:
 3236 1182 8E89      		ldd r24,Y+22
 3237 1184 9F89      		ldd r25,Y+23
 3238 1186 A88D      		ldd r26,Y+24
 3239 1188 B98D      		ldd r27,Y+25
 3240 118a C816      		cp r12,r24
 3241 118c D906      		cpc r13,r25
 3242 118e EA06      		cpc r14,r26
 3243 1190 FB06      		cpc r15,r27
 3244 1192 00F4      		brsh .+2
 3245 1194 00C0      		rjmp .L161
 3246 1196 2401      		movw r4,r8
 3247 1198 3501      		movw r6,r10
 3248 119a 00C0      		rjmp .L159
 3249               	.L174:
1012:ff.c          **** 		if (!scl || scl >= fs->n_fatent) scl = 1;
 3251               	.LM287:
 3252 119c 412C      		mov r4,__zero_reg__
 3253 119e 512C      		mov r5,__zero_reg__
 3254 11a0 3201      		movw r6,r4
 3255 11a2 4394      		inc r4
 3256               	.L159:
 3257 11a4 7301      		movw r14,r6
 3258 11a6 6201      		movw r12,r4
 3259               	.L167:
1023:ff.c          **** 		ncl++;							/* Next cluster */
 3261               	.LM288:
 3262 11a8 8FEF      		ldi r24,-1
 3263 11aa C81A      		sub r12,r24
 3264 11ac D80A      		sbc r13,r24
 3265 11ae E80A      		sbc r14,r24
 3266 11b0 F80A      		sbc r15,r24
1024:ff.c          **** 		if (ncl >= fs->n_fatent) {		/* Wrap around */
 3268               	.LM289:
 3269 11b2 8E89      		ldd r24,Y+22
 3270 11b4 9F89      		ldd r25,Y+23
 3271 11b6 A88D      		ldd r26,Y+24
 3272 11b8 B98D      		ldd r27,Y+25
 3273 11ba C816      		cp r12,r24
 3274 11bc D906      		cpc r13,r25
 3275 11be EA06      		cpc r14,r26
 3276 11c0 FB06      		cpc r15,r27
 3277 11c2 00F0      		brlo .L162
1026:ff.c          **** 			if (ncl > scl) return 0;	/* No free cluster */
 3279               	.LM290:
 3280 11c4 22E0      		ldi r18,2
 3281 11c6 4216      		cp r4,r18
 3282 11c8 5104      		cpc r5,__zero_reg__
 3283 11ca 6104      		cpc r6,__zero_reg__
 3284 11cc 7104      		cpc r7,__zero_reg__
 3285 11ce 00F4      		brsh .L175
 3286               	.L166:
 3287 11d0 C12C      		mov r12,__zero_reg__
 3288 11d2 D12C      		mov r13,__zero_reg__
 3289 11d4 7601      		movw r14,r12
 3290 11d6 00C0      		rjmp .L161
 3291               	.L175:
1025:ff.c          **** 			ncl = 2;
 3293               	.LM291:
 3294 11d8 E2E0      		ldi r30,lo8(2)
 3295 11da CE2E      		mov r12,r30
 3296 11dc D12C      		mov r13,__zero_reg__
 3297 11de E12C      		mov r14,__zero_reg__
 3298 11e0 F12C      		mov r15,__zero_reg__
 3299               	.L162:
1028:ff.c          **** 		cs = get_fat(fs, ncl);			/* Get the cluster status */
 3301               	.LM292:
 3302 11e2 B701      		movw r22,r14
 3303 11e4 A601      		movw r20,r12
 3304 11e6 CE01      		movw r24,r28
 3305 11e8 0E94 0000 		call get_fat
1029:ff.c          **** 		if (cs == 0) break;				/* Found a free cluster */
 3307               	.LM293:
 3308 11ec 6115      		cp r22,__zero_reg__
 3309 11ee 7105      		cpc r23,__zero_reg__
 3310 11f0 8105      		cpc r24,__zero_reg__
 3311 11f2 9105      		cpc r25,__zero_reg__
 3312 11f4 01F0      		breq .L163
1030:ff.c          **** 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
 3314               	.LM294:
 3315 11f6 6F3F      		cpi r22,-1
 3316 11f8 2FEF      		ldi r18,-1
 3317 11fa 7207      		cpc r23,r18
 3318 11fc 8207      		cpc r24,r18
 3319 11fe 9207      		cpc r25,r18
 3320 1200 01F4      		brne .L164
 3321               	.L172:
1046:ff.c          **** 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 3323               	.LM295:
 3324 1202 CC24      		clr r12
 3325 1204 CA94      		dec r12
 3326 1206 DC2C      		mov r13,r12
 3327 1208 7601      		movw r14,r12
 3328 120a 00C0      		rjmp .L161
 3329               	.L164:
1030:ff.c          **** 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
 3331               	.LM296:
 3332 120c 6130      		cpi r22,1
 3333 120e 7105      		cpc r23,__zero_reg__
 3334 1210 8105      		cpc r24,__zero_reg__
 3335 1212 9105      		cpc r25,__zero_reg__
 3336 1214 01F4      		brne .+2
 3337 1216 00C0      		rjmp .L185
1032:ff.c          **** 		if (ncl == scl) return 0;		/* No free cluster */
 3339               	.LM297:
 3340 1218 C414      		cp r12,r4
 3341 121a D504      		cpc r13,r5
 3342 121c E604      		cpc r14,r6
 3343 121e F704      		cpc r15,r7
 3344 1220 01F4      		brne .L167
 3345 1222 00C0      		rjmp .L166
 3346               	.L163:
1029:ff.c          **** 		if (cs == 0) break;				/* Found a free cluster */
 3348               	.LM298:
 3349 1224 7C2C      		mov r7,r12
 3350 1226 6D2C      		mov r6,r13
 3351 1228 5E2C      		mov r5,r14
 3352 122a 4F2C      		mov r4,r15
1035:ff.c          **** 	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
 3354               	.LM299:
 3355 122c 0FEF      		ldi r16,lo8(-1)
 3356 122e 1FEF      		ldi r17,lo8(-1)
 3357 1230 2FEF      		ldi r18,lo8(-1)
 3358 1232 3FE0      		ldi r19,lo8(15)
 3359 1234 A601      		movw r20,r12
 3360 1236 B701      		movw r22,r14
 3361 1238 CE01      		movw r24,r28
 3362 123a 0E94 0000 		call put_fat
1036:ff.c          **** 	if (res == FR_OK && clst != 0) {
 3364               	.LM300:
 3365 123e 8111      		cpse r24,__zero_reg__
 3366 1240 00C0      		rjmp .L168
1036:ff.c          **** 	if (res == FR_OK && clst != 0) {
 3368               	.LM301:
 3369 1242 8114      		cp r8,__zero_reg__
 3370 1244 9104      		cpc r9,__zero_reg__
 3371 1246 A104      		cpc r10,__zero_reg__
 3372 1248 B104      		cpc r11,__zero_reg__
 3373 124a 01F4      		brne .L169
 3374               	.L171:
1040:ff.c          **** 		fs->last_clust = ncl;			/* Update FSINFO */
 3376               	.LM302:
 3377 124c 7A86      		std Y+10,r7
 3378 124e 6B86      		std Y+11,r6
 3379 1250 5C86      		std Y+12,r5
 3380 1252 4D86      		std Y+13,r4
1041:ff.c          **** 		if (fs->free_clust != 0xFFFFFFFF) {
 3382               	.LM303:
 3383 1254 8E85      		ldd r24,Y+14
 3384 1256 9F85      		ldd r25,Y+15
 3385 1258 A889      		ldd r26,Y+16
 3386 125a B989      		ldd r27,Y+17
 3387 125c 8F3F      		cpi r24,-1
 3388 125e 2FEF      		ldi r18,-1
 3389 1260 9207      		cpc r25,r18
 3390 1262 A207      		cpc r26,r18
 3391 1264 B207      		cpc r27,r18
 3392 1266 01F4      		brne .L170
 3393 1268 00C0      		rjmp .L161
 3394               	.L169:
1037:ff.c          **** 		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
 3396               	.LM304:
 3397 126a 8601      		movw r16,r12
 3398 126c 9701      		movw r18,r14
 3399 126e B501      		movw r22,r10
 3400 1270 A401      		movw r20,r8
 3401 1272 CE01      		movw r24,r28
 3402 1274 0E94 0000 		call put_fat
1039:ff.c          **** 	if (res == FR_OK) {
 3404               	.LM305:
 3405 1278 8823      		tst r24
 3406 127a 01F0      		breq .L171
 3407 127c 00C0      		rjmp .L168
 3408               	.L170:
1042:ff.c          **** 			fs->free_clust--;
 3410               	.LM306:
 3411 127e 0197      		sbiw r24,1
 3412 1280 A109      		sbc r26,__zero_reg__
 3413 1282 B109      		sbc r27,__zero_reg__
 3414 1284 8E87      		std Y+14,r24
 3415 1286 9F87      		std Y+15,r25
 3416 1288 A88B      		std Y+16,r26
 3417 128a B98B      		std Y+17,r27
1043:ff.c          **** 			fs->fsi_flag = 1;
 3419               	.LM307:
 3420 128c 81E0      		ldi r24,lo8(1)
 3421 128e 8D83      		std Y+5,r24
 3422 1290 00C0      		rjmp .L161
 3423               	.L168:
1046:ff.c          **** 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 3425               	.LM308:
 3426 1292 8130      		cpi r24,lo8(1)
 3427 1294 01F4      		brne .+2
 3428 1296 00C0      		rjmp .L172
 3429               	.L185:
 3430 1298 C12C      		mov r12,__zero_reg__
 3431 129a D12C      		mov r13,__zero_reg__
 3432 129c 7601      		movw r14,r12
 3433 129e C394      		inc r12
 3434               	.L161:
1050:ff.c          **** }
 3436               	.LM309:
 3437 12a0 B601      		movw r22,r12
 3438 12a2 C701      		movw r24,r14
 3439               	/* epilogue start */
 3440 12a4 DF91      		pop r29
 3441 12a6 CF91      		pop r28
 3442 12a8 1F91      		pop r17
 3443 12aa 0F91      		pop r16
 3444 12ac FF90      		pop r15
 3445 12ae EF90      		pop r14
 3446 12b0 DF90      		pop r13
 3447 12b2 CF90      		pop r12
 3448 12b4 BF90      		pop r11
 3449 12b6 AF90      		pop r10
 3450 12b8 9F90      		pop r9
 3451 12ba 8F90      		pop r8
 3452 12bc 7F90      		pop r7
 3453 12be 6F90      		pop r6
 3454 12c0 5F90      		pop r5
 3455 12c2 4F90      		pop r4
 3456 12c4 0895      		ret
 3462               	.Lscope15:
 3464               		.stabd	78,0,0
 3469               	dir_next:
 3470               		.stabd	46,0,0
1140:ff.c          **** {
 3472               	.LM310:
 3473               	.LFBB16:
 3474 12c6 8F92      		push r8
 3475 12c8 9F92      		push r9
 3476 12ca AF92      		push r10
 3477 12cc BF92      		push r11
 3478 12ce CF92      		push r12
 3479 12d0 DF92      		push r13
 3480 12d2 EF92      		push r14
 3481 12d4 FF92      		push r15
 3482 12d6 0F93      		push r16
 3483 12d8 1F93      		push r17
 3484 12da CF93      		push r28
 3485 12dc DF93      		push r29
 3486               	/* prologue: function */
 3487               	/* frame size = 0 */
 3488               	/* stack size = 12 */
 3489               	.L__stack_usage = 12
 3490 12de EC01      		movw r28,r24
 3491 12e0 6B01      		movw r12,r22
1146:ff.c          **** 	i = dj->index + 1;
 3493               	.LM311:
 3494 12e2 0C81      		ldd r16,Y+4
 3495 12e4 1D81      		ldd r17,Y+5
 3496 12e6 0F5F      		subi r16,-1
 3497 12e8 1F4F      		sbci r17,-1
1147:ff.c          **** 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 3499               	.LM312:
 3500 12ea 01F4      		brne .L187
 3501               	.L189:
 3502               	.LBB36:
1148:ff.c          **** 		return FR_NO_FILE;
 3504               	.LM313:
 3505 12ec 84E0      		ldi r24,lo8(4)
 3506 12ee 00C0      		rjmp .L188
 3507               	.L187:
 3508               	.LBE36:
1147:ff.c          **** 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 3510               	.LM314:
 3511 12f0 8E85      		ldd r24,Y+14
 3512 12f2 9F85      		ldd r25,Y+15
 3513 12f4 A889      		ldd r26,Y+16
 3514 12f6 B989      		ldd r27,Y+17
 3515 12f8 0097      		sbiw r24,0
 3516 12fa A105      		cpc r26,__zero_reg__
 3517 12fc B105      		cpc r27,__zero_reg__
 3518 12fe 01F0      		breq .L189
1150:ff.c          **** 	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
 3520               	.LM315:
 3521 1300 2FE0      		ldi r18,lo8(15)
 3522 1302 E22E      		mov r14,r18
 3523 1304 F12C      		mov r15,__zero_reg__
 3524 1306 E022      		and r14,r16
 3525 1308 F122      		and r15,r17
 3526 130a E114      		cp r14,__zero_reg__
 3527 130c F104      		cpc r15,__zero_reg__
 3528 130e 01F0      		breq .+2
 3529 1310 00C0      		rjmp .L191
1151:ff.c          **** 		dj->sect++;					/* Next sector */
 3531               	.LM316:
 3532 1312 0196      		adiw r24,1
 3533 1314 A11D      		adc r26,__zero_reg__
 3534 1316 B11D      		adc r27,__zero_reg__
 3535 1318 8E87      		std Y+14,r24
 3536 131a 9F87      		std Y+15,r25
 3537 131c A88B      		std Y+16,r26
 3538 131e B98B      		std Y+17,r27
1153:ff.c          **** 		if (dj->clust == 0) {	/* Static table */
 3540               	.LM317:
 3541 1320 4A85      		ldd r20,Y+10
 3542 1322 5B85      		ldd r21,Y+11
 3543 1324 6C85      		ldd r22,Y+12
 3544 1326 7D85      		ldd r23,Y+13
 3545 1328 8881      		ld r24,Y
 3546 132a 9981      		ldd r25,Y+1
1154:ff.c          **** 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 3548               	.LM318:
 3549 132c FC01      		movw r30,r24
1153:ff.c          **** 		if (dj->clust == 0) {	/* Static table */
 3551               	.LM319:
 3552 132e 4115      		cp r20,__zero_reg__
 3553 1330 5105      		cpc r21,__zero_reg__
 3554 1332 6105      		cpc r22,__zero_reg__
 3555 1334 7105      		cpc r23,__zero_reg__
 3556 1336 01F4      		brne .L192
1154:ff.c          **** 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 3558               	.LM320:
 3559 1338 8085      		ldd r24,Z+8
 3560 133a 9185      		ldd r25,Z+9
 3561 133c 0817      		cp r16,r24
 3562 133e 1907      		cpc r17,r25
 3563 1340 00F4      		brsh .L189
 3564 1342 00C0      		rjmp .L191
 3565               	.L192:
1158:ff.c          **** 			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
 3567               	.LM321:
 3568 1344 2281      		ldd r18,Z+2
 3569 1346 30E0      		ldi r19,0
 3570 1348 2150      		subi r18,1
 3571 134a 3109      		sbc r19,__zero_reg__
 3572 134c F801      		movw r30,r16
 3573 134e B4E0      		ldi r27,4
 3574               		1:
 3575 1350 F695      		lsr r31
 3576 1352 E795      		ror r30
 3577 1354 BA95      		dec r27
 3578 1356 01F4      		brne 1b
 3579 1358 2E23      		and r18,r30
 3580 135a 3F23      		and r19,r31
 3581 135c 232B      		or r18,r19
 3582 135e 01F0      		breq .+2
 3583 1360 00C0      		rjmp .L191
1159:ff.c          **** 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
 3585               	.LM322:
 3586 1362 0E94 0000 		call get_fat
 3587 1366 4B01      		movw r8,r22
 3588 1368 5C01      		movw r10,r24
1160:ff.c          **** 				if (clst <= 1) return FR_INT_ERR;
 3590               	.LM323:
 3591 136a 6230      		cpi r22,2
 3592 136c 7105      		cpc r23,__zero_reg__
 3593 136e 8105      		cpc r24,__zero_reg__
 3594 1370 9105      		cpc r25,__zero_reg__
 3595 1372 00F4      		brsh .L194
 3596               	.L197:
 3597 1374 82E0      		ldi r24,lo8(2)
 3598 1376 00C0      		rjmp .L188
 3599               	.L194:
1161:ff.c          **** 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 3601               	.LM324:
 3602 1378 8FEF      		ldi r24,-1
 3603 137a 8816      		cp r8,r24
 3604 137c 9806      		cpc r9,r24
 3605 137e A806      		cpc r10,r24
 3606 1380 B806      		cpc r11,r24
 3607 1382 01F4      		brne .L195
 3608               	.L198:
 3609 1384 81E0      		ldi r24,lo8(1)
 3610 1386 00C0      		rjmp .L188
 3611               	.L195:
1162:ff.c          **** 				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
 3613               	.LM325:
 3614 1388 8881      		ld r24,Y
 3615 138a 9981      		ldd r25,Y+1
 3616 138c FC01      		movw r30,r24
 3617 138e 4689      		ldd r20,Z+22
 3618 1390 5789      		ldd r21,Z+23
 3619 1392 608D      		ldd r22,Z+24
 3620 1394 718D      		ldd r23,Z+25
 3621 1396 8416      		cp r8,r20
 3622 1398 9506      		cpc r9,r21
 3623 139a A606      		cpc r10,r22
 3624 139c B706      		cpc r11,r23
 3625 139e 00F4      		brsh .+2
 3626 13a0 00C0      		rjmp .L196
 3627               	.LBB39:
1165:ff.c          **** 					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
 3629               	.LM326:
 3630 13a2 CD28      		or r12,r13
 3631 13a4 01F4      		brne .+2
 3632 13a6 00C0      		rjmp .L189
1166:ff.c          **** 					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
 3634               	.LM327:
 3635 13a8 4A85      		ldd r20,Y+10
 3636 13aa 5B85      		ldd r21,Y+11
 3637 13ac 6C85      		ldd r22,Y+12
 3638 13ae 7D85      		ldd r23,Y+13
 3639 13b0 0E94 0000 		call create_chain
 3640 13b4 4B01      		movw r8,r22
 3641 13b6 5C01      		movw r10,r24
1167:ff.c          **** 					if (clst == 0) return FR_DENIED;			/* No free cluster */
 3643               	.LM328:
 3644 13b8 6115      		cp r22,__zero_reg__
 3645 13ba 7105      		cpc r23,__zero_reg__
 3646 13bc 8105      		cpc r24,__zero_reg__
 3647 13be 9105      		cpc r25,__zero_reg__
 3648 13c0 01F4      		brne .+2
 3649 13c2 00C0      		rjmp .L203
1168:ff.c          **** 					if (clst == 1) return FR_INT_ERR;
 3651               	.LM329:
 3652 13c4 6130      		cpi r22,1
 3653 13c6 7105      		cpc r23,__zero_reg__
 3654 13c8 8105      		cpc r24,__zero_reg__
 3655 13ca 9105      		cpc r25,__zero_reg__
 3656 13cc 01F0      		breq .L197
1169:ff.c          **** 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 3658               	.LM330:
 3659 13ce 8FEF      		ldi r24,-1
 3660 13d0 8816      		cp r8,r24
 3661 13d2 9806      		cpc r9,r24
 3662 13d4 A806      		cpc r10,r24
 3663 13d6 B806      		cpc r11,r24
 3664 13d8 01F0      		breq .L198
1171:ff.c          **** 					if (sync_window(dj->fs)) return FR_DISK_ERR;	/* Flush active window */
 3666               	.LM331:
 3667 13da 8881      		ld r24,Y
 3668 13dc 9981      		ldd r25,Y+1
 3669 13de 0E94 0000 		call sync_window
 3670 13e2 8111      		cpse r24,__zero_reg__
 3671 13e4 00C0      		rjmp .L198
1172:ff.c          **** 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
 3673               	.LM332:
 3674 13e6 8881      		ld r24,Y
 3675 13e8 9981      		ldd r25,Y+1
 3676 13ea FC01      		movw r30,r24
 3677 13ec F296      		adiw r30,50
1136:ff.c          **** FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
 3679               	.LM333:
 3680 13ee 8E5C      		subi r24,-50
 3681 13f0 9D4F      		sbci r25,-3
 3682 13f2 00C0      		rjmp .L199
 3683               	.L200:
 3684               	.LBB37:
 3685               	.LBB38:
 560:ff.c          **** 		*d++ = (BYTE)val;
 3687               	.LM334:
 3688 13f4 1192      		st Z+,__zero_reg__
 3689               	.L199:
 559:ff.c          **** 	while (cnt--)
 3691               	.LM335:
 3692 13f6 E817      		cp r30,r24
 3693 13f8 F907      		cpc r31,r25
 3694 13fa 01F4      		brne .L200
 3695               	.LBE38:
 3696               	.LBE37:
1173:ff.c          **** 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
 3698               	.LM336:
 3699 13fc C880      		ld r12,Y
 3700 13fe D980      		ldd r13,Y+1
 3701 1400 B501      		movw r22,r10
 3702 1402 A401      		movw r20,r8
 3703 1404 C601      		movw r24,r12
 3704 1406 0E94 0000 		call clust2sect
 3705 140a F601      		movw r30,r12
 3706 140c 66A7      		std Z+46,r22
 3707 140e 77A7      		std Z+47,r23
 3708 1410 80AB      		std Z+48,r24
 3709 1412 91AB      		std Z+49,r25
1174:ff.c          **** 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 3711               	.LM337:
 3712 1414 D12C      		mov r13,__zero_reg__
1175:ff.c          **** 						dj->fs->wflag = 1;
 3714               	.LM338:
 3715 1416 CC24      		clr r12
 3716 1418 C394      		inc r12
1174:ff.c          **** 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 3718               	.LM339:
 3719 141a 00C0      		rjmp .L201
 3720               	.L202:
1175:ff.c          **** 						dj->fs->wflag = 1;
 3722               	.LM340:
 3723 141c C482      		std Z+4,r12
1176:ff.c          **** 						if (sync_window(dj->fs)) return FR_DISK_ERR;
 3725               	.LM341:
 3726 141e 8881      		ld r24,Y
 3727 1420 9981      		ldd r25,Y+1
 3728 1422 0E94 0000 		call sync_window
 3729 1426 8111      		cpse r24,__zero_reg__
 3730 1428 00C0      		rjmp .L198
1177:ff.c          **** 						dj->fs->winsect++;
 3732               	.LM342:
 3733 142a E881      		ld r30,Y
 3734 142c F981      		ldd r31,Y+1
 3735 142e 86A5      		ldd r24,Z+46
 3736 1430 97A5      		ldd r25,Z+47
 3737 1432 A0A9      		ldd r26,Z+48
 3738 1434 B1A9      		ldd r27,Z+49
 3739 1436 0196      		adiw r24,1
 3740 1438 A11D      		adc r26,__zero_reg__
 3741 143a B11D      		adc r27,__zero_reg__
 3742 143c 86A7      		std Z+46,r24
 3743 143e 97A7      		std Z+47,r25
 3744 1440 A0AB      		std Z+48,r26
 3745 1442 B1AB      		std Z+49,r27
1174:ff.c          **** 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 3747               	.LM343:
 3748 1444 D394      		inc r13
 3749               	.L201:
1174:ff.c          **** 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 3751               	.LM344:
 3752 1446 E881      		ld r30,Y
 3753 1448 F981      		ldd r31,Y+1
 3754 144a 8281      		ldd r24,Z+2
 3755 144c D816      		cp r13,r24
 3756 144e 00F0      		brlo .L202
1179:ff.c          **** 					dj->fs->winsect -= c;						/* Rewind window address */
 3758               	.LM345:
 3759 1450 86A5      		ldd r24,Z+46
 3760 1452 97A5      		ldd r25,Z+47
 3761 1454 A0A9      		ldd r26,Z+48
 3762 1456 B1A9      		ldd r27,Z+49
 3763 1458 8D19      		sub r24,r13
 3764 145a 9109      		sbc r25,__zero_reg__
 3765 145c A109      		sbc r26,__zero_reg__
 3766 145e B109      		sbc r27,__zero_reg__
 3767 1460 86A7      		std Z+46,r24
 3768 1462 97A7      		std Z+47,r25
 3769 1464 A0AB      		std Z+48,r26
 3770 1466 B1AB      		std Z+49,r27
 3771               	.L196:
 3772               	.LBE39:
1184:ff.c          **** 				dj->clust = clst;				/* Initialize data for new cluster */
 3774               	.LM346:
 3775 1468 8A86      		std Y+10,r8
 3776 146a 9B86      		std Y+11,r9
 3777 146c AC86      		std Y+12,r10
 3778 146e BD86      		std Y+13,r11
1185:ff.c          **** 				dj->sect = clust2sect(dj->fs, clst);
 3780               	.LM347:
 3781 1470 B501      		movw r22,r10
 3782 1472 A401      		movw r20,r8
 3783 1474 8881      		ld r24,Y
 3784 1476 9981      		ldd r25,Y+1
 3785 1478 0E94 0000 		call clust2sect
 3786 147c 6E87      		std Y+14,r22
 3787 147e 7F87      		std Y+15,r23
 3788 1480 888B      		std Y+16,r24
 3789 1482 998B      		std Y+17,r25
 3790               	.L191:
1190:ff.c          **** 	dj->index = i;
 3792               	.LM348:
 3793 1484 1D83      		std Y+5,r17
 3794 1486 0C83      		std Y+4,r16
1191:ff.c          **** 	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
 3796               	.LM349:
 3797 1488 A5E0      		ldi r26,5
 3798               		1:
 3799 148a EE0C      		lsl r14
 3800 148c FF1C      		rol r15
 3801 148e AA95      		dec r26
 3802 1490 01F4      		brne 1b
 3803 1492 F2E3      		ldi r31,50
 3804 1494 EF0E      		add r14,r31
 3805 1496 F11C      		adc r15,__zero_reg__
 3806 1498 8881      		ld r24,Y
 3807 149a 9981      		ldd r25,Y+1
 3808 149c 8E0D      		add r24,r14
 3809 149e 9F1D      		adc r25,r15
 3810 14a0 9B8B      		std Y+19,r25
 3811 14a2 8A8B      		std Y+18,r24
1193:ff.c          **** 	return FR_OK;
 3813               	.LM350:
 3814 14a4 80E0      		ldi r24,0
 3815 14a6 00C0      		rjmp .L188
 3816               	.L203:
 3817               	.LBB40:
1167:ff.c          **** 					if (clst == 0) return FR_DENIED;			/* No free cluster */
 3819               	.LM351:
 3820 14a8 87E0      		ldi r24,lo8(7)
 3821               	.L188:
 3822               	/* epilogue start */
 3823               	.LBE40:
1194:ff.c          **** }
 3825               	.LM352:
 3826 14aa DF91      		pop r29
 3827 14ac CF91      		pop r28
 3828 14ae 1F91      		pop r17
 3829 14b0 0F91      		pop r16
 3830 14b2 FF90      		pop r15
 3831 14b4 EF90      		pop r14
 3832 14b6 DF90      		pop r13
 3833 14b8 CF90      		pop r12
 3834 14ba BF90      		pop r11
 3835 14bc AF90      		pop r10
 3836 14be 9F90      		pop r9
 3837 14c0 8F90      		pop r8
 3838 14c2 0895      		ret
 3856               	.Lscope16:
 3858               		.stabd	78,0,0
 3859               		.section	.rodata.str1.1,"aMS",@progbits,1
 3860               	.LC0:
 3861 0000 222A 2B2C 		.string	"\"*+,:;<=>?[]|\177"
 3861      3A3B 3C3D 
 3861      3E3F 5B5D 
 3861      7C7F 00
 3862               		.text
 3867               	follow_path:
 3868               		.stabd	46,0,0
1983:ff.c          **** {
 3870               	.LM353:
 3871               	.LFBB17:
 3872 14c4 8F92      		push r8
 3873 14c6 9F92      		push r9
 3874 14c8 AF92      		push r10
 3875 14ca BF92      		push r11
 3876 14cc CF92      		push r12
 3877 14ce DF92      		push r13
 3878 14d0 EF92      		push r14
 3879 14d2 FF92      		push r15
 3880 14d4 0F93      		push r16
 3881 14d6 1F93      		push r17
 3882 14d8 CF93      		push r28
 3883 14da DF93      		push r29
 3884               	/* prologue: function */
 3885               	/* frame size = 0 */
 3886               	/* stack size = 12 */
 3887               	.L__stack_usage = 12
 3888 14dc EC01      		movw r28,r24
 3889 14de 8B01      		movw r16,r22
1995:ff.c          **** 	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
 3891               	.LM354:
 3892 14e0 DB01      		movw r26,r22
 3893 14e2 8C91      		ld r24,X
 3894 14e4 8F32      		cpi r24,lo8(47)
 3895 14e6 01F0      		breq .L217
1995:ff.c          **** 	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
 3897               	.LM355:
 3898 14e8 8C35      		cpi r24,lo8(92)
 3899 14ea 01F4      		brne .L218
 3900               	.L217:
1996:ff.c          **** 		path++;
 3902               	.LM356:
 3903 14ec 0F5F      		subi r16,-1
 3904 14ee 1F4F      		sbci r17,-1
 3905               	.L218:
1997:ff.c          **** 	dj->sclust = 0;						/* Start from the root dir */
 3907               	.LM357:
 3908 14f0 1E82      		std Y+6,__zero_reg__
 3909 14f2 1F82      		std Y+7,__zero_reg__
 3910 14f4 1886      		std Y+8,__zero_reg__
 3911 14f6 1986      		std Y+9,__zero_reg__
2000:ff.c          **** 	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
 3913               	.LM358:
 3914 14f8 F801      		movw r30,r16
 3915 14fa 8081      		ld r24,Z
 3916 14fc 8032      		cpi r24,lo8(32)
 3917 14fe 00F4      		brsh .L285
2001:ff.c          **** 		res = dir_sdi(dj, 0);
 3919               	.LM359:
 3920 1500 60E0      		ldi r22,0
 3921 1502 70E0      		ldi r23,0
 3922 1504 CE01      		movw r24,r28
 3923 1506 0E94 0000 		call dir_sdi
2002:ff.c          **** 		dj->dir = 0;
 3925               	.LM360:
 3926 150a 1B8A      		std Y+19,__zero_reg__
 3927 150c 1A8A      		std Y+18,__zero_reg__
 3928 150e 00C0      		rjmp .L268
 3929               	.L285:
 3930               	.LBB51:
 3931               	.LBB52:
 3932               	.LBB53:
 3933               	.LBB54:
 560:ff.c          **** 		*d++ = (BYTE)val;
 3935               	.LM361:
 3936 1510 80E2      		ldi r24,lo8(32)
 3937 1512 F82E      		mov r15,r24
 3938               	.LBE54:
 3939               	.LBE53:
1877:ff.c          **** 	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
 3941               	.LM362:
 3942 1514 95E0      		ldi r25,lo8(5)
 3943 1516 E92E      		mov r14,r25
 3944               	.L284:
 3945 1518 4801      		movw r8,r16
1819:ff.c          **** 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
 3947               	.LM363:
 3948 151a D801      		movw r26,r16
 3949 151c 8C91      		ld r24,X
 3950 151e 0F5F      		subi r16,-1
 3951 1520 1F4F      		sbci r17,-1
 3952 1522 8F32      		cpi r24,lo8(47)
 3953 1524 01F0      		breq .L284
 3954 1526 8C35      		cpi r24,lo8(92)
 3955 1528 01F0      		breq .L284
1820:ff.c          **** 	sfn = dj->fn;
 3957               	.LM364:
 3958 152a EC89      		ldd r30,Y+20
 3959 152c FD89      		ldd r31,Y+21
1979:ff.c          **** FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
 3961               	.LM365:
 3962 152e 9F01      		movw r18,r30
 3963 1530 255F      		subi r18,-11
 3964 1532 3F4F      		sbci r19,-1
 3965               	.LBE52:
 3966               	.LBE51:
 557:ff.c          **** 	BYTE *d = (BYTE*)dst;
 3968               	.LM366:
 3969 1534 CF01      		movw r24,r30
 3970 1536 00C0      		rjmp .L224
 3971               	.L225:
 3972               	.LBB63:
 3973               	.LBB59:
 3974               	.LBB56:
 3975               	.LBB55:
 560:ff.c          **** 		*d++ = (BYTE)val;
 3977               	.LM367:
 3978 1538 DC01      		movw r26,r24
 3979 153a FD92      		st X+,r15
 3980 153c CD01      		movw r24,r26
 3981               	.L224:
 559:ff.c          **** 	while (cnt--)
 3983               	.LM368:
 3984 153e 8217      		cp r24,r18
 3985 1540 9307      		cpc r25,r19
 3986 1542 01F4      		brne .L225
 3987 1544 80E0      		ldi r24,0
 3988 1546 90E0      		ldi r25,0
 3989 1548 40E0      		ldi r20,0
 3990 154a 50E0      		ldi r21,0
 3991 154c 28E0      		ldi r18,lo8(8)
 3992 154e 30E0      		ldi r19,0
 3993 1550 70E0      		ldi r23,0
 3994 1552 00C0      		rjmp .L226
 3995               	.L230:
 3996 1554 A801      		movw r20,r16
 3997               	.L226:
 3998               	.LBE55:
 3999               	.LBE56:
1837:ff.c          **** 		c = (BYTE)p[si++];
 4001               	.LM369:
 4002 1556 8401      		movw r16,r8
 4003 1558 040F      		add r16,r20
 4004 155a 151F      		adc r17,r21
 4005 155c D801      		movw r26,r16
 4006 155e 6C91      		ld r22,X
 4007 1560 8A01      		movw r16,r20
 4008 1562 0F5F      		subi r16,-1
 4009 1564 1F4F      		sbci r17,-1
1838:ff.c          **** 		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 4011               	.LM370:
 4012 1566 6132      		cpi r22,lo8(33)
 4013 1568 00F4      		brsh .+2
 4014 156a 00C0      		rjmp .L227
 4015 156c 6F32      		cpi r22,lo8(47)
 4016 156e 01F4      		brne .+2
 4017 1570 00C0      		rjmp .L227
 4018 1572 6C35      		cpi r22,lo8(92)
 4019 1574 01F4      		brne .+2
 4020 1576 00C0      		rjmp .L227
1839:ff.c          **** 		if (c == '.' || i >= ni) {
 4022               	.LM371:
 4023 1578 6E32      		cpi r22,lo8(46)
 4024 157a 01F4      		brne .+2
 4025 157c 00C0      		rjmp .L228
 4026 157e 8217      		cp r24,r18
 4027 1580 9307      		cpc r25,r19
 4028 1582 00F0      		brlo .+2
 4029 1584 00C0      		rjmp .L262
 4030 1586 00C0      		rjmp .L286
 4031               	.L289:
1842:ff.c          **** 			b <<= 2; continue;
 4033               	.LM372:
 4034 1588 770F      		lsl r23
 4035 158a 770F      		lsl r23
1841:ff.c          **** 			i = 8; ni = 11;
 4037               	.LM373:
 4038 158c 88E0      		ldi r24,lo8(8)
 4039 158e 90E0      		ldi r25,0
 4040 1590 2BE0      		ldi r18,lo8(11)
 4041 1592 30E0      		ldi r19,0
 4042 1594 00C0      		rjmp .L230
 4043               	.L286:
1844:ff.c          **** 		if (c >= 0x80) {				/* Extended char? */
 4045               	.LM374:
 4046 1596 67FD      		sbrc r22,7
1845:ff.c          **** 			b |= 3;						/* Eliminate NT flag */
 4048               	.LM375:
 4049 1598 7360      		ori r23,lo8(3)
 4050               	.L231:
1854:ff.c          **** 		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
 4052               	.LM376:
 4053 159a BFE7      		ldi r27,lo8(127)
 4054 159c DB2E      		mov r13,r27
 4055 159e D60E      		add r13,r22
 4056 15a0 BEE1      		ldi r27,lo8(30)
 4057 15a2 BD15      		cp r27,r13
 4058 15a4 00F4      		brsh .L232
 4059 15a6 A0E2      		ldi r26,lo8(32)
 4060 15a8 DA2E      		mov r13,r26
 4061 15aa D60E      		add r13,r22
 4062 15ac ACE1      		ldi r26,lo8(28)
 4063 15ae AD15      		cp r26,r13
 4064 15b0 00F0      		brlo .L233
 4065               	.L232:
1855:ff.c          **** 			d = (BYTE)p[si++];			/* Get 2nd byte */
 4067               	.LM377:
 4068 15b2 080D      		add r16,r8
 4069 15b4 191D      		adc r17,r9
 4070 15b6 D801      		movw r26,r16
 4071 15b8 DC90      		ld r13,X
 4072 15ba 8A01      		movw r16,r20
 4073 15bc 0E5F      		subi r16,-2
 4074 15be 1F4F      		sbci r17,-1
1856:ff.c          **** 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
 4076               	.LM378:
 4077 15c0 4D2D      		mov r20,r13
 4078 15c2 4054      		subi r20,lo8(-(-64))
 4079 15c4 4F33      		cpi r20,lo8(63)
 4080 15c6 00F0      		brlo .L234
 4081 15c8 4054      		subi r20,lo8(-(-64))
 4082 15ca 4D37      		cpi r20,lo8(125)
 4083 15cc 00F0      		brlo .+2
 4084 15ce 00C0      		rjmp .L262
 4085               	.L234:
 4086 15d0 A901      		movw r20,r18
 4087 15d2 4150      		subi r20,1
 4088 15d4 5109      		sbc r21,__zero_reg__
 4089 15d6 8417      		cp r24,r20
 4090 15d8 9507      		cpc r25,r21
 4091 15da 00F0      		brlo .+2
 4092 15dc 00C0      		rjmp .L262
1858:ff.c          **** 			sfn[i++] = c;
 4094               	.LM379:
 4095 15de AF01      		movw r20,r30
 4096 15e0 480F      		add r20,r24
 4097 15e2 591F      		adc r21,r25
 4098 15e4 DA01      		movw r26,r20
 4099 15e6 6C93      		st X,r22
1859:ff.c          **** 			sfn[i++] = d;
 4101               	.LM380:
 4102 15e8 1196      		adiw r26,1
 4103 15ea DC92      		st X,r13
 4104 15ec 0296      		adiw r24,2
 4105 15ee 00C0      		rjmp .L230
 4106               	.L233:
1861:ff.c          **** 			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
 4108               	.LM381:
 4109 15f0 A62E      		mov r10,r22
 4110 15f2 B12C      		mov r11,__zero_reg__
 4111 15f4 40E0      		ldi r20,lo8(.LC0)
 4112 15f6 50E0      		ldi r21,hi8(.LC0)
 4113               	.L236:
 4114               	.LBB57:
 4115               	.LBB58:
 576:ff.c          **** 	while (*str && *str != chr) str++;
 4117               	.LM382:
 4118 15f8 DA01      		movw r26,r20
 4119 15fa CD90      		ld r12,X+
 4120 15fc AD01      		movw r20,r26
 4121 15fe CC20      		tst r12
 4122 1600 01F4      		brne .+2
 4123 1602 00C0      		rjmp .L235
 4124 1604 D12C      		mov r13,__zero_reg__
 4125 1606 CA14      		cp r12,r10
 4126 1608 DB04      		cpc r13,r11
 4127 160a 01F4      		brne .L236
 4128 160c 00C0      		rjmp .L262
 4129               	.L248:
 4130               	.LBE58:
 4131               	.LBE57:
1864:ff.c          **** 				b |= 2;
 4133               	.LM383:
 4134 160e 7260      		ori r23,lo8(2)
 4135 1610 00C0      		rjmp .L237
 4136               	.L288:
1866:ff.c          **** 				if (IsLower(c)) {		/* ASCII small capital? */
 4138               	.LM384:
 4139 1612 462F      		mov r20,r22
 4140 1614 4156      		subi r20,lo8(-(-97))
 4141 1616 4A31      		cpi r20,lo8(26)
 4142 1618 00F4      		brsh .L237
1867:ff.c          **** 					b |= 1; c -= 0x20;
 4144               	.LM385:
 4145 161a 7160      		ori r23,lo8(1)
 4146 161c 6052      		subi r22,lo8(-(-32))
 4147               	.L237:
1870:ff.c          **** 			sfn[i++] = c;
 4149               	.LM386:
 4150 161e AF01      		movw r20,r30
 4151 1620 480F      		add r20,r24
 4152 1622 591F      		adc r21,r25
 4153 1624 DA01      		movw r26,r20
 4154 1626 6C93      		st X,r22
 4155 1628 0196      		adiw r24,1
 4156 162a 00C0      		rjmp .L230
 4157               	.L227:
1873:ff.c          **** 	*path = &p[si];						/* Return pointer to the next segment */
 4159               	.LM387:
 4160 162c 080D      		add r16,r8
 4161 162e 191D      		adc r17,r9
1874:ff.c          **** 	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 4163               	.LM388:
 4164 1630 6132      		cpi r22,lo8(33)
 4165 1632 00F4      		brsh .L257
 4166 1634 44E0      		ldi r20,lo8(4)
 4167 1636 00C0      		rjmp .L238
 4168               	.L257:
 4169 1638 40E0      		ldi r20,0
 4170               	.L238:
1876:ff.c          **** 	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
 4172               	.LM389:
 4173 163a 892B      		or r24,r25
 4174 163c 01F4      		brne .+2
 4175 163e 00C0      		rjmp .L262
1877:ff.c          **** 	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
 4177               	.LM390:
 4178 1640 8081      		ld r24,Z
 4179 1642 853E      		cpi r24,lo8(-27)
 4180 1644 01F4      		brne .L239
 4181 1646 E082      		st Z,r14
 4182               	.L239:
1879:ff.c          **** 	if (ni == 8) b <<= 2;
 4184               	.LM391:
 4185 1648 2830      		cpi r18,8
 4186 164a 3105      		cpc r19,__zero_reg__
 4187 164c 01F4      		brne .L240
 4188 164e 770F      		lsl r23
 4189 1650 770F      		lsl r23
 4190               	.L240:
 4191               	.LBE59:
1880:ff.c          **** 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
 4193               	.LM392:
 4194 1652 872F      		mov r24,r23
 4195 1654 8370      		andi r24,lo8(3)
 4196               	.LBB60:
 4197 1656 8130      		cpi r24,lo8(1)
 4198 1658 01F4      		brne .L241
 4199 165a 4061      		ori r20,lo8(16)
 4200               	.L241:
 4201               	.LBE60:
1881:ff.c          **** 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
 4203               	.LM393:
 4204 165c 872F      		mov r24,r23
 4205 165e 8C70      		andi r24,lo8(12)
 4206               	.LBB61:
 4207 1660 8430      		cpi r24,lo8(4)
 4208 1662 01F4      		brne .L242
 4209 1664 4860      		ori r20,lo8(8)
 4210               	.L242:
1883:ff.c          **** 	sfn[NS] = c;		/* Store NT flag, File name is created */
 4212               	.LM394:
 4213 1666 4387      		std Z+11,r20
 4214               	.LBE61:
 4215               	.LBE63:
 4216               	.LBB64:
 4217               	.LBB65:
1455:ff.c          **** 	res = dir_sdi(dj, 0);			/* Rewind directory object */
 4219               	.LM395:
 4220 1668 60E0      		ldi r22,0
 4221 166a 70E0      		ldi r23,0
 4222 166c CE01      		movw r24,r28
 4223 166e 0E94 0000 		call dir_sdi
 4224               	.L290:
1456:ff.c          **** 	if (res != FR_OK) return res;
 4226               	.LM396:
 4227 1672 8111      		cpse r24,__zero_reg__
 4228 1674 00C0      		rjmp .L243
1462:ff.c          **** 		res = move_window(dj->fs, dj->sect);
 4230               	.LM397:
 4231 1676 4E85      		ldd r20,Y+14
 4232 1678 5F85      		ldd r21,Y+15
 4233 167a 6889      		ldd r22,Y+16
 4234 167c 7989      		ldd r23,Y+17
 4235 167e 8881      		ld r24,Y
 4236 1680 9981      		ldd r25,Y+1
 4237 1682 0E94 0000 		call move_window
1463:ff.c          **** 		if (res != FR_OK) break;
 4239               	.LM398:
 4240 1686 8111      		cpse r24,__zero_reg__
 4241 1688 00C0      		rjmp .L243
1464:ff.c          **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
 4243               	.LM399:
 4244 168a EA89      		ldd r30,Y+18
 4245 168c FB89      		ldd r31,Y+19
1466:ff.c          **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 4247               	.LM400:
 4248 168e 9081      		ld r25,Z
 4249 1690 9923      		tst r25
 4250 1692 01F0      		breq .L259
 4251               	.LBE65:
1489:ff.c          **** 		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
 4253               	.LM401:
 4254 1694 9385      		ldd r25,Z+11
 4255               	.LBB68:
 4256 1696 93FD      		sbrc r25,3
 4257 1698 00C0      		rjmp .L244
 4258 169a AC89      		ldd r26,Y+20
 4259 169c BD89      		ldd r27,Y+21
1979:ff.c          **** FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
 4261               	.LM402:
 4262 169e 9F01      		movw r18,r30
 4263 16a0 255F      		subi r18,-11
 4264 16a2 3F4F      		sbci r19,-1
 4265               	.L245:
 4266               	.LBB66:
 4267               	.LBB67:
 569:ff.c          **** 	while (cnt-- && (r = *d++ - *s++) == 0) ;
 4269               	.LM403:
 4270 16a4 E217      		cp r30,r18
 4271 16a6 F307      		cpc r31,r19
 4272 16a8 01F0      		breq .L243
 4273 16aa 4191      		ld r20,Z+
 4274 16ac 9D91      		ld r25,X+
 4275 16ae 4917      		cp r20,r25
 4276 16b0 01F0      		breq .L245
 4277               	.L244:
 4278               	.LBE67:
 4279               	.LBE66:
1492:ff.c          **** 		res = dir_next(dj, 0);		/* Next entry */
 4281               	.LM404:
 4282 16b2 60E0      		ldi r22,0
 4283 16b4 70E0      		ldi r23,0
 4284 16b6 CE01      		movw r24,r28
 4285 16b8 0E94 0000 		call dir_next
 4286 16bc 00C0      		rjmp .L290
 4287               	.L259:
1466:ff.c          **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 4289               	.LM405:
 4290 16be 84E0      		ldi r24,lo8(4)
 4291               	.L243:
 4292               	.LBE68:
 4293               	.LBE64:
2008:ff.c          **** 			ns = *(dj->fn+NS);
 4295               	.LM406:
 4296 16c0 EC89      		ldd r30,Y+20
 4297 16c2 FD89      		ldd r31,Y+21
 4298 16c4 9385      		ldd r25,Z+11
2009:ff.c          **** 			if (res != FR_OK) {				/* Failed to find the object */
 4300               	.LM407:
 4301 16c6 8823      		tst r24
 4302 16c8 01F0      		breq .L247
2010:ff.c          **** 				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
 4304               	.LM408:
 4305 16ca 8430      		cpi r24,lo8(4)
 4306 16cc 01F4      		brne .L268
2017:ff.c          **** 					if (!(ns & NS_LAST)) res = FR_NO_PATH;
 4308               	.LM409:
 4309 16ce 92FF      		sbrs r25,2
 4310 16d0 00C0      		rjmp .L261
 4311 16d2 00C0      		rjmp .L268
 4312               	.L247:
2021:ff.c          **** 			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
 4314               	.LM410:
 4315 16d4 92FD      		sbrc r25,2
 4316 16d6 00C0      		rjmp .L268
2022:ff.c          **** 			dir = dj->dir;						/* There is next segment. Follow the sub directory */
 4318               	.LM411:
 4319 16d8 6A89      		ldd r22,Y+18
 4320 16da 7B89      		ldd r23,Y+19
2023:ff.c          **** 			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
 4322               	.LM412:
 4323 16dc FB01      		movw r30,r22
 4324 16de 8385      		ldd r24,Z+11
 4325 16e0 84FF      		sbrs r24,4
 4326 16e2 00C0      		rjmp .L261
2252:ff.c          **** 
2253:ff.c          **** 
2254:ff.c          **** 
2255:ff.c          **** 
2256:ff.c          **** /*--------------------------------------------------------------------------
2257:ff.c          **** 
2258:ff.c          ****    Public Functions
2259:ff.c          **** 
2260:ff.c          **** --------------------------------------------------------------------------*/
2261:ff.c          **** 
2262:ff.c          **** 
2263:ff.c          **** 
2264:ff.c          **** /*-----------------------------------------------------------------------*/
2265:ff.c          **** /* Mount/Unmount a Logical Drive                                         */
2266:ff.c          **** /*-----------------------------------------------------------------------*/
2267:ff.c          **** 
2268:ff.c          **** FRESULT f_mount (
2269:ff.c          **** 	BYTE vol,		/* Logical drive number to be mounted/unmounted */
2270:ff.c          **** 	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
2271:ff.c          **** )
2272:ff.c          **** {
2273:ff.c          **** 	FATFS *rfs;
2274:ff.c          **** 
2275:ff.c          **** 
2276:ff.c          **** 	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
2277:ff.c          **** 		return FR_INVALID_DRIVE;
2278:ff.c          **** 	rfs = FatFs[vol];			/* Get current fs object */
2279:ff.c          **** 
2280:ff.c          **** 	if (rfs) {
2281:ff.c          **** #if _FS_LOCK
2282:ff.c          **** 		clear_lock(rfs);
2283:ff.c          **** #endif
2284:ff.c          **** #if _FS_REENTRANT				/* Discard sync object of the current volume */
2285:ff.c          **** 		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
2286:ff.c          **** #endif
2287:ff.c          **** 		rfs->fs_type = 0;		/* Clear old fs object */
2288:ff.c          **** 	}
2289:ff.c          **** 
2290:ff.c          **** 	if (fs) {
2291:ff.c          **** 		fs->fs_type = 0;		/* Clear new fs object */
2292:ff.c          **** #if _FS_REENTRANT				/* Create sync object for the new volume */
2293:ff.c          **** 		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
2294:ff.c          **** #endif
2295:ff.c          **** 	}
2296:ff.c          **** 	FatFs[vol] = fs;			/* Register new fs object */
2297:ff.c          **** 
2298:ff.c          **** 	return FR_OK;
2299:ff.c          **** }
2300:ff.c          **** 
2301:ff.c          **** 
2302:ff.c          **** 
2303:ff.c          **** 
2304:ff.c          **** /*-----------------------------------------------------------------------*/
2305:ff.c          **** /* Open or Create a File                                                 */
2306:ff.c          **** /*-----------------------------------------------------------------------*/
2307:ff.c          **** 
2308:ff.c          **** FRESULT f_open (
2309:ff.c          **** 	FIL *fp,			/* Pointer to the blank file object */
2310:ff.c          **** 	const TCHAR *path,	/* Pointer to the file name */
2311:ff.c          **** 	BYTE mode			/* Access mode and file open mode flags */
2312:ff.c          **** )
2313:ff.c          **** {
2314:ff.c          **** 	FRESULT res;
2315:ff.c          **** 	DIR dj;
2316:ff.c          **** 	BYTE *dir;
2317:ff.c          **** 	DEF_NAMEBUF;
2318:ff.c          **** 
2319:ff.c          **** 
2320:ff.c          **** 	if (!fp) return FR_INVALID_OBJECT;
2321:ff.c          **** 	fp->fs = 0;			/* Clear file object */
2322:ff.c          **** 
2323:ff.c          **** #if !_FS_READONLY
2324:ff.c          **** 	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
2325:ff.c          **** 	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
2326:ff.c          **** #else
2327:ff.c          **** 	mode &= FA_READ;
2328:ff.c          **** 	res = chk_mounted(&path, &dj.fs, 0);
2329:ff.c          **** #endif
2330:ff.c          **** 	if (res == FR_OK) {
2331:ff.c          **** 		INIT_BUF(dj);
2332:ff.c          **** 		res = follow_path(&dj, path);	/* Follow the file path */
2333:ff.c          **** 		dir = dj.dir;
2334:ff.c          **** #if !_FS_READONLY	/* R/W configuration */
2335:ff.c          **** 		if (res == FR_OK) {
2336:ff.c          **** 			if (!dir)	/* Current dir itself */
2337:ff.c          **** 				res = FR_INVALID_NAME;
2338:ff.c          **** #if _FS_LOCK
2339:ff.c          **** 			else
2340:ff.c          **** 				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2341:ff.c          **** #endif
2342:ff.c          **** 		}
2343:ff.c          **** 		/* Create or Open a file */
2344:ff.c          **** 		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
2345:ff.c          **** 			DWORD dw, cl;
2346:ff.c          **** 
2347:ff.c          **** 			if (res != FR_OK) {					/* No file, create new */
2348:ff.c          **** 				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
2349:ff.c          **** #if _FS_LOCK
2350:ff.c          **** 					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
2351:ff.c          **** #else
2352:ff.c          **** 					res = dir_register(&dj);
2353:ff.c          **** #endif
2354:ff.c          **** 				mode |= FA_CREATE_ALWAYS;		/* File is created */
2355:ff.c          **** 				dir = dj.dir;					/* New entry */
2356:ff.c          **** 			}
2357:ff.c          **** 			else {								/* Any object is already existing */
2358:ff.c          **** 				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
2359:ff.c          **** 					res = FR_DENIED;
2360:ff.c          **** 				} else {
2361:ff.c          **** 					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
2362:ff.c          **** 						res = FR_EXIST;
2363:ff.c          **** 				}
2364:ff.c          **** 			}
2365:ff.c          **** 			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
2366:ff.c          **** 				dw = get_fattime();					/* Created time */
2367:ff.c          **** 				ST_DWORD(dir+DIR_CrtTime, dw);
2368:ff.c          **** 				dir[DIR_Attr] = 0;					/* Reset attribute */
2369:ff.c          **** 				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
2370:ff.c          **** 				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
2371:ff.c          **** 				st_clust(dir, 0);					/* cluster = 0 */
2372:ff.c          **** 				dj.fs->wflag = 1;
2373:ff.c          **** 				if (cl) {							/* Remove the cluster chain if exist */
2374:ff.c          **** 					dw = dj.fs->winsect;
2375:ff.c          **** 					res = remove_chain(dj.fs, cl);
2376:ff.c          **** 					if (res == FR_OK) {
2377:ff.c          **** 						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
2378:ff.c          **** 						res = move_window(dj.fs, dw);
2379:ff.c          **** 					}
2380:ff.c          **** 				}
2381:ff.c          **** 			}
2382:ff.c          **** 		}
2383:ff.c          **** 		else {	/* Open an existing file */
2384:ff.c          **** 			if (res == FR_OK) {						/* Follow succeeded */
2385:ff.c          **** 				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
2386:ff.c          **** 					res = FR_NO_FILE;
2387:ff.c          **** 				} else {
2388:ff.c          **** 					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
2389:ff.c          **** 						res = FR_DENIED;
2390:ff.c          **** 				}
2391:ff.c          **** 			}
2392:ff.c          **** 		}
2393:ff.c          **** 		if (res == FR_OK) {
2394:ff.c          **** 			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
2395:ff.c          **** 				mode |= FA__WRITTEN;
2396:ff.c          **** 			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
2397:ff.c          **** 			fp->dir_ptr = dir;
2398:ff.c          **** #if _FS_LOCK
2399:ff.c          **** 			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2400:ff.c          **** 			if (!fp->lockid) res = FR_INT_ERR;
2401:ff.c          **** #endif
2402:ff.c          **** 		}
2403:ff.c          **** 
2404:ff.c          **** #else				/* R/O configuration */
2405:ff.c          **** 		if (res == FR_OK) {					/* Follow succeeded */
2406:ff.c          **** 			dir = dj.dir;
2407:ff.c          **** 			if (!dir) {						/* Current dir itself */
2408:ff.c          **** 				res = FR_INVALID_NAME;
2409:ff.c          **** 			} else {
2410:ff.c          **** 				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
2411:ff.c          **** 					res = FR_NO_FILE;
2412:ff.c          **** 			}
2413:ff.c          **** 		}
2414:ff.c          **** #endif
2415:ff.c          **** 		FREE_BUF();
2416:ff.c          **** 
2417:ff.c          **** 		if (res == FR_OK) {
2418:ff.c          **** 			fp->flag = mode;					/* File access mode */
2419:ff.c          **** 			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
2420:ff.c          **** 			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
2421:ff.c          **** 			fp->fptr = 0;						/* File pointer */
2422:ff.c          **** 			fp->dsect = 0;
2423:ff.c          **** #if _USE_FASTSEEK
2424:ff.c          **** 			fp->cltbl = 0;						/* Normal seek mode */
2425:ff.c          **** #endif
2426:ff.c          **** 			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
2427:ff.c          **** 		}
2428:ff.c          **** 	}
2429:ff.c          **** 
2430:ff.c          **** 	LEAVE_FF(dj.fs, res);
2431:ff.c          **** }
2432:ff.c          **** 
2433:ff.c          **** 
2434:ff.c          **** 
2435:ff.c          **** 
2436:ff.c          **** /*-----------------------------------------------------------------------*/
2437:ff.c          **** /* Read File                                                             */
2438:ff.c          **** /*-----------------------------------------------------------------------*/
2439:ff.c          **** 
2440:ff.c          **** FRESULT f_read (
2441:ff.c          **** 	FIL *fp, 		/* Pointer to the file object */
2442:ff.c          **** 	void *buff,		/* Pointer to data buffer */
2443:ff.c          **** 	UINT btr,		/* Number of bytes to read */
2444:ff.c          **** 	UINT *br		/* Pointer to number of bytes read */
2445:ff.c          **** )
2446:ff.c          **** {
2447:ff.c          **** 	FRESULT res;
2448:ff.c          **** 	DWORD clst, sect, remain;
2449:ff.c          **** 	UINT rcnt, cc;
2450:ff.c          **** 	BYTE csect, *rbuff = (BYTE*)buff;
2451:ff.c          **** 
2452:ff.c          **** 
2453:ff.c          **** 	*br = 0;	/* Clear read byte counter */
2454:ff.c          **** 
2455:ff.c          **** 	res = validate(fp);							/* Check validity */
2456:ff.c          **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
2457:ff.c          **** 	if (fp->flag & FA__ERROR)					/* Aborted file? */
2458:ff.c          **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
2459:ff.c          **** 	if (!(fp->flag & FA_READ)) 					/* Check access mode */
2460:ff.c          **** 		LEAVE_FF(fp->fs, FR_DENIED);
2461:ff.c          **** 	remain = fp->fsize - fp->fptr;
2462:ff.c          **** 	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
2463:ff.c          **** 
2464:ff.c          **** 	for ( ;  btr;								/* Repeat until all data read */
2465:ff.c          **** 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
2466:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
2467:ff.c          **** 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
2468:ff.c          **** 			if (!csect) {						/* On the cluster boundary? */
2469:ff.c          **** 				if (fp->fptr == 0) {			/* On the top of the file? */
2470:ff.c          **** 					clst = fp->sclust;			/* Follow from the origin */
2471:ff.c          **** 				} else {						/* Middle or end of the file */
2472:ff.c          **** #if _USE_FASTSEEK
2473:ff.c          **** 					if (fp->cltbl)
2474:ff.c          **** 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
2475:ff.c          **** 					else
2476:ff.c          **** #endif
2477:ff.c          **** 						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
2478:ff.c          **** 				}
2479:ff.c          **** 				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
2480:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2481:ff.c          **** 				fp->clust = clst;				/* Update current cluster */
2482:ff.c          **** 			}
2483:ff.c          **** 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
2484:ff.c          **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
2485:ff.c          **** 			sect += csect;
2486:ff.c          **** 			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
2487:ff.c          **** 			if (cc) {							/* Read maximum contiguous sectors directly */
2488:ff.c          **** 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
2489:ff.c          **** 					cc = fp->fs->csize - csect;
2490:ff.c          **** 				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
2491:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
2492:ff.c          **** #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it 
2493:ff.c          **** #if _FS_TINY
2494:ff.c          **** 				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
2495:ff.c          **** 					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
2496:ff.c          **** #else
2497:ff.c          **** 				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
2498:ff.c          **** 					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
2499:ff.c          **** #endif
2500:ff.c          **** #endif
2501:ff.c          **** 				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
2502:ff.c          **** 				continue;
2503:ff.c          **** 			}
2504:ff.c          **** #if !_FS_TINY
2505:ff.c          **** 			if (fp->dsect != sect) {			/* Load data sector if not in cache */
2506:ff.c          **** #if !_FS_READONLY
2507:ff.c          **** 				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
2508:ff.c          **** 					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2509:ff.c          **** 						ABORT(fp->fs, FR_DISK_ERR);
2510:ff.c          **** 					fp->flag &= ~FA__DIRTY;
2511:ff.c          **** 				}
2512:ff.c          **** #endif
2513:ff.c          **** 				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
2514:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
2515:ff.c          **** 			}
2516:ff.c          **** #endif
2517:ff.c          **** 			fp->dsect = sect;
2518:ff.c          **** 		}
2519:ff.c          **** 		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer 
2520:ff.c          **** 		if (rcnt > btr) rcnt = btr;
2521:ff.c          **** #if _FS_TINY
2522:ff.c          **** 		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
2523:ff.c          **** 			ABORT(fp->fs, FR_DISK_ERR);
2524:ff.c          **** 		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
2525:ff.c          **** #else
2526:ff.c          **** 		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
2527:ff.c          **** #endif
2528:ff.c          **** 	}
2529:ff.c          **** 
2530:ff.c          **** 	LEAVE_FF(fp->fs, FR_OK);
2531:ff.c          **** }
2532:ff.c          **** 
2533:ff.c          **** 
2534:ff.c          **** 
2535:ff.c          **** 
2536:ff.c          **** #if !_FS_READONLY
2537:ff.c          **** /*-----------------------------------------------------------------------*/
2538:ff.c          **** /* Write File                                                            */
2539:ff.c          **** /*-----------------------------------------------------------------------*/
2540:ff.c          **** 
2541:ff.c          **** FRESULT f_write (
2542:ff.c          **** 	FIL *fp,			/* Pointer to the file object */
2543:ff.c          **** 	const void *buff,	/* Pointer to the data to be written */
2544:ff.c          **** 	UINT btw,			/* Number of bytes to write */
2545:ff.c          **** 	UINT *bw			/* Pointer to number of bytes written */
2546:ff.c          **** )
2547:ff.c          **** {
2548:ff.c          **** 	FRESULT res;
2549:ff.c          **** 	DWORD clst, sect;
2550:ff.c          **** 	UINT wcnt, cc;
2551:ff.c          **** 	const BYTE *wbuff = (const BYTE*)buff;
2552:ff.c          **** 	BYTE csect;
2553:ff.c          **** 
2554:ff.c          **** 
2555:ff.c          **** 	*bw = 0;	/* Clear write byte counter */
2556:ff.c          **** 
2557:ff.c          **** 	res = validate(fp);						/* Check validity */
2558:ff.c          **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
2559:ff.c          **** 	if (fp->flag & FA__ERROR)				/* Aborted file? */
2560:ff.c          **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
2561:ff.c          **** 	if (!(fp->flag & FA_WRITE))				/* Check access mode */
2562:ff.c          **** 		LEAVE_FF(fp->fs, FR_DENIED);
2563:ff.c          **** 	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
2564:ff.c          **** 
2565:ff.c          **** 	for ( ;  btw;							/* Repeat until all data written */
2566:ff.c          **** 		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
2567:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
2568:ff.c          **** 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
2569:ff.c          **** 			if (!csect) {					/* On the cluster boundary? */
2570:ff.c          **** 				if (fp->fptr == 0) {		/* On the top of the file? */
2571:ff.c          **** 					clst = fp->sclust;		/* Follow from the origin */
2572:ff.c          **** 					if (clst == 0)			/* When no cluster is allocated, */
2573:ff.c          **** 						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
2574:ff.c          **** 				} else {					/* Middle or end of the file */
2575:ff.c          **** #if _USE_FASTSEEK
2576:ff.c          **** 					if (fp->cltbl)
2577:ff.c          **** 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
2578:ff.c          **** 					else
2579:ff.c          **** #endif
2580:ff.c          **** 						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
2581:ff.c          **** 				}
2582:ff.c          **** 				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
2583:ff.c          **** 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
2584:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2585:ff.c          **** 				fp->clust = clst;			/* Update current cluster */
2586:ff.c          **** 			}
2587:ff.c          **** #if _FS_TINY
2588:ff.c          **** 			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
2589:ff.c          **** 				ABORT(fp->fs, FR_DISK_ERR);
2590:ff.c          **** #else
2591:ff.c          **** 			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
2592:ff.c          **** 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2593:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
2594:ff.c          **** 				fp->flag &= ~FA__DIRTY;
2595:ff.c          **** 			}
2596:ff.c          **** #endif
2597:ff.c          **** 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
2598:ff.c          **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
2599:ff.c          **** 			sect += csect;
2600:ff.c          **** 			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
2601:ff.c          **** 			if (cc) {						/* Write maximum contiguous sectors directly */
2602:ff.c          **** 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
2603:ff.c          **** 					cc = fp->fs->csize - csect;
2604:ff.c          **** 				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
2605:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
2606:ff.c          **** #if _FS_TINY
2607:ff.c          **** 				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct 
2608:ff.c          **** 					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
2609:ff.c          **** 					fp->fs->wflag = 0;
2610:ff.c          **** 				}
2611:ff.c          **** #else
2612:ff.c          **** 				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write 
2613:ff.c          **** 					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
2614:ff.c          **** 					fp->flag &= ~FA__DIRTY;
2615:ff.c          **** 				}
2616:ff.c          **** #endif
2617:ff.c          **** 				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
2618:ff.c          **** 				continue;
2619:ff.c          **** 			}
2620:ff.c          **** #if _FS_TINY
2621:ff.c          **** 			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
2622:ff.c          **** 				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
2623:ff.c          **** 				fp->fs->winsect = sect;
2624:ff.c          **** 			}
2625:ff.c          **** #else
2626:ff.c          **** 			if (fp->dsect != sect) {		/* Fill sector cache with file data */
2627:ff.c          **** 				if (fp->fptr < fp->fsize &&
2628:ff.c          **** 					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
2629:ff.c          **** 						ABORT(fp->fs, FR_DISK_ERR);
2630:ff.c          **** 			}
2631:ff.c          **** #endif
2632:ff.c          **** 			fp->dsect = sect;
2633:ff.c          **** 		}
2634:ff.c          **** 		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
2635:ff.c          **** 		if (wcnt > btw) wcnt = btw;
2636:ff.c          **** #if _FS_TINY
2637:ff.c          **** 		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
2638:ff.c          **** 			ABORT(fp->fs, FR_DISK_ERR);
2639:ff.c          **** 		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
2640:ff.c          **** 		fp->fs->wflag = 1;
2641:ff.c          **** #else
2642:ff.c          **** 		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
2643:ff.c          **** 		fp->flag |= FA__DIRTY;
2644:ff.c          **** #endif
2645:ff.c          **** 	}
2646:ff.c          **** 
2647:ff.c          **** 	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
2648:ff.c          **** 	fp->flag |= FA__WRITTEN;						/* Set file change flag */
2649:ff.c          **** 
2650:ff.c          **** 	LEAVE_FF(fp->fs, FR_OK);
2651:ff.c          **** }
2652:ff.c          **** 
2653:ff.c          **** 
2654:ff.c          **** 
2655:ff.c          **** 
2656:ff.c          **** /*-----------------------------------------------------------------------*/
2657:ff.c          **** /* Synchronize the File Object                                           */
2658:ff.c          **** /*-----------------------------------------------------------------------*/
2659:ff.c          **** 
2660:ff.c          **** FRESULT f_sync (
2661:ff.c          **** 	FIL *fp		/* Pointer to the file object */
2662:ff.c          **** )
2663:ff.c          **** {
2664:ff.c          **** 	FRESULT res;
2665:ff.c          **** 	DWORD tm;
2666:ff.c          **** 	BYTE *dir;
2667:ff.c          **** 
2668:ff.c          **** 
2669:ff.c          **** 	res = validate(fp);					/* Check validity of the object */
2670:ff.c          **** 	if (res == FR_OK) {
2671:ff.c          **** 		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
2672:ff.c          **** #if !_FS_TINY	/* Write-back dirty buffer */
2673:ff.c          **** 			if (fp->flag & FA__DIRTY) {
2674:ff.c          **** 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2675:ff.c          **** 					LEAVE_FF(fp->fs, FR_DISK_ERR);
2676:ff.c          **** 				fp->flag &= ~FA__DIRTY;
2677:ff.c          **** 			}
2678:ff.c          **** #endif
2679:ff.c          **** 			/* Update the directory entry */
2680:ff.c          **** 			res = move_window(fp->fs, fp->dir_sect);
2681:ff.c          **** 			if (res == FR_OK) {
2682:ff.c          **** 				dir = fp->dir_ptr;
2683:ff.c          **** 				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
2684:ff.c          **** 				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
2685:ff.c          **** 				st_clust(dir, fp->sclust);					/* Update start cluster */
2686:ff.c          **** 				tm = get_fattime();							/* Update updated time */
2687:ff.c          **** 				ST_DWORD(dir+DIR_WrtTime, tm);
2688:ff.c          **** 				ST_WORD(dir+DIR_LstAccDate, 0);
2689:ff.c          **** 				fp->flag &= ~FA__WRITTEN;
2690:ff.c          **** 				fp->fs->wflag = 1;
2691:ff.c          **** 				res = sync_fs(fp->fs);
2692:ff.c          **** 			}
2693:ff.c          **** 		}
2694:ff.c          **** 	}
2695:ff.c          **** 
2696:ff.c          **** 	LEAVE_FF(fp->fs, res);
2697:ff.c          **** }
2698:ff.c          **** 
2699:ff.c          **** #endif /* !_FS_READONLY */
2700:ff.c          **** 
2701:ff.c          **** 
2702:ff.c          **** 
2703:ff.c          **** 
2704:ff.c          **** /*-----------------------------------------------------------------------*/
2705:ff.c          **** /* Close File                                                            */
2706:ff.c          **** /*-----------------------------------------------------------------------*/
2707:ff.c          **** 
2708:ff.c          **** FRESULT f_close (
2709:ff.c          **** 	FIL *fp		/* Pointer to the file object to be closed */
2710:ff.c          **** )
2711:ff.c          **** {
2712:ff.c          **** 	FRESULT res;
2713:ff.c          **** 
2714:ff.c          **** 
2715:ff.c          **** #if _FS_READONLY
2716:ff.c          **** 	res = validate(fp);
2717:ff.c          **** 	{
2718:ff.c          **** #if _FS_REENTRANT
2719:ff.c          **** 		FATFS *fs = fp->fs;
2720:ff.c          **** #endif
2721:ff.c          **** 		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
2722:ff.c          **** 		LEAVE_FF(fs, res);
2723:ff.c          **** 	}
2724:ff.c          **** #else
2725:ff.c          **** 	res = f_sync(fp);		/* Flush cached data */
2726:ff.c          **** #if _FS_LOCK
2727:ff.c          **** 	if (res == FR_OK) {		/* Decrement open counter */
2728:ff.c          **** #if _FS_REENTRANT
2729:ff.c          **** 		FATFS *fs = fp->fs;;
2730:ff.c          **** 		res = validate(fp);
2731:ff.c          **** 		if (res == FR_OK) {
2732:ff.c          **** 			res = dec_lock(fp->lockid);	
2733:ff.c          **** 			unlock_fs(fs, FR_OK);
2734:ff.c          **** 		}
2735:ff.c          **** #else
2736:ff.c          **** 		res = dec_lock(fp->lockid);
2737:ff.c          **** #endif
2738:ff.c          **** 	}
2739:ff.c          **** #endif
2740:ff.c          **** 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
2741:ff.c          **** 	return res;
2742:ff.c          **** #endif
2743:ff.c          **** }
2744:ff.c          **** 
2745:ff.c          **** 
2746:ff.c          **** 
2747:ff.c          **** 
2748:ff.c          **** /*-----------------------------------------------------------------------*/
2749:ff.c          **** /* Current Drive/Directory Handlings                                     */
2750:ff.c          **** /*-----------------------------------------------------------------------*/
2751:ff.c          **** 
2752:ff.c          **** #if _FS_RPATH >= 1
2753:ff.c          **** 
2754:ff.c          **** FRESULT f_chdrive (
2755:ff.c          **** 	BYTE drv		/* Drive number */
2756:ff.c          **** )
2757:ff.c          **** {
2758:ff.c          **** 	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
2759:ff.c          **** 
2760:ff.c          **** 	CurrVol = drv;
2761:ff.c          **** 
2762:ff.c          **** 	return FR_OK;
2763:ff.c          **** }
2764:ff.c          **** 
2765:ff.c          **** 
2766:ff.c          **** 
2767:ff.c          **** FRESULT f_chdir (
2768:ff.c          **** 	const TCHAR *path	/* Pointer to the directory path */
2769:ff.c          **** )
2770:ff.c          **** {
2771:ff.c          **** 	FRESULT res;
2772:ff.c          **** 	DIR dj;
2773:ff.c          **** 	DEF_NAMEBUF;
2774:ff.c          **** 
2775:ff.c          **** 
2776:ff.c          **** 	res = chk_mounted(&path, &dj.fs, 0);
2777:ff.c          **** 	if (res == FR_OK) {
2778:ff.c          **** 		INIT_BUF(dj);
2779:ff.c          **** 		res = follow_path(&dj, path);		/* Follow the path */
2780:ff.c          **** 		FREE_BUF();
2781:ff.c          **** 		if (res == FR_OK) {					/* Follow completed */
2782:ff.c          **** 			if (!dj.dir) {
2783:ff.c          **** 				dj.fs->cdir = dj.sclust;	/* Start directory itself */
2784:ff.c          **** 			} else {
2785:ff.c          **** 				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
2786:ff.c          **** 					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
2787:ff.c          **** 				else
2788:ff.c          **** 					res = FR_NO_PATH;		/* Reached but a file */
2789:ff.c          **** 			}
2790:ff.c          **** 		}
2791:ff.c          **** 		if (res == FR_NO_FILE) res = FR_NO_PATH;
2792:ff.c          **** 	}
2793:ff.c          **** 
2794:ff.c          **** 	LEAVE_FF(dj.fs, res);
2795:ff.c          **** }
2796:ff.c          **** 
2797:ff.c          **** 
2798:ff.c          **** #if _FS_RPATH >= 2
2799:ff.c          **** FRESULT f_getcwd (
2800:ff.c          **** 	TCHAR *buff,	/* Pointer to the directory path */
2801:ff.c          **** 	UINT len		/* Size of path */
2802:ff.c          **** )
2803:ff.c          **** {
2804:ff.c          **** 	FRESULT res;
2805:ff.c          **** 	DIR dj;
2806:ff.c          **** 	UINT i, n;
2807:ff.c          **** 	DWORD ccl;
2808:ff.c          **** 	TCHAR *tp;
2809:ff.c          **** 	FILINFO fno;
2810:ff.c          **** 	DEF_NAMEBUF;
2811:ff.c          **** 
2812:ff.c          **** 
2813:ff.c          **** 	*buff = 0;
2814:ff.c          **** 	res = chk_mounted((const TCHAR**)&buff, &dj.fs, 0);	/* Get current volume */
2815:ff.c          **** 	if (res == FR_OK) {
2816:ff.c          **** 		INIT_BUF(dj);
2817:ff.c          **** 		i = len;			/* Bottom of buffer (dir stack base) */
2818:ff.c          **** 		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
2819:ff.c          **** 		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
2820:ff.c          **** 			res = dir_sdi(&dj, 1);			/* Get parent dir */
2821:ff.c          **** 			if (res != FR_OK) break;
2822:ff.c          **** 			res = dir_read(&dj, 0);
2823:ff.c          **** 			if (res != FR_OK) break;
2824:ff.c          **** 			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent dir */
2825:ff.c          **** 			res = dir_sdi(&dj, 0);
2826:ff.c          **** 			if (res != FR_OK) break;
2827:ff.c          **** 			do {							/* Find the entry links to the child dir */
2828:ff.c          **** 				res = dir_read(&dj, 0);
2829:ff.c          **** 				if (res != FR_OK) break;
2830:ff.c          **** 				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
2831:ff.c          **** 				res = dir_next(&dj, 0);	
2832:ff.c          **** 			} while (res == FR_OK);
2833:ff.c          **** 			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
2834:ff.c          **** 			if (res != FR_OK) break;
2835:ff.c          **** #if _USE_LFN
2836:ff.c          **** 			fno.lfname = buff;
2837:ff.c          **** 			fno.lfsize = i;
2838:ff.c          **** #endif
2839:ff.c          **** 			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
2840:ff.c          **** 			tp = fno.fname;
2841:ff.c          **** 			if (_USE_LFN && *buff) tp = buff;
2842:ff.c          **** 			for (n = 0; tp[n]; n++) ;
2843:ff.c          **** 			if (i < n + 3) {
2844:ff.c          **** 				res = FR_NOT_ENOUGH_CORE; break;
2845:ff.c          **** 			}
2846:ff.c          **** 			while (n) buff[--i] = tp[--n];
2847:ff.c          **** 			buff[--i] = '/';
2848:ff.c          **** 		}
2849:ff.c          **** 		tp = buff;
2850:ff.c          **** 		if (res == FR_OK) {
2851:ff.c          **** 			*tp++ = '0' + CurrVol;			/* Put drive number */
2852:ff.c          **** 			*tp++ = ':';
2853:ff.c          **** 			if (i == len) {					/* Root-dir */
2854:ff.c          **** 				*tp++ = '/';
2855:ff.c          **** 			} else {						/* Sub-dir */
2856:ff.c          **** 				do		/* Add stacked path str */
2857:ff.c          **** 					*tp++ = buff[i++];
2858:ff.c          **** 				while (i < len);
2859:ff.c          **** 			}
2860:ff.c          **** 		}
2861:ff.c          **** 		*tp = 0;
2862:ff.c          **** 		FREE_BUF();
2863:ff.c          **** 	}
2864:ff.c          **** 
2865:ff.c          **** 	LEAVE_FF(dj.fs, res);
2866:ff.c          **** }
2867:ff.c          **** #endif /* _FS_RPATH >= 2 */
2868:ff.c          **** #endif /* _FS_RPATH >= 1 */
2869:ff.c          **** 
2870:ff.c          **** 
2871:ff.c          **** 
2872:ff.c          **** #if _FS_MINIMIZE <= 2
2873:ff.c          **** /*-----------------------------------------------------------------------*/
2874:ff.c          **** /* Seek File R/W Pointer                                                 */
2875:ff.c          **** /*-----------------------------------------------------------------------*/
2876:ff.c          **** 
2877:ff.c          **** FRESULT f_lseek (
2878:ff.c          **** 	FIL *fp,		/* Pointer to the file object */
2879:ff.c          **** 	DWORD ofs		/* File pointer from top of file */
2880:ff.c          **** )
2881:ff.c          **** {
2882:ff.c          **** 	FRESULT res;
2883:ff.c          **** 
2884:ff.c          **** 
2885:ff.c          **** 	res = validate(fp);					/* Check validity of the object */
2886:ff.c          **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
2887:ff.c          **** 	if (fp->flag & FA__ERROR)			/* Check abort flag */
2888:ff.c          **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
2889:ff.c          **** 
2890:ff.c          **** #if _USE_FASTSEEK
2891:ff.c          **** 	if (fp->cltbl) {	/* Fast seek */
2892:ff.c          **** 		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
2893:ff.c          **** 
2894:ff.c          **** 		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
2895:ff.c          **** 			tbl = fp->cltbl;
2896:ff.c          **** 			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
2897:ff.c          **** 			cl = fp->sclust;			/* Top of the chain */
2898:ff.c          **** 			if (cl) {
2899:ff.c          **** 				do {
2900:ff.c          **** 					/* Get a fragment */
2901:ff.c          **** 					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
2902:ff.c          **** 					do {
2903:ff.c          **** 						pcl = cl; ncl++;
2904:ff.c          **** 						cl = get_fat(fp->fs, cl);
2905:ff.c          **** 						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
2906:ff.c          **** 						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2907:ff.c          **** 					} while (cl == pcl + 1);
2908:ff.c          **** 					if (ulen <= tlen) {		/* Store the length and top of the fragment */
2909:ff.c          **** 						*tbl++ = ncl; *tbl++ = tcl;
2910:ff.c          **** 					}
2911:ff.c          **** 				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
2912:ff.c          **** 			}
2913:ff.c          **** 			*fp->cltbl = ulen;	/* Number of items used */
2914:ff.c          **** 			if (ulen <= tlen)
2915:ff.c          **** 				*tbl = 0;		/* Terminate table */
2916:ff.c          **** 			else
2917:ff.c          **** 				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
2918:ff.c          **** 
2919:ff.c          **** 		} else {						/* Fast seek */
2920:ff.c          **** 			if (ofs > fp->fsize)		/* Clip offset at the file size */
2921:ff.c          **** 				ofs = fp->fsize;
2922:ff.c          **** 			fp->fptr = ofs;				/* Set file pointer */
2923:ff.c          **** 			if (ofs) {
2924:ff.c          **** 				fp->clust = clmt_clust(fp, ofs - 1);
2925:ff.c          **** 				dsc = clust2sect(fp->fs, fp->clust);
2926:ff.c          **** 				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
2927:ff.c          **** 				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
2928:ff.c          **** 				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
2929:ff.c          **** #if !_FS_TINY
2930:ff.c          **** #if !_FS_READONLY
2931:ff.c          **** 					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
2932:ff.c          **** 						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2933:ff.c          **** 							ABORT(fp->fs, FR_DISK_ERR);
2934:ff.c          **** 						fp->flag &= ~FA__DIRTY;
2935:ff.c          **** 					}
2936:ff.c          **** #endif
2937:ff.c          **** 					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
2938:ff.c          **** 						ABORT(fp->fs, FR_DISK_ERR);
2939:ff.c          **** #endif
2940:ff.c          **** 					fp->dsect = dsc;
2941:ff.c          **** 				}
2942:ff.c          **** 			}
2943:ff.c          **** 		}
2944:ff.c          **** 	} else
2945:ff.c          **** #endif
2946:ff.c          **** 
2947:ff.c          **** 	/* Normal Seek */
2948:ff.c          **** 	{
2949:ff.c          **** 		DWORD clst, bcs, nsect, ifptr;
2950:ff.c          **** 
2951:ff.c          **** 		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
2952:ff.c          **** #if !_FS_READONLY
2953:ff.c          **** 			 && !(fp->flag & FA_WRITE)
2954:ff.c          **** #endif
2955:ff.c          **** 			) ofs = fp->fsize;
2956:ff.c          **** 
2957:ff.c          **** 		ifptr = fp->fptr;
2958:ff.c          **** 		fp->fptr = nsect = 0;
2959:ff.c          **** 		if (ofs) {
2960:ff.c          **** 			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
2961:ff.c          **** 			if (ifptr > 0 &&
2962:ff.c          **** 				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
2963:ff.c          **** 				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
2964:ff.c          **** 				ofs -= fp->fptr;
2965:ff.c          **** 				clst = fp->clust;
2966:ff.c          **** 			} else {									/* When seek to back cluster, */
2967:ff.c          **** 				clst = fp->sclust;						/* start from the first cluster */
2968:ff.c          **** #if !_FS_READONLY
2969:ff.c          **** 				if (clst == 0) {						/* If no cluster chain, create a new chain */
2970:ff.c          **** 					clst = create_chain(fp->fs, 0);
2971:ff.c          **** 					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
2972:ff.c          **** 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2973:ff.c          **** 					fp->sclust = clst;
2974:ff.c          **** 				}
2975:ff.c          **** #endif
2976:ff.c          **** 				fp->clust = clst;
2977:ff.c          **** 			}
2978:ff.c          **** 			if (clst != 0) {
2979:ff.c          **** 				while (ofs > bcs) {						/* Cluster following loop */
2980:ff.c          **** #if !_FS_READONLY
2981:ff.c          **** 					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
2982:ff.c          **** 						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
2983:ff.c          **** 						if (clst == 0) {				/* When disk gets full, clip file size */
2984:ff.c          **** 							ofs = bcs; break;
2985:ff.c          **** 						}
2986:ff.c          **** 					} else
2987:ff.c          **** #endif
2988:ff.c          **** 						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
2989:ff.c          **** 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2990:ff.c          **** 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
2991:ff.c          **** 					fp->clust = clst;
2992:ff.c          **** 					fp->fptr += bcs;
2993:ff.c          **** 					ofs -= bcs;
2994:ff.c          **** 				}
2995:ff.c          **** 				fp->fptr += ofs;
2996:ff.c          **** 				if (ofs % SS(fp->fs)) {
2997:ff.c          **** 					nsect = clust2sect(fp->fs, clst);	/* Current sector */
2998:ff.c          **** 					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
2999:ff.c          **** 					nsect += ofs / SS(fp->fs);
3000:ff.c          **** 				}
3001:ff.c          **** 			}
3002:ff.c          **** 		}
3003:ff.c          **** 		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
3004:ff.c          **** #if !_FS_TINY
3005:ff.c          **** #if !_FS_READONLY
3006:ff.c          **** 			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
3007:ff.c          **** 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
3008:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
3009:ff.c          **** 				fp->flag &= ~FA__DIRTY;
3010:ff.c          **** 			}
3011:ff.c          **** #endif
3012:ff.c          **** 			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
3013:ff.c          **** 				ABORT(fp->fs, FR_DISK_ERR);
3014:ff.c          **** #endif
3015:ff.c          **** 			fp->dsect = nsect;
3016:ff.c          **** 		}
3017:ff.c          **** #if !_FS_READONLY
3018:ff.c          **** 		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
3019:ff.c          **** 			fp->fsize = fp->fptr;
3020:ff.c          **** 			fp->flag |= FA__WRITTEN;
3021:ff.c          **** 		}
3022:ff.c          **** #endif
3023:ff.c          **** 	}
3024:ff.c          **** 
3025:ff.c          **** 	LEAVE_FF(fp->fs, res);
3026:ff.c          **** }
3027:ff.c          **** 
3028:ff.c          **** 
3029:ff.c          **** 
3030:ff.c          **** #if _FS_MINIMIZE <= 1
3031:ff.c          **** /*-----------------------------------------------------------------------*/
3032:ff.c          **** /* Create a Directory Object                                             */
3033:ff.c          **** /*-----------------------------------------------------------------------*/
3034:ff.c          **** 
3035:ff.c          **** FRESULT f_opendir (
3036:ff.c          **** 	DIR *dj,			/* Pointer to directory object to create */
3037:ff.c          **** 	const TCHAR *path	/* Pointer to the directory path */
3038:ff.c          **** )
3039:ff.c          **** {
3040:ff.c          **** 	FRESULT res;
3041:ff.c          **** 	FATFS *fs;
3042:ff.c          **** 	DEF_NAMEBUF;
3043:ff.c          **** 
3044:ff.c          **** 
3045:ff.c          **** 	if (!dj) return FR_INVALID_OBJECT;
3046:ff.c          **** 
3047:ff.c          **** 	res = chk_mounted(&path, &dj->fs, 0);
3048:ff.c          **** 	fs = dj->fs;
3049:ff.c          **** 	if (res == FR_OK) {
3050:ff.c          **** 		INIT_BUF(*dj);
3051:ff.c          **** 		res = follow_path(dj, path);			/* Follow the path to the directory */
3052:ff.c          **** 		FREE_BUF();
3053:ff.c          **** 		if (res == FR_OK) {						/* Follow completed */
3054:ff.c          **** 			if (dj->dir) {						/* It is not the root dir */
3055:ff.c          **** 				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
3056:ff.c          **** 					dj->sclust = ld_clust(fs, dj->dir);
3057:ff.c          **** 				} else {						/* The object is not a directory */
3058:ff.c          **** 					res = FR_NO_PATH;
3059:ff.c          **** 				}
3060:ff.c          **** 			}
3061:ff.c          **** 			if (res == FR_OK) {
3062:ff.c          **** 				dj->id = fs->id;
3063:ff.c          **** 				res = dir_sdi(dj, 0);			/* Rewind dir */
3064:ff.c          **** 			}
3065:ff.c          **** 		}
3066:ff.c          **** 		if (res == FR_NO_FILE) res = FR_NO_PATH;
3067:ff.c          **** 		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
3068:ff.c          **** 	} else {
3069:ff.c          **** 		dj->fs = 0;
3070:ff.c          **** 	}
3071:ff.c          **** 
3072:ff.c          **** 	LEAVE_FF(fs, res);
3073:ff.c          **** }
3074:ff.c          **** 
3075:ff.c          **** 
3076:ff.c          **** 
3077:ff.c          **** 
3078:ff.c          **** /*-----------------------------------------------------------------------*/
3079:ff.c          **** /* Read Directory Entry in Sequence                                      */
3080:ff.c          **** /*-----------------------------------------------------------------------*/
3081:ff.c          **** 
3082:ff.c          **** FRESULT f_readdir (
3083:ff.c          **** 	DIR *dj,			/* Pointer to the open directory object */
3084:ff.c          **** 	FILINFO *fno		/* Pointer to file information to return */
3085:ff.c          **** )
3086:ff.c          **** {
3087:ff.c          **** 	FRESULT res;
3088:ff.c          **** 	DEF_NAMEBUF;
3089:ff.c          **** 
3090:ff.c          **** 
3091:ff.c          **** 	res = validate(dj);						/* Check validity of the object */
3092:ff.c          **** 	if (res == FR_OK) {
3093:ff.c          **** 		if (!fno) {
3094:ff.c          **** 			res = dir_sdi(dj, 0);			/* Rewind the directory object */
3095:ff.c          **** 		} else {
3096:ff.c          **** 			INIT_BUF(*dj);
3097:ff.c          **** 			res = dir_read(dj, 0);			/* Read an item */
3098:ff.c          **** 			if (res == FR_NO_FILE) {		/* Reached end of dir */
3099:ff.c          **** 				dj->sect = 0;
3100:ff.c          **** 				res = FR_OK;
3101:ff.c          **** 			}
3102:ff.c          **** 			if (res == FR_OK) {				/* A valid entry is found */
3103:ff.c          **** 				get_fileinfo(dj, fno);		/* Get the object information */
3104:ff.c          **** 				res = dir_next(dj, 0);		/* Increment index for next */
3105:ff.c          **** 				if (res == FR_NO_FILE) {
3106:ff.c          **** 					dj->sect = 0;
3107:ff.c          **** 					res = FR_OK;
3108:ff.c          **** 				}
3109:ff.c          **** 			}
3110:ff.c          **** 			FREE_BUF();
3111:ff.c          **** 		}
3112:ff.c          **** 	}
3113:ff.c          **** 
3114:ff.c          **** 	LEAVE_FF(dj->fs, res);
3115:ff.c          **** }
3116:ff.c          **** 
3117:ff.c          **** 
3118:ff.c          **** 
3119:ff.c          **** #if _FS_MINIMIZE == 0
3120:ff.c          **** /*-----------------------------------------------------------------------*/
3121:ff.c          **** /* Get File Status                                                       */
3122:ff.c          **** /*-----------------------------------------------------------------------*/
3123:ff.c          **** 
3124:ff.c          **** FRESULT f_stat (
3125:ff.c          **** 	const TCHAR *path,	/* Pointer to the file path */
3126:ff.c          **** 	FILINFO *fno		/* Pointer to file information to return */
3127:ff.c          **** )
3128:ff.c          **** {
3129:ff.c          **** 	FRESULT res;
3130:ff.c          **** 	DIR dj;
3131:ff.c          **** 	DEF_NAMEBUF;
3132:ff.c          **** 
3133:ff.c          **** 
3134:ff.c          **** 	res = chk_mounted(&path, &dj.fs, 0);
3135:ff.c          **** 	if (res == FR_OK) {
3136:ff.c          **** 		INIT_BUF(dj);
3137:ff.c          **** 		res = follow_path(&dj, path);	/* Follow the file path */
3138:ff.c          **** 		if (res == FR_OK) {				/* Follow completed */
3139:ff.c          **** 			if (dj.dir)		/* Found an object */
3140:ff.c          **** 				get_fileinfo(&dj, fno);
3141:ff.c          **** 			else			/* It is root dir */
3142:ff.c          **** 				res = FR_INVALID_NAME;
3143:ff.c          **** 		}
3144:ff.c          **** 		FREE_BUF();
3145:ff.c          **** 	}
3146:ff.c          **** 
3147:ff.c          **** 	LEAVE_FF(dj.fs, res);
3148:ff.c          **** }
3149:ff.c          **** 
3150:ff.c          **** 
3151:ff.c          **** 
3152:ff.c          **** #if !_FS_READONLY
3153:ff.c          **** /*-----------------------------------------------------------------------*/
3154:ff.c          **** /* Get Number of Free Clusters                                           */
3155:ff.c          **** /*-----------------------------------------------------------------------*/
3156:ff.c          **** 
3157:ff.c          **** FRESULT f_getfree (
3158:ff.c          **** 	const TCHAR *path,	/* Path name of the logical drive number */
3159:ff.c          **** 	DWORD *nclst,		/* Pointer to a variable to return number of free clusters */
3160:ff.c          **** 	FATFS **fatfs		/* Pointer to return pointer to corresponding file system object */
3161:ff.c          **** )
3162:ff.c          **** {
3163:ff.c          **** 	FRESULT res;
3164:ff.c          **** 	FATFS *fs;
3165:ff.c          **** 	DWORD n, clst, sect, stat;
3166:ff.c          **** 	UINT i;
3167:ff.c          **** 	BYTE fat, *p;
3168:ff.c          **** 
3169:ff.c          **** 
3170:ff.c          **** 	/* Get drive number */
3171:ff.c          **** 	res = chk_mounted(&path, fatfs, 0);
3172:ff.c          **** 	fs = *fatfs;
3173:ff.c          **** 	if (res == FR_OK) {
3174:ff.c          **** 		/* If free_clust is valid, return it without full cluster scan */
3175:ff.c          **** 		if (fs->free_clust <= fs->n_fatent - 2) {
3176:ff.c          **** 			*nclst = fs->free_clust;
3177:ff.c          **** 		} else {
3178:ff.c          **** 			/* Get number of free clusters */
3179:ff.c          **** 			fat = fs->fs_type;
3180:ff.c          **** 			n = 0;
3181:ff.c          **** 			if (fat == FS_FAT12) {
3182:ff.c          **** 				clst = 2;
3183:ff.c          **** 				do {
3184:ff.c          **** 					stat = get_fat(fs, clst);
3185:ff.c          **** 					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
3186:ff.c          **** 					if (stat == 1) { res = FR_INT_ERR; break; }
3187:ff.c          **** 					if (stat == 0) n++;
3188:ff.c          **** 				} while (++clst < fs->n_fatent);
3189:ff.c          **** 			} else {
3190:ff.c          **** 				clst = fs->n_fatent;
3191:ff.c          **** 				sect = fs->fatbase;
3192:ff.c          **** 				i = 0; p = 0;
3193:ff.c          **** 				do {
3194:ff.c          **** 					if (!i) {
3195:ff.c          **** 						res = move_window(fs, sect++);
3196:ff.c          **** 						if (res != FR_OK) break;
3197:ff.c          **** 						p = fs->win;
3198:ff.c          **** 						i = SS(fs);
3199:ff.c          **** 					}
3200:ff.c          **** 					if (fat == FS_FAT16) {
3201:ff.c          **** 						if (LD_WORD(p) == 0) n++;
3202:ff.c          **** 						p += 2; i -= 2;
3203:ff.c          **** 					} else {
3204:ff.c          **** 						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
3205:ff.c          **** 						p += 4; i -= 4;
3206:ff.c          **** 					}
3207:ff.c          **** 				} while (--clst);
3208:ff.c          **** 			}
3209:ff.c          **** 			fs->free_clust = n;
3210:ff.c          **** 			if (fat == FS_FAT32) fs->fsi_flag = 1;
3211:ff.c          **** 			*nclst = n;
3212:ff.c          **** 		}
3213:ff.c          **** 	}
3214:ff.c          **** 	LEAVE_FF(fs, res);
3215:ff.c          **** }
3216:ff.c          **** 
3217:ff.c          **** 
3218:ff.c          **** 
3219:ff.c          **** 
3220:ff.c          **** /*-----------------------------------------------------------------------*/
3221:ff.c          **** /* Truncate File                                                         */
3222:ff.c          **** /*-----------------------------------------------------------------------*/
3223:ff.c          **** 
3224:ff.c          **** FRESULT f_truncate (
3225:ff.c          **** 	FIL *fp		/* Pointer to the file object */
3226:ff.c          **** )
3227:ff.c          **** {
3228:ff.c          **** 	FRESULT res;
3229:ff.c          **** 	DWORD ncl;
3230:ff.c          **** 
3231:ff.c          **** 
3232:ff.c          **** 	res = validate(fp);						/* Check validity of the object */
3233:ff.c          **** 	if (res == FR_OK) {
3234:ff.c          **** 		if (fp->flag & FA__ERROR) {			/* Check abort flag */
3235:ff.c          **** 			res = FR_INT_ERR;
3236:ff.c          **** 		} else {
3237:ff.c          **** 			if (!(fp->flag & FA_WRITE))		/* Check access mode */
3238:ff.c          **** 				res = FR_DENIED;
3239:ff.c          **** 		}
3240:ff.c          **** 	}
3241:ff.c          **** 	if (res == FR_OK) {
3242:ff.c          **** 		if (fp->fsize > fp->fptr) {
3243:ff.c          **** 			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
3244:ff.c          **** 			fp->flag |= FA__WRITTEN;
3245:ff.c          **** 			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
3246:ff.c          **** 				res = remove_chain(fp->fs, fp->sclust);
3247:ff.c          **** 				fp->sclust = 0;
3248:ff.c          **** 			} else {				/* When truncate a part of the file, remove remaining clusters */
3249:ff.c          **** 				ncl = get_fat(fp->fs, fp->clust);
3250:ff.c          **** 				res = FR_OK;
3251:ff.c          **** 				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
3252:ff.c          **** 				if (ncl == 1) res = FR_INT_ERR;
3253:ff.c          **** 				if (res == FR_OK && ncl < fp->fs->n_fatent) {
3254:ff.c          **** 					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
3255:ff.c          **** 					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
3256:ff.c          **** 				}
3257:ff.c          **** 			}
3258:ff.c          **** 		}
3259:ff.c          **** 		if (res != FR_OK) fp->flag |= FA__ERROR;
3260:ff.c          **** 	}
3261:ff.c          **** 
3262:ff.c          **** 	LEAVE_FF(fp->fs, res);
3263:ff.c          **** }
3264:ff.c          **** 
3265:ff.c          **** 
3266:ff.c          **** 
3267:ff.c          **** 
3268:ff.c          **** /*-----------------------------------------------------------------------*/
3269:ff.c          **** /* Delete a File or Directory                                            */
3270:ff.c          **** /*-----------------------------------------------------------------------*/
3271:ff.c          **** 
3272:ff.c          **** FRESULT f_unlink (
3273:ff.c          **** 	const TCHAR *path		/* Pointer to the file or directory path */
3274:ff.c          **** )
3275:ff.c          **** {
3276:ff.c          **** 	FRESULT res;
3277:ff.c          **** 	DIR dj, sdj;
3278:ff.c          **** 	BYTE *dir;
3279:ff.c          **** 	DWORD dclst;
3280:ff.c          **** 	DEF_NAMEBUF;
3281:ff.c          **** 
3282:ff.c          **** 
3283:ff.c          **** 	res = chk_mounted(&path, &dj.fs, 1);
3284:ff.c          **** 	if (res == FR_OK) {
3285:ff.c          **** 		INIT_BUF(dj);
3286:ff.c          **** 		res = follow_path(&dj, path);		/* Follow the file path */
3287:ff.c          **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3288:ff.c          **** 			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
3289:ff.c          **** #if _FS_LOCK
3290:ff.c          **** 		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
3291:ff.c          **** #endif
3292:ff.c          **** 		if (res == FR_OK) {					/* The object is accessible */
3293:ff.c          **** 			dir = dj.dir;
3294:ff.c          **** 			if (!dir) {
3295:ff.c          **** 				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
3296:ff.c          **** 			} else {
3297:ff.c          **** 				if (dir[DIR_Attr] & AM_RDO)
3298:ff.c          **** 					res = FR_DENIED;		/* Cannot remove R/O object */
3299:ff.c          **** 			}
3300:ff.c          **** 			dclst = ld_clust(dj.fs, dir);
3301:ff.c          **** 			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
3302:ff.c          **** 				if (dclst < 2) {
3303:ff.c          **** 					res = FR_INT_ERR;
3304:ff.c          **** 				} else {
3305:ff.c          **** 					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
3306:ff.c          **** 					sdj.sclust = dclst;
3307:ff.c          **** 					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
3308:ff.c          **** 					if (res == FR_OK) {
3309:ff.c          **** 						res = dir_read(&sdj, 0);	/* Read an item */
3310:ff.c          **** 						if (res == FR_OK		/* Not empty dir */
3311:ff.c          **** #if _FS_RPATH
3312:ff.c          **** 						|| dclst == dj.fs->cdir	/* Current dir */
3313:ff.c          **** #endif
3314:ff.c          **** 						) res = FR_DENIED;
3315:ff.c          **** 						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
3316:ff.c          **** 					}
3317:ff.c          **** 				}
3318:ff.c          **** 			}
3319:ff.c          **** 			if (res == FR_OK) {
3320:ff.c          **** 				res = dir_remove(&dj);		/* Remove the directory entry */
3321:ff.c          **** 				if (res == FR_OK) {
3322:ff.c          **** 					if (dclst)				/* Remove the cluster chain if exist */
3323:ff.c          **** 						res = remove_chain(dj.fs, dclst);
3324:ff.c          **** 					if (res == FR_OK) res = sync_fs(dj.fs);
3325:ff.c          **** 				}
3326:ff.c          **** 			}
3327:ff.c          **** 		}
3328:ff.c          **** 		FREE_BUF();
3329:ff.c          **** 	}
3330:ff.c          **** 
3331:ff.c          **** 	LEAVE_FF(dj.fs, res);
3332:ff.c          **** }
3333:ff.c          **** 
3334:ff.c          **** 
3335:ff.c          **** 
3336:ff.c          **** 
3337:ff.c          **** /*-----------------------------------------------------------------------*/
3338:ff.c          **** /* Create a Directory                                                    */
3339:ff.c          **** /*-----------------------------------------------------------------------*/
3340:ff.c          **** 
3341:ff.c          **** FRESULT f_mkdir (
3342:ff.c          **** 	const TCHAR *path		/* Pointer to the directory path */
3343:ff.c          **** )
3344:ff.c          **** {
3345:ff.c          **** 	FRESULT res;
3346:ff.c          **** 	DIR dj;
3347:ff.c          **** 	BYTE *dir, n;
3348:ff.c          **** 	DWORD dsc, dcl, pcl, tm = get_fattime();
3349:ff.c          **** 	DEF_NAMEBUF;
3350:ff.c          **** 
3351:ff.c          **** 
3352:ff.c          **** 	res = chk_mounted(&path, &dj.fs, 1);
3353:ff.c          **** 	if (res == FR_OK) {
3354:ff.c          **** 		INIT_BUF(dj);
3355:ff.c          **** 		res = follow_path(&dj, path);			/* Follow the file path */
3356:ff.c          **** 		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
3357:ff.c          **** 		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
3358:ff.c          **** 			res = FR_INVALID_NAME;
3359:ff.c          **** 		if (res == FR_NO_FILE) {				/* Can create a new directory */
3360:ff.c          **** 			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
3361:ff.c          **** 			res = FR_OK;
3362:ff.c          **** 			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
3363:ff.c          **** 			if (dcl == 1) res = FR_INT_ERR;
3364:ff.c          **** 			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
3365:ff.c          **** 			if (res == FR_OK)					/* Flush FAT */
3366:ff.c          **** 				res = sync_window(dj.fs);
3367:ff.c          **** 			if (res == FR_OK) {					/* Initialize the new directory table */
3368:ff.c          **** 				dsc = clust2sect(dj.fs, dcl);
3369:ff.c          **** 				dir = dj.fs->win;
3370:ff.c          **** 				mem_set(dir, 0, SS(dj.fs));
3371:ff.c          **** 				mem_set(dir+DIR_Name, ' ', 11);	/* Create "." entry */
3372:ff.c          **** 				dir[DIR_Name] = '.';
3373:ff.c          **** 				dir[DIR_Attr] = AM_DIR;
3374:ff.c          **** 				ST_DWORD(dir+DIR_WrtTime, tm);
3375:ff.c          **** 				st_clust(dir, dcl);
3376:ff.c          **** 				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
3377:ff.c          **** 				dir[33] = '.'; pcl = dj.sclust;
3378:ff.c          **** 				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
3379:ff.c          **** 					pcl = 0;
3380:ff.c          **** 				st_clust(dir+SZ_DIR, pcl);
3381:ff.c          **** 				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
3382:ff.c          **** 					dj.fs->winsect = dsc++;
3383:ff.c          **** 					dj.fs->wflag = 1;
3384:ff.c          **** 					res = sync_window(dj.fs);
3385:ff.c          **** 					if (res != FR_OK) break;
3386:ff.c          **** 					mem_set(dir, 0, SS(dj.fs));
3387:ff.c          **** 				}
3388:ff.c          **** 			}
3389:ff.c          **** 			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
3390:ff.c          **** 			if (res != FR_OK) {
3391:ff.c          **** 				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
3392:ff.c          **** 			} else {
3393:ff.c          **** 				dir = dj.dir;
3394:ff.c          **** 				dir[DIR_Attr] = AM_DIR;				/* Attribute */
3395:ff.c          **** 				ST_DWORD(dir+DIR_WrtTime, tm);		/* Created time */
3396:ff.c          **** 				st_clust(dir, dcl);					/* Table start cluster */
3397:ff.c          **** 				dj.fs->wflag = 1;
3398:ff.c          **** 				res = sync_fs(dj.fs);
3399:ff.c          **** 			}
3400:ff.c          **** 		}
3401:ff.c          **** 		FREE_BUF();
3402:ff.c          **** 	}
3403:ff.c          **** 
3404:ff.c          **** 	LEAVE_FF(dj.fs, res);
3405:ff.c          **** }
3406:ff.c          **** 
3407:ff.c          **** 
3408:ff.c          **** 
3409:ff.c          **** 
3410:ff.c          **** /*-----------------------------------------------------------------------*/
3411:ff.c          **** /* Change Attribute                                                      */
3412:ff.c          **** /*-----------------------------------------------------------------------*/
3413:ff.c          **** 
3414:ff.c          **** FRESULT f_chmod (
3415:ff.c          **** 	const TCHAR *path,	/* Pointer to the file path */
3416:ff.c          **** 	BYTE value,			/* Attribute bits */
3417:ff.c          **** 	BYTE mask			/* Attribute mask to change */
3418:ff.c          **** )
3419:ff.c          **** {
3420:ff.c          **** 	FRESULT res;
3421:ff.c          **** 	DIR dj;
3422:ff.c          **** 	BYTE *dir;
3423:ff.c          **** 	DEF_NAMEBUF;
3424:ff.c          **** 
3425:ff.c          **** 
3426:ff.c          **** 	res = chk_mounted(&path, &dj.fs, 1);
3427:ff.c          **** 	if (res == FR_OK) {
3428:ff.c          **** 		INIT_BUF(dj);
3429:ff.c          **** 		res = follow_path(&dj, path);		/* Follow the file path */
3430:ff.c          **** 		FREE_BUF();
3431:ff.c          **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3432:ff.c          **** 			res = FR_INVALID_NAME;
3433:ff.c          **** 		if (res == FR_OK) {
3434:ff.c          **** 			dir = dj.dir;
3435:ff.c          **** 			if (!dir) {						/* Is it a root directory? */
3436:ff.c          **** 				res = FR_INVALID_NAME;
3437:ff.c          **** 			} else {						/* File or sub directory */
3438:ff.c          **** 				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
3439:ff.c          **** 				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
3440:ff.c          **** 				dj.fs->wflag = 1;
3441:ff.c          **** 				res = sync_fs(dj.fs);
3442:ff.c          **** 			}
3443:ff.c          **** 		}
3444:ff.c          **** 	}
3445:ff.c          **** 
3446:ff.c          **** 	LEAVE_FF(dj.fs, res);
3447:ff.c          **** }
3448:ff.c          **** 
3449:ff.c          **** 
3450:ff.c          **** 
3451:ff.c          **** 
3452:ff.c          **** /*-----------------------------------------------------------------------*/
3453:ff.c          **** /* Change Timestamp                                                      */
3454:ff.c          **** /*-----------------------------------------------------------------------*/
3455:ff.c          **** 
3456:ff.c          **** FRESULT f_utime (
3457:ff.c          **** 	const TCHAR *path,	/* Pointer to the file/directory name */
3458:ff.c          **** 	const FILINFO *fno	/* Pointer to the time stamp to be set */
3459:ff.c          **** )
3460:ff.c          **** {
3461:ff.c          **** 	FRESULT res;
3462:ff.c          **** 	DIR dj;
3463:ff.c          **** 	BYTE *dir;
3464:ff.c          **** 	DEF_NAMEBUF;
3465:ff.c          **** 
3466:ff.c          **** 
3467:ff.c          **** 	res = chk_mounted(&path, &dj.fs, 1);
3468:ff.c          **** 	if (res == FR_OK) {
3469:ff.c          **** 		INIT_BUF(dj);
3470:ff.c          **** 		res = follow_path(&dj, path);	/* Follow the file path */
3471:ff.c          **** 		FREE_BUF();
3472:ff.c          **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3473:ff.c          **** 			res = FR_INVALID_NAME;
3474:ff.c          **** 		if (res == FR_OK) {
3475:ff.c          **** 			dir = dj.dir;
3476:ff.c          **** 			if (!dir) {					/* Root directory */
3477:ff.c          **** 				res = FR_INVALID_NAME;
3478:ff.c          **** 			} else {					/* File or sub-directory */
3479:ff.c          **** 				ST_WORD(dir+DIR_WrtTime, fno->ftime);
3480:ff.c          **** 				ST_WORD(dir+DIR_WrtDate, fno->fdate);
3481:ff.c          **** 				dj.fs->wflag = 1;
3482:ff.c          **** 				res = sync_fs(dj.fs);
3483:ff.c          **** 			}
3484:ff.c          **** 		}
3485:ff.c          **** 	}
3486:ff.c          **** 
3487:ff.c          **** 	LEAVE_FF(dj.fs, res);
3488:ff.c          **** }
3489:ff.c          **** 
3490:ff.c          **** 
3491:ff.c          **** 
3492:ff.c          **** 
3493:ff.c          **** /*-----------------------------------------------------------------------*/
3494:ff.c          **** /* Rename File/Directory                                                 */
3495:ff.c          **** /*-----------------------------------------------------------------------*/
3496:ff.c          **** 
3497:ff.c          **** FRESULT f_rename (
3498:ff.c          **** 	const TCHAR *path_old,	/* Pointer to the old name */
3499:ff.c          **** 	const TCHAR *path_new	/* Pointer to the new name */
3500:ff.c          **** )
3501:ff.c          **** {
3502:ff.c          **** 	FRESULT res;
3503:ff.c          **** 	DIR djo, djn;
3504:ff.c          **** 	BYTE buf[21], *dir;
3505:ff.c          **** 	DWORD dw;
3506:ff.c          **** 	DEF_NAMEBUF;
3507:ff.c          **** 
3508:ff.c          **** 
3509:ff.c          **** 	res = chk_mounted(&path_old, &djo.fs, 1);
3510:ff.c          **** 	if (res == FR_OK) {
3511:ff.c          **** 		djn.fs = djo.fs;
3512:ff.c          **** 		INIT_BUF(djo);
3513:ff.c          **** 		res = follow_path(&djo, path_old);		/* Check old object */
3514:ff.c          **** 		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
3515:ff.c          **** 			res = FR_INVALID_NAME;
3516:ff.c          **** #if _FS_LOCK
3517:ff.c          **** 		if (res == FR_OK) res = chk_lock(&djo, 2);
3518:ff.c          **** #endif
3519:ff.c          **** 		if (res == FR_OK) {						/* Old object is found */
3520:ff.c          **** 			if (!djo.dir) {						/* Is root dir? */
3521:ff.c          **** 				res = FR_NO_FILE;
3522:ff.c          **** 			} else {
3523:ff.c          **** 				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
3524:ff.c          **** 				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
3525:ff.c          **** 				res = follow_path(&djn, path_new);
3526:ff.c          **** 				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
3527:ff.c          **** 				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
3528:ff.c          **** /* Start critical section that any interruption can cause a cross-link */
3529:ff.c          **** 					res = dir_register(&djn);			/* Register the new entry */
3530:ff.c          **** 					if (res == FR_OK) {
3531:ff.c          **** 						dir = djn.dir;					/* Copy object information except for name */
3532:ff.c          **** 						mem_cpy(dir+13, buf+2, 19);
3533:ff.c          **** 						dir[DIR_Attr] = buf[0] | AM_ARC;
3534:ff.c          **** 						djo.fs->wflag = 1;
3535:ff.c          **** 						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the direct
3536:ff.c          **** 							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
3537:ff.c          **** 							if (!dw) {
3538:ff.c          **** 								res = FR_INT_ERR;
3539:ff.c          **** 							} else {
3540:ff.c          **** 								res = move_window(djo.fs, dw);
3541:ff.c          **** 								dir = djo.fs->win+SZ_DIR;	/* .. entry */
3542:ff.c          **** 								if (res == FR_OK && dir[1] == '.') {
3543:ff.c          **** 									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
3544:ff.c          **** 									st_clust(dir, dw);
3545:ff.c          **** 									djo.fs->wflag = 1;
3546:ff.c          **** 								}
3547:ff.c          **** 							}
3548:ff.c          **** 						}
3549:ff.c          **** 						if (res == FR_OK) {
3550:ff.c          **** 							res = dir_remove(&djo);		/* Remove old entry */
3551:ff.c          **** 							if (res == FR_OK)
3552:ff.c          **** 								res = sync_fs(djo.fs);
3553:ff.c          **** 						}
3554:ff.c          **** 					}
3555:ff.c          **** /* End critical section */
3556:ff.c          **** 				}
3557:ff.c          **** 			}
3558:ff.c          **** 		}
3559:ff.c          **** 		FREE_BUF();
3560:ff.c          **** 	}
3561:ff.c          **** 
3562:ff.c          **** 	LEAVE_FF(djo.fs, res);
3563:ff.c          **** }
 4328               	.LM413:
 4329 16e4 E881      		ld r30,Y
 4330 16e6 F981      		ldd r31,Y+1
2026:ff.c          **** 			dj->sclust = ld_clust(dj->fs, dir);
 4332               	.LM414:
 4333 16e8 8081      		ld r24,Z
 4334 16ea 0E94 0000 		call ld_clust.isra.0
 4335 16ee 6E83      		std Y+6,r22
 4336 16f0 7F83      		std Y+7,r23
 4337 16f2 8887      		std Y+8,r24
 4338 16f4 9987      		std Y+9,r25
2027:ff.c          **** 		}
 4340               	.LM415:
 4341 16f6 00C0      		rjmp .L284
 4342               	.L261:
2024:ff.c          **** 				res = FR_NO_PATH; break;
 4344               	.LM416:
 4345 16f8 85E0      		ldi r24,lo8(5)
 4346 16fa 00C0      		rjmp .L268
 4347               	.L262:
 4348               	.LBB69:
 4349               	.LBB62:
1840:ff.c          **** 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
 4351               	.LM417:
 4352 16fc 86E0      		ldi r24,lo8(6)
 4353 16fe 00C0      		rjmp .L268
 4354               	.L235:
1863:ff.c          **** 			if (IsUpper(c)) {			/* ASCII large capital? */
 4356               	.LM418:
 4357 1700 462F      		mov r20,r22
 4358 1702 4154      		subi r20,lo8(-(-65))
 4359 1704 4A31      		cpi r20,lo8(26)
 4360 1706 00F4      		brsh .+2
 4361 1708 00C0      		rjmp .L248
 4362 170a 00C0      		rjmp .L288
 4363               	.L228:
1840:ff.c          **** 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
 4365               	.LM419:
 4366 170c 2830      		cpi r18,8
 4367 170e 3105      		cpc r19,__zero_reg__
 4368 1710 01F4      		brne .+2
 4369 1712 00C0      		rjmp .L289
 4370 1714 00C0      		rjmp .L262
 4371               	.L268:
 4372               	/* epilogue start */
 4373               	.LBE62:
 4374               	.LBE69:
2031:ff.c          **** }
 4376               	.LM420:
 4377 1716 DF91      		pop r29
 4378 1718 CF91      		pop r28
 4379 171a 1F91      		pop r17
 4380 171c 0F91      		pop r16
 4381 171e FF90      		pop r15
 4382 1720 EF90      		pop r14
 4383 1722 DF90      		pop r13
 4384 1724 CF90      		pop r12
 4385 1726 BF90      		pop r11
 4386 1728 AF90      		pop r10
 4387 172a 9F90      		pop r9
 4388 172c 8F90      		pop r8
 4389 172e 0895      		ret
 4419               	.Lscope17:
 4421               		.stabd	78,0,0
 4425               	dir_read.constprop.10:
 4426               		.stabd	46,0,0
1506:ff.c          **** FRESULT dir_read (
 4428               	.LM421:
 4429               	.LFBB18:
 4430 1730 CF93      		push r28
 4431 1732 DF93      		push r29
 4432               	/* prologue: function */
 4433               	/* frame size = 0 */
 4434               	/* stack size = 2 */
 4435               	.L__stack_usage = 2
 4436 1734 EC01      		movw r28,r24
1517:ff.c          **** 	res = FR_NO_FILE;
 4438               	.LM422:
 4439 1736 84E0      		ldi r24,lo8(4)
 4440 1738 00C0      		rjmp .L292
 4441               	.L296:
1519:ff.c          **** 		res = move_window(dj->fs, dj->sect);
 4443               	.LM423:
 4444 173a 8881      		ld r24,Y
 4445 173c 9981      		ldd r25,Y+1
 4446 173e 0E94 0000 		call move_window
1520:ff.c          **** 		if (res != FR_OK) break;
 4448               	.LM424:
 4449 1742 8111      		cpse r24,__zero_reg__
 4450 1744 00C0      		rjmp .L297
1521:ff.c          **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
 4452               	.LM425:
 4453 1746 EA89      		ldd r30,Y+18
 4454 1748 FB89      		ldd r31,Y+19
1522:ff.c          **** 		c = dir[DIR_Name];
 4456               	.LM426:
 4457 174a 9081      		ld r25,Z
1523:ff.c          **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 4459               	.LM427:
 4460 174c 9923      		tst r25
 4461 174e 01F0      		breq .L298
1524:ff.c          **** 		a = dir[DIR_Attr] & AM_MASK;
 4463               	.LM428:
 4464 1750 2385      		ldd r18,Z+11
1544:ff.c          **** 		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (a == AM_VOL) == vol)	/* Is it a valid 
 4466               	.LM429:
 4467 1752 953E      		cpi r25,lo8(-27)
 4468 1754 01F0      		breq .L294
 4469 1756 9E32      		cpi r25,lo8(46)
 4470 1758 01F0      		breq .L294
1524:ff.c          **** 		a = dir[DIR_Attr] & AM_MASK;
 4472               	.LM430:
 4473 175a 922F      		mov r25,r18
 4474 175c 9F73      		andi r25,lo8(63)
1544:ff.c          **** 		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (a == AM_VOL) == vol)	/* Is it a valid 
 4476               	.LM431:
 4477 175e 9F30      		cpi r25,lo8(15)
 4478 1760 01F0      		breq .L294
 4479 1762 9830      		cpi r25,lo8(8)
 4480 1764 01F4      		brne .L303
 4481               	.L294:
1547:ff.c          **** 		res = dir_next(dj, 0);				/* Next entry */
 4483               	.LM432:
 4484 1766 60E0      		ldi r22,0
 4485 1768 70E0      		ldi r23,0
 4486 176a CE01      		movw r24,r28
 4487 176c 0E94 0000 		call dir_next
1548:ff.c          **** 		if (res != FR_OK) break;
 4489               	.LM433:
 4490 1770 8111      		cpse r24,__zero_reg__
 4491 1772 00C0      		rjmp .L297
 4492               	.L292:
1518:ff.c          **** 	while (dj->sect) {
 4494               	.LM434:
 4495 1774 4E85      		ldd r20,Y+14
 4496 1776 5F85      		ldd r21,Y+15
 4497 1778 6889      		ldd r22,Y+16
 4498 177a 7989      		ldd r23,Y+17
 4499 177c 4115      		cp r20,__zero_reg__
 4500 177e 5105      		cpc r21,__zero_reg__
 4501 1780 6105      		cpc r22,__zero_reg__
 4502 1782 7105      		cpc r23,__zero_reg__
 4503 1784 01F4      		brne .L296
1551:ff.c          **** 	if (res != FR_OK) dj->sect = 0;
 4505               	.LM435:
 4506 1786 8823      		tst r24
 4507 1788 01F0      		breq .L303
 4508               	.L297:
 4509 178a 1E86      		std Y+14,__zero_reg__
 4510 178c 1F86      		std Y+15,__zero_reg__
 4511 178e 188A      		std Y+16,__zero_reg__
 4512 1790 198A      		std Y+17,__zero_reg__
 4513 1792 00C0      		rjmp .L303
 4514               	.L298:
1523:ff.c          **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 4516               	.LM436:
 4517 1794 84E0      		ldi r24,lo8(4)
 4518 1796 00C0      		rjmp .L297
 4519               	.L303:
 4520               	/* epilogue start */
1554:ff.c          **** }
 4522               	.LM437:
 4523 1798 DF91      		pop r29
 4524 179a CF91      		pop r28
 4525 179c 0895      		ret
 4532               	.Lscope18:
 4534               		.stabd	78,0,0
 4538               	dir_register:
 4539               		.stabd	46,0,0
1567:ff.c          **** {
 4541               	.LM438:
 4542               	.LFBB19:
 4543 179e 1F93      		push r17
 4544 17a0 CF93      		push r28
 4545 17a2 DF93      		push r29
 4546               	/* prologue: function */
 4547               	/* frame size = 0 */
 4548               	/* stack size = 3 */
 4549               	.L__stack_usage = 3
 4550 17a4 EC01      		movw r28,r24
 4551               	.LBB76:
 4552               	.LBB77:
1214:ff.c          **** 	res = dir_sdi(dj, 0);
 4554               	.LM439:
 4555 17a6 60E0      		ldi r22,0
 4556 17a8 70E0      		ldi r23,0
 4557 17aa 0E94 0000 		call dir_sdi
 4558               	.L333:
 4559 17ae 182F      		mov r17,r24
1215:ff.c          **** 	if (res == FR_OK) {
 4561               	.LM440:
 4562 17b0 8111      		cpse r24,__zero_reg__
 4563 17b2 00C0      		rjmp .L324
1218:ff.c          **** 			res = move_window(dj->fs, dj->sect);
 4565               	.LM441:
 4566 17b4 4E85      		ldd r20,Y+14
 4567 17b6 5F85      		ldd r21,Y+15
 4568 17b8 6889      		ldd r22,Y+16
 4569 17ba 7989      		ldd r23,Y+17
 4570 17bc 8881      		ld r24,Y
 4571 17be 9981      		ldd r25,Y+1
 4572 17c0 0E94 0000 		call move_window
 4573 17c4 182F      		mov r17,r24
1219:ff.c          **** 			if (res != FR_OK) break;
 4575               	.LM442:
 4576 17c6 8111      		cpse r24,__zero_reg__
 4577 17c8 00C0      		rjmp .L324
1220:ff.c          **** 			if (dj->dir[0] == DDE || dj->dir[0] == 0) {	/* Is it a blank entry? */
 4579               	.LM443:
 4580 17ca EA89      		ldd r30,Y+18
 4581 17cc FB89      		ldd r31,Y+19
 4582 17ce 8081      		ld r24,Z
 4583 17d0 853E      		cpi r24,lo8(-27)
 4584 17d2 01F0      		breq .L314
 4585 17d4 8823      		tst r24
 4586 17d6 01F0      		breq .L314
1225:ff.c          **** 			res = dir_next(dj, 1);		/* Next entry with table stretch enabled */
 4588               	.LM444:
 4589 17d8 61E0      		ldi r22,lo8(1)
 4590 17da 70E0      		ldi r23,0
 4591 17dc CE01      		movw r24,r28
 4592 17de 0E94 0000 		call dir_next
 4593 17e2 00C0      		rjmp .L333
 4594               	.L319:
 4595               	.LBE77:
 4596               	.LBE76:
 4597               	.LBB78:
 4598               	.LBB79:
1621:ff.c          **** 			mem_set(dj->dir, 0, SZ_DIR);	/* Clean the entry */
 4600               	.LM445:
 4601 17e4 EA89      		ldd r30,Y+18
 4602 17e6 FB89      		ldd r31,Y+19
1564:ff.c          **** FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_D
 4604               	.LM446:
 4605 17e8 9F01      		movw r18,r30
 4606 17ea 205E      		subi r18,-32
 4607 17ec 3F4F      		sbci r19,-1
 4608 17ee 00C0      		rjmp .L316
 4609               	.L317:
 4610               	.LBB80:
 4611               	.LBB81:
 560:ff.c          **** 		*d++ = (BYTE)val;
 4613               	.LM447:
 4614 17f0 1192      		st Z+,__zero_reg__
 4615               	.L316:
 559:ff.c          **** 	while (cnt--)
 4617               	.LM448:
 4618 17f2 E217      		cp r30,r18
 4619 17f4 F307      		cpc r31,r19
 4620 17f6 01F4      		brne .L317
 4621               	.LBE81:
 4622               	.LBE80:
1622:ff.c          **** 			mem_cpy(dj->dir, dj->fn, 11);	/* Put SFN */
 4624               	.LM449:
 4625 17f8 6C89      		ldd r22,Y+20
 4626 17fa 7D89      		ldd r23,Y+21
 4627 17fc 4BE0      		ldi r20,lo8(11)
 4628 17fe 50E0      		ldi r21,0
 4629 1800 8A89      		ldd r24,Y+18
 4630 1802 9B89      		ldd r25,Y+19
 4631 1804 0E94 0000 		call mem_cpy
1626:ff.c          **** 			dj->fs->wflag = 1;
 4633               	.LM450:
 4634 1808 E881      		ld r30,Y
 4635 180a F981      		ldd r31,Y+1
 4636 180c 81E0      		ldi r24,lo8(1)
 4637 180e 8483      		std Z+4,r24
 4638 1810 00C0      		rjmp .L324
 4639               	.L314:
1619:ff.c          **** 		res = move_window(dj->fs, dj->sect);
 4641               	.LM451:
 4642 1812 4E85      		ldd r20,Y+14
 4643 1814 5F85      		ldd r21,Y+15
 4644 1816 6889      		ldd r22,Y+16
 4645 1818 7989      		ldd r23,Y+17
 4646 181a 8881      		ld r24,Y
 4647 181c 9981      		ldd r25,Y+1
 4648 181e 0E94 0000 		call move_window
 4649 1822 182F      		mov r17,r24
1620:ff.c          **** 		if (res == FR_OK) {
 4651               	.LM452:
 4652 1824 8823      		tst r24
 4653 1826 01F0      		breq .L319
 4654               	.L324:
 4655               	.LBE79:
 4656               	.LBE78:
1631:ff.c          **** }
 4658               	.LM453:
 4659 1828 812F      		mov r24,r17
 4660               	/* epilogue start */
 4661 182a DF91      		pop r29
 4662 182c CF91      		pop r28
 4663 182e 1F91      		pop r17
 4664 1830 0895      		ret
 4672               	.Lscope19:
 4674               		.stabd	78,0,0
 4679               	remove_chain:
 4680               		.stabd	46,0,0
 952:ff.c          **** {
 4682               	.LM454:
 4683               	.LFBB20:
 4684 1832 7F92      		push r7
 4685 1834 8F92      		push r8
 4686 1836 9F92      		push r9
 4687 1838 AF92      		push r10
 4688 183a BF92      		push r11
 4689 183c CF92      		push r12
 4690 183e DF92      		push r13
 4691 1840 EF92      		push r14
 4692 1842 FF92      		push r15
 4693 1844 0F93      		push r16
 4694 1846 1F93      		push r17
 4695 1848 CF93      		push r28
 4696 184a DF93      		push r29
 4697               	/* prologue: function */
 4698               	/* frame size = 0 */
 4699               	/* stack size = 13 */
 4700               	.L__stack_usage = 13
 4701 184c EC01      		movw r28,r24
 4702 184e 6A01      		movw r12,r20
 4703 1850 7B01      		movw r14,r22
 959:ff.c          **** 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 4705               	.LM455:
 4706 1852 4230      		cpi r20,2
 4707 1854 5105      		cpc r21,__zero_reg__
 4708 1856 6105      		cpc r22,__zero_reg__
 4709 1858 7105      		cpc r23,__zero_reg__
 4710 185a 00F4      		brsh .+2
 4711 185c 00C0      		rjmp .L343
 959:ff.c          **** 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 4713               	.LM456:
 4714 185e 8E89      		ldd r24,Y+22
 4715 1860 9F89      		ldd r25,Y+23
 4716 1862 A88D      		ldd r26,Y+24
 4717 1864 B98D      		ldd r27,Y+25
 4718 1866 4817      		cp r20,r24
 4719 1868 5907      		cpc r21,r25
 4720 186a 6A07      		cpc r22,r26
 4721 186c 7B07      		cpc r23,r27
 4722 186e 00F0      		brlo .+2
 4723 1870 00C0      		rjmp .L343
 4724 1872 00C0      		rjmp .L349
 4725               	.L340:
 4726               	.LBB84:
 4727               	.LBB85:
 965:ff.c          **** 			nxt = get_fat(fs, clst);			/* Get cluster status */
 4729               	.LM457:
 4730 1874 B701      		movw r22,r14
 4731 1876 A601      		movw r20,r12
 4732 1878 CE01      		movw r24,r28
 4733 187a 0E94 0000 		call get_fat
 4734 187e 4B01      		movw r8,r22
 4735 1880 5C01      		movw r10,r24
 966:ff.c          **** 			if (nxt == 0) break;				/* Empty cluster? */
 4737               	.LM458:
 4738 1882 6115      		cp r22,__zero_reg__
 4739 1884 7105      		cpc r23,__zero_reg__
 4740 1886 8105      		cpc r24,__zero_reg__
 4741 1888 9105      		cpc r25,__zero_reg__
 4742 188a 01F4      		brne .L337
 4743               	.L341:
 4744               	.LBE85:
 4745               	.LBE84:
 952:ff.c          **** {
 4747               	.LM459:
 4748 188c 80E0      		ldi r24,0
 4749 188e 00C0      		rjmp .L335
 4750               	.L337:
 4751               	.LBB88:
 4752               	.LBB86:
 967:ff.c          **** 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 4754               	.LM460:
 4755 1890 81E0      		ldi r24,1
 4756 1892 8816      		cp r8,r24
 4757 1894 9104      		cpc r9,__zero_reg__
 4758 1896 A104      		cpc r10,__zero_reg__
 4759 1898 B104      		cpc r11,__zero_reg__
 4760 189a 01F0      		breq .L343
 968:ff.c          **** 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 4762               	.LM461:
 4763 189c 2FEF      		ldi r18,-1
 4764 189e 8216      		cp r8,r18
 4765 18a0 9206      		cpc r9,r18
 4766 18a2 A206      		cpc r10,r18
 4767 18a4 B206      		cpc r11,r18
 4768 18a6 01F0      		breq .L345
 969:ff.c          **** 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 4770               	.LM462:
 4771 18a8 00E0      		ldi r16,0
 4772 18aa 10E0      		ldi r17,0
 4773 18ac 9801      		movw r18,r16
 4774 18ae B701      		movw r22,r14
 4775 18b0 A601      		movw r20,r12
 4776 18b2 CE01      		movw r24,r28
 4777 18b4 0E94 0000 		call put_fat
 970:ff.c          **** 			if (res != FR_OK) break;
 4779               	.LM463:
 4780 18b8 8111      		cpse r24,__zero_reg__
 4781 18ba 00C0      		rjmp .L335
 971:ff.c          **** 			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
 4783               	.LM464:
 4784 18bc 8E85      		ldd r24,Y+14
 4785 18be 9F85      		ldd r25,Y+15
 4786 18c0 A889      		ldd r26,Y+16
 4787 18c2 B989      		ldd r27,Y+17
 4788 18c4 8F3F      		cpi r24,-1
 4789 18c6 2FEF      		ldi r18,-1
 4790 18c8 9207      		cpc r25,r18
 4791 18ca A207      		cpc r26,r18
 4792 18cc B207      		cpc r27,r18
 4793 18ce 01F0      		breq .L339
 972:ff.c          **** 				fs->free_clust++;
 4795               	.LM465:
 4796 18d0 0196      		adiw r24,1
 4797 18d2 A11D      		adc r26,__zero_reg__
 4798 18d4 B11D      		adc r27,__zero_reg__
 4799 18d6 8E87      		std Y+14,r24
 4800 18d8 9F87      		std Y+15,r25
 4801 18da A88B      		std Y+16,r26
 4802 18dc B98B      		std Y+17,r27
 973:ff.c          **** 				fs->fsi_flag = 1;
 4804               	.LM466:
 4805 18de 7D82      		std Y+5,r7
 4806               	.L339:
 4807               	.LBE86:
 4808               	.LBE88:
 952:ff.c          **** {
 4810               	.LM467:
 4811 18e0 7501      		movw r14,r10
 4812 18e2 6401      		movw r12,r8
 4813 18e4 00C0      		rjmp .L350
 4814               	.L349:
 4815               	.LBB89:
 4816               	.LBB87:
 973:ff.c          **** 				fs->fsi_flag = 1;
 4818               	.LM468:
 4819 18e6 7724      		clr r7
 4820 18e8 7394      		inc r7
 4821               	.L350:
 964:ff.c          **** 		while (clst < fs->n_fatent) {			/* Not a last link? */
 4823               	.LM469:
 4824 18ea 8E89      		ldd r24,Y+22
 4825 18ec 9F89      		ldd r25,Y+23
 4826 18ee A88D      		ldd r26,Y+24
 4827 18f0 B98D      		ldd r27,Y+25
 4828 18f2 C816      		cp r12,r24
 4829 18f4 D906      		cpc r13,r25
 4830 18f6 EA06      		cpc r14,r26
 4831 18f8 FB06      		cpc r15,r27
 4832 18fa 00F4      		brsh .+2
 4833 18fc 00C0      		rjmp .L340
 4834 18fe 00C0      		rjmp .L341
 4835               	.L345:
 968:ff.c          **** 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 4837               	.LM470:
 4838 1900 81E0      		ldi r24,lo8(1)
 4839 1902 00C0      		rjmp .L335
 4840               	.L343:
 4841               	.LBE87:
 4842               	.LBE89:
 960:ff.c          **** 		res = FR_INT_ERR;
 4844               	.LM471:
 4845 1904 82E0      		ldi r24,lo8(2)
 4846               	.L335:
 4847               	/* epilogue start */
 990:ff.c          **** }
 4849               	.LM472:
 4850 1906 DF91      		pop r29
 4851 1908 CF91      		pop r28
 4852 190a 1F91      		pop r17
 4853 190c 0F91      		pop r16
 4854 190e FF90      		pop r15
 4855 1910 EF90      		pop r14
 4856 1912 DF90      		pop r13
 4857 1914 CF90      		pop r12
 4858 1916 BF90      		pop r11
 4859 1918 AF90      		pop r10
 4860 191a 9F90      		pop r9
 4861 191c 8F90      		pop r8
 4862 191e 7F90      		pop r7
 4863 1920 0895      		ret
 4868               	.Lscope20:
 4870               		.stabd	78,0,0
 4874               	.global	f_mount
 4876               	f_mount:
 4877               		.stabd	46,0,0
2272:ff.c          **** {
 4879               	.LM473:
 4880               	.LFBB21:
 4881               	/* prologue: function */
 4882               	/* frame size = 0 */
 4883               	/* stack size = 0 */
 4884               	.L__stack_usage = 0
2276:ff.c          **** 	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
 4886               	.LM474:
 4887 1922 8111      		cpse r24,__zero_reg__
 4888 1924 00C0      		rjmp .L355
2278:ff.c          **** 	rfs = FatFs[vol];			/* Get current fs object */
 4890               	.LM475:
 4891 1926 E091 0000 		lds r30,FatFs
 4892 192a F091 0000 		lds r31,FatFs+1
2280:ff.c          **** 	if (rfs) {
 4894               	.LM476:
 4895 192e 3097      		sbiw r30,0
 4896 1930 01F0      		breq .L353
2287:ff.c          **** 		rfs->fs_type = 0;		/* Clear old fs object */
 4898               	.LM477:
 4899 1932 1082      		st Z,__zero_reg__
 4900               	.L353:
2290:ff.c          **** 	if (fs) {
 4902               	.LM478:
 4903 1934 6115      		cp r22,__zero_reg__
 4904 1936 7105      		cpc r23,__zero_reg__
 4905 1938 01F0      		breq .L354
2291:ff.c          **** 		fs->fs_type = 0;		/* Clear new fs object */
 4907               	.LM479:
 4908 193a FB01      		movw r30,r22
 4909 193c 1082      		st Z,__zero_reg__
 4910               	.L354:
2296:ff.c          **** 	FatFs[vol] = fs;			/* Register new fs object */
 4912               	.LM480:
 4913 193e 7093 0000 		sts FatFs+1,r23
 4914 1942 6093 0000 		sts FatFs,r22
2298:ff.c          **** 	return FR_OK;
 4916               	.LM481:
 4917 1946 80E0      		ldi r24,0
 4918 1948 0895      		ret
 4919               	.L355:
2277:ff.c          **** 		return FR_INVALID_DRIVE;
 4921               	.LM482:
 4922 194a 8BE0      		ldi r24,lo8(11)
2299:ff.c          **** }
 4924               	.LM483:
 4925 194c 0895      		ret
 4930               	.Lscope21:
 4932               		.stabd	78,0,0
 4937               	.global	f_open
 4939               	f_open:
 4940               		.stabd	46,0,0
2313:ff.c          **** {
 4942               	.LM484:
 4943               	.LFBB22:
 4944 194e 2F92      		push r2
 4945 1950 3F92      		push r3
 4946 1952 4F92      		push r4
 4947 1954 5F92      		push r5
 4948 1956 6F92      		push r6
 4949 1958 7F92      		push r7
 4950 195a 8F92      		push r8
 4951 195c 9F92      		push r9
 4952 195e AF92      		push r10
 4953 1960 BF92      		push r11
 4954 1962 CF92      		push r12
 4955 1964 DF92      		push r13
 4956 1966 EF92      		push r14
 4957 1968 FF92      		push r15
 4958 196a 0F93      		push r16
 4959 196c 1F93      		push r17
 4960 196e CF93      		push r28
 4961 1970 DF93      		push r29
 4962 1972 CDB7      		in r28,__SP_L__
 4963 1974 DEB7      		in r29,__SP_H__
 4964 1976 A497      		sbiw r28,36
 4965 1978 0FB6      		in __tmp_reg__,__SREG__
 4966 197a F894      		cli
 4967 197c DEBF      		out __SP_H__,r29
 4968 197e 0FBE      		out __SREG__,__tmp_reg__
 4969 1980 CDBF      		out __SP_L__,r28
 4970               	/* prologue: function */
 4971               	/* frame size = 36 */
 4972               	/* stack size = 54 */
 4973               	.L__stack_usage = 54
 4974 1982 7C01      		movw r14,r24
 4975 1984 7CA3      		std Y+36,r23
 4976 1986 6BA3      		std Y+35,r22
 4977 1988 D42E      		mov r13,r20
2320:ff.c          **** 	if (!fp) return FR_INVALID_OBJECT;
 4979               	.LM485:
 4980 198a 0097      		sbiw r24,0
 4981 198c 01F4      		brne .+2
 4982 198e 00C0      		rjmp .L375
2321:ff.c          **** 	fp->fs = 0;			/* Clear file object */
 4984               	.LM486:
 4985 1990 FC01      		movw r30,r24
 4986 1992 1182      		std Z+1,__zero_reg__
 4987 1994 1082      		st Z,__zero_reg__
2325:ff.c          **** 	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
 4989               	.LM487:
 4990 1996 4E71      		andi r20,lo8(30)
 4991 1998 BE01      		movw r22,r28
 4992 199a 6F5F      		subi r22,-1
 4993 199c 7F4F      		sbci r23,-1
 4994 199e CE01      		movw r24,r28
 4995 19a0 8396      		adiw r24,35
 4996 19a2 0E94 0000 		call chk_mounted
 4997 19a6 782E      		mov r7,r24
2330:ff.c          **** 	if (res == FR_OK) {
 4999               	.LM488:
 5000 19a8 8111      		cpse r24,__zero_reg__
 5001 19aa 00C0      		rjmp .L387
2331:ff.c          **** 		INIT_BUF(dj);
 5003               	.LM489:
 5004 19ac CE01      		movw r24,r28
 5005 19ae 4796      		adiw r24,23
 5006 19b0 9E8B      		std Y+22,r25
 5007 19b2 8D8B      		std Y+21,r24
2332:ff.c          **** 		res = follow_path(&dj, path);	/* Follow the file path */
 5009               	.LM490:
 5010 19b4 6BA1      		ldd r22,Y+35
 5011 19b6 7CA1      		ldd r23,Y+36
 5012 19b8 CE01      		movw r24,r28
 5013 19ba 0196      		adiw r24,1
 5014 19bc 0E94 0000 		call follow_path
2333:ff.c          **** 		dir = dj.dir;
 5016               	.LM491:
 5017 19c0 0B89      		ldd r16,Y+19
 5018 19c2 1C89      		ldd r17,Y+20
2335:ff.c          **** 		if (res == FR_OK) {
 5020               	.LM492:
 5021 19c4 8111      		cpse r24,__zero_reg__
 5022 19c6 00C0      		rjmp .L364
2336:ff.c          **** 			if (!dir)	/* Current dir itself */
 5024               	.LM493:
 5025 19c8 0115      		cp r16,__zero_reg__
 5026 19ca 1105      		cpc r17,__zero_reg__
 5027 19cc 01F4      		brne .L364
2337:ff.c          **** 				res = FR_INVALID_NAME;
 5029               	.LM494:
 5030 19ce 86E0      		ldi r24,lo8(6)
 5031               	.L364:
2324:ff.c          **** 	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
 5033               	.LM495:
 5034 19d0 4FE1      		ldi r20,lo8(31)
 5035 19d2 642E      		mov r6,r20
 5036 19d4 6D20      		and r6,r13
2344:ff.c          **** 		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 5038               	.LM496:
 5039 19d6 9D2D      		mov r25,r13
 5040 19d8 9C71      		andi r25,lo8(28)
 5041 19da 01F4      		brne .+2
 5042 19dc 00C0      		rjmp .L365
 5043               	.LBB93:
2347:ff.c          **** 			if (res != FR_OK) {					/* No file, create new */
 5045               	.LM497:
 5046 19de 8823      		tst r24
 5047 19e0 01F0      		breq .L366
2348:ff.c          **** 				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
 5049               	.LM498:
 5050 19e2 8430      		cpi r24,lo8(4)
 5051 19e4 01F4      		brne .L367
2352:ff.c          **** 					res = dir_register(&dj);
 5053               	.LM499:
 5054 19e6 CE01      		movw r24,r28
 5055 19e8 0196      		adiw r24,1
 5056 19ea 0E94 0000 		call dir_register
 5057               	.L367:
2354:ff.c          **** 				mode |= FA_CREATE_ALWAYS;		/* File is created */
 5059               	.LM500:
 5060 19ee F8E0      		ldi r31,lo8(8)
 5061 19f0 6F2A      		or r6,r31
2355:ff.c          **** 				dir = dj.dir;					/* New entry */
 5063               	.LM501:
 5064 19f2 0B89      		ldd r16,Y+19
 5065 19f4 1C89      		ldd r17,Y+20
2365:ff.c          **** 			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 5067               	.LM502:
 5068 19f6 8823      		tst r24
 5069 19f8 01F0      		breq .L368
 5070 19fa 00C0      		rjmp .L373
 5071               	.L366:
2358:ff.c          **** 				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 5073               	.LM503:
 5074 19fc F801      		movw r30,r16
 5075 19fe 8385      		ldd r24,Z+11
 5076 1a00 8171      		andi r24,lo8(17)
 5077 1a02 01F0      		breq .+2
 5078 1a04 00C0      		rjmp .L380
2361:ff.c          **** 					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
 5080               	.LM504:
 5081 1a06 D2FC      		sbrc r13,2
 5082 1a08 00C0      		rjmp .L378
 5083               	.L368:
2365:ff.c          **** 			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 5085               	.LM505:
 5086 1a0a 63FE      		sbrs r6,3
 5087 1a0c 00C0      		rjmp .L372
2366:ff.c          **** 				dw = get_fattime();					/* Created time */
 5089               	.LM506:
 5090 1a0e 0E94 0000 		call get_fattime
2367:ff.c          **** 				ST_DWORD(dir+DIR_CrtTime, dw);
 5092               	.LM507:
 5093 1a12 F801      		movw r30,r16
 5094 1a14 6687      		std Z+14,r22
 5095 1a16 7787      		std Z+15,r23
 5096 1a18 808B      		std Z+16,r24
 5097 1a1a 918B      		std Z+17,r25
2368:ff.c          **** 				dir[DIR_Attr] = 0;					/* Reset attribute */
 5099               	.LM508:
 5100 1a1c 1386      		std Z+11,__zero_reg__
2369:ff.c          **** 				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
 5102               	.LM509:
 5103 1a1e 148E      		std Z+28,__zero_reg__
 5104 1a20 158E      		std Z+29,__zero_reg__
 5105 1a22 168E      		std Z+30,__zero_reg__
 5106 1a24 178E      		std Z+31,__zero_reg__
2370:ff.c          **** 				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
 5108               	.LM510:
 5109 1a26 C980      		ldd r12,Y+1
 5110 1a28 DA80      		ldd r13,Y+2
 5111 1a2a B801      		movw r22,r16
 5112 1a2c F601      		movw r30,r12
 5113 1a2e 8081      		ld r24,Z
 5114 1a30 0E94 0000 		call ld_clust.isra.0
 5115 1a34 4B01      		movw r8,r22
 5116 1a36 5C01      		movw r10,r24
 5117               	.LBB94:
 5118               	.LBB95:
1261:ff.c          **** 	ST_WORD(dir+DIR_FstClusLO, cl);
 5120               	.LM511:
 5121 1a38 F801      		movw r30,r16
 5122 1a3a 128E      		std Z+26,__zero_reg__
 5123 1a3c 138E      		std Z+27,__zero_reg__
1262:ff.c          **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 5125               	.LM512:
 5126 1a3e 148A      		std Z+20,__zero_reg__
 5127 1a40 158A      		std Z+21,__zero_reg__
 5128               	.LBE95:
 5129               	.LBE94:
2372:ff.c          **** 				dj.fs->wflag = 1;
 5131               	.LM513:
 5132 1a42 81E0      		ldi r24,lo8(1)
 5133 1a44 F601      		movw r30,r12
 5134 1a46 8483      		std Z+4,r24
2373:ff.c          **** 				if (cl) {							/* Remove the cluster chain if exist */
 5136               	.LM514:
 5137 1a48 8114      		cp r8,__zero_reg__
 5138 1a4a 9104      		cpc r9,__zero_reg__
 5139 1a4c A104      		cpc r10,__zero_reg__
 5140 1a4e B104      		cpc r11,__zero_reg__
 5141 1a50 01F0      		breq .L372
2374:ff.c          **** 					dw = dj.fs->winsect;
 5143               	.LM515:
 5144 1a52 26A4      		ldd r2,Z+46
 5145 1a54 37A4      		ldd r3,Z+47
 5146 1a56 40A8      		ldd r4,Z+48
 5147 1a58 51A8      		ldd r5,Z+49
2375:ff.c          **** 					res = remove_chain(dj.fs, cl);
 5149               	.LM516:
 5150 1a5a B501      		movw r22,r10
 5151 1a5c A401      		movw r20,r8
 5152 1a5e C601      		movw r24,r12
 5153 1a60 0E94 0000 		call remove_chain
2376:ff.c          **** 					if (res == FR_OK) {
 5155               	.LM517:
 5156 1a64 8111      		cpse r24,__zero_reg__
 5157 1a66 00C0      		rjmp .L373
2377:ff.c          **** 						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 5159               	.LM518:
 5160 1a68 8981      		ldd r24,Y+1
 5161 1a6a 9A81      		ldd r25,Y+2
 5162 1a6c F1E0      		ldi r31,1
 5163 1a6e 8F1A      		sub r8,r31
 5164 1a70 9108      		sbc r9,__zero_reg__
 5165 1a72 A108      		sbc r10,__zero_reg__
 5166 1a74 B108      		sbc r11,__zero_reg__
 5167 1a76 FC01      		movw r30,r24
 5168 1a78 8286      		std Z+10,r8
 5169 1a7a 9386      		std Z+11,r9
 5170 1a7c A486      		std Z+12,r10
 5171 1a7e B586      		std Z+13,r11
2378:ff.c          **** 						res = move_window(dj.fs, dw);
 5173               	.LM519:
 5174 1a80 B201      		movw r22,r4
 5175 1a82 A101      		movw r20,r2
 5176 1a84 0E94 0000 		call move_window
 5177               	.LBE93:
2393:ff.c          **** 		if (res == FR_OK) {
 5179               	.LM520:
 5180 1a88 8823      		tst r24
 5181 1a8a 01F0      		breq .L372
 5182 1a8c 00C0      		rjmp .L373
 5183               	.L365:
2384:ff.c          **** 			if (res == FR_OK) {						/* Follow succeeded */
 5185               	.LM521:
 5186 1a8e 8111      		cpse r24,__zero_reg__
 5187 1a90 00C0      		rjmp .L373
2385:ff.c          **** 				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
 5189               	.LM522:
 5190 1a92 F801      		movw r30,r16
 5191 1a94 8385      		ldd r24,Z+11
 5192 1a96 84FD      		sbrc r24,4
 5193 1a98 00C0      		rjmp .L379
2388:ff.c          **** 					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
 5195               	.LM523:
 5196 1a9a D1FE      		sbrs r13,1
 5197 1a9c 00C0      		rjmp .L372
2388:ff.c          **** 					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
 5199               	.LM524:
 5200 1a9e 80FD      		sbrc r24,0
 5201 1aa0 00C0      		rjmp .L380
 5202               	.L372:
2394:ff.c          **** 			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
 5204               	.LM525:
 5205 1aa2 63FE      		sbrs r6,3
 5206 1aa4 00C0      		rjmp .L374
2395:ff.c          **** 				mode |= FA__WRITTEN;
 5208               	.LM526:
 5209 1aa6 F0E2      		ldi r31,lo8(32)
 5210 1aa8 6F2A      		or r6,r31
 5211               	.L374:
2396:ff.c          **** 			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
 5213               	.LM527:
 5214 1aaa C980      		ldd r12,Y+1
 5215 1aac DA80      		ldd r13,Y+2
 5216 1aae F601      		movw r30,r12
 5217 1ab0 86A5      		ldd r24,Z+46
 5218 1ab2 97A5      		ldd r25,Z+47
 5219 1ab4 A0A9      		ldd r26,Z+48
 5220 1ab6 B1A9      		ldd r27,Z+49
 5221 1ab8 F701      		movw r30,r14
 5222 1aba 828F      		std Z+26,r24
 5223 1abc 938F      		std Z+27,r25
 5224 1abe A48F      		std Z+28,r26
 5225 1ac0 B58F      		std Z+29,r27
2397:ff.c          **** 			fp->dir_ptr = dir;
 5227               	.LM528:
 5228 1ac2 178F      		std Z+31,r17
 5229 1ac4 068F      		std Z+30,r16
2418:ff.c          **** 			fp->flag = mode;					/* File access mode */
 5231               	.LM529:
 5232 1ac6 6482      		std Z+4,r6
2419:ff.c          **** 			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
 5234               	.LM530:
 5235 1ac8 B801      		movw r22,r16
 5236 1aca F601      		movw r30,r12
 5237 1acc 8081      		ld r24,Z
 5238 1ace 0E94 0000 		call ld_clust.isra.0
 5239 1ad2 F701      		movw r30,r14
 5240 1ad4 6687      		std Z+14,r22
 5241 1ad6 7787      		std Z+15,r23
 5242 1ad8 808B      		std Z+16,r24
 5243 1ada 918B      		std Z+17,r25
2420:ff.c          **** 			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 5245               	.LM531:
 5246 1adc F801      		movw r30,r16
 5247 1ade 878D      		ldd r24,Z+31
 5248 1ae0 468D      		ldd r20,Z+30
 5249 1ae2 50E0      		ldi r21,0
 5250 1ae4 60E0      		ldi r22,0
 5251 1ae6 70E0      		ldi r23,0
 5252 1ae8 BA01      		movw r22,r20
 5253 1aea 5527      		clr r21
 5254 1aec 4427      		clr r20
 5255 1aee 782B      		or r23,r24
 5256 1af0 848D      		ldd r24,Z+28
 5257 1af2 482B      		or r20,r24
 5258 1af4 958D      		ldd r25,Z+29
 5259 1af6 80E0      		ldi r24,0
 5260 1af8 A0E0      		ldi r26,0
 5261 1afa B0E0      		ldi r27,0
 5262 1afc 482B      		or r20,r24
 5263 1afe 592B      		or r21,r25
 5264 1b00 6A2B      		or r22,r26
 5265 1b02 7B2B      		or r23,r27
 5266 1b04 F701      		movw r30,r14
 5267 1b06 4287      		std Z+10,r20
 5268 1b08 5387      		std Z+11,r21
 5269 1b0a 6487      		std Z+12,r22
 5270 1b0c 7587      		std Z+13,r23
2421:ff.c          **** 			fp->fptr = 0;						/* File pointer */
 5272               	.LM532:
 5273 1b0e 1682      		std Z+6,__zero_reg__
 5274 1b10 1782      		std Z+7,__zero_reg__
 5275 1b12 1086      		std Z+8,__zero_reg__
 5276 1b14 1186      		std Z+9,__zero_reg__
2422:ff.c          **** 			fp->dsect = 0;
 5278               	.LM533:
 5279 1b16 168A      		std Z+22,__zero_reg__
 5280 1b18 178A      		std Z+23,__zero_reg__
 5281 1b1a 108E      		std Z+24,__zero_reg__
 5282 1b1c 118E      		std Z+25,__zero_reg__
2426:ff.c          **** 			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
 5284               	.LM534:
 5285 1b1e D182      		std Z+1,r13
 5286 1b20 C082      		st Z,r12
 5287 1b22 F601      		movw r30,r12
 5288 1b24 8681      		ldd r24,Z+6
 5289 1b26 9781      		ldd r25,Z+7
 5290 1b28 F701      		movw r30,r14
 5291 1b2a 9383      		std Z+3,r25
 5292 1b2c 8283      		std Z+2,r24
 5293 1b2e 00C0      		rjmp .L387
 5294               	.L375:
2320:ff.c          **** 	if (!fp) return FR_INVALID_OBJECT;
 5296               	.LM535:
 5297 1b30 29E0      		ldi r18,lo8(9)
 5298 1b32 722E      		mov r7,r18
 5299 1b34 00C0      		rjmp .L387
 5300               	.L378:
 5301               	.LBB96:
2362:ff.c          **** 						res = FR_EXIST;
 5303               	.LM536:
 5304 1b36 88E0      		ldi r24,lo8(8)
 5305 1b38 00C0      		rjmp .L373
 5306               	.L379:
 5307               	.LBE96:
2386:ff.c          **** 					res = FR_NO_FILE;
 5309               	.LM537:
 5310 1b3a 84E0      		ldi r24,lo8(4)
 5311 1b3c 00C0      		rjmp .L373
 5312               	.L380:
2389:ff.c          **** 						res = FR_DENIED;
 5314               	.LM538:
 5315 1b3e 87E0      		ldi r24,lo8(7)
 5316               	.L373:
2320:ff.c          **** 	if (!fp) return FR_INVALID_OBJECT;
 5318               	.LM539:
 5319 1b40 782E      		mov r7,r24
 5320               	.L387:
2431:ff.c          **** }
 5322               	.LM540:
 5323 1b42 872D      		mov r24,r7
 5324               	/* epilogue start */
 5325 1b44 A496      		adiw r28,36
 5326 1b46 0FB6      		in __tmp_reg__,__SREG__
 5327 1b48 F894      		cli
 5328 1b4a DEBF      		out __SP_H__,r29
 5329 1b4c 0FBE      		out __SREG__,__tmp_reg__
 5330 1b4e CDBF      		out __SP_L__,r28
 5331 1b50 DF91      		pop r29
 5332 1b52 CF91      		pop r28
 5333 1b54 1F91      		pop r17
 5334 1b56 0F91      		pop r16
 5335 1b58 FF90      		pop r15
 5336 1b5a EF90      		pop r14
 5337 1b5c DF90      		pop r13
 5338 1b5e CF90      		pop r12
 5339 1b60 BF90      		pop r11
 5340 1b62 AF90      		pop r10
 5341 1b64 9F90      		pop r9
 5342 1b66 8F90      		pop r8
 5343 1b68 7F90      		pop r7
 5344 1b6a 6F90      		pop r6
 5345 1b6c 5F90      		pop r5
 5346 1b6e 4F90      		pop r4
 5347 1b70 3F90      		pop r3
 5348 1b72 2F90      		pop r2
 5349 1b74 0895      		ret
 5362               	.Lscope22:
 5364               		.stabd	78,0,0
 5369               	.global	f_read
 5371               	f_read:
 5372               		.stabd	46,0,0
2446:ff.c          **** {
 5374               	.LM541:
 5375               	.LFBB23:
 5376 1b76 2F92      		push r2
 5377 1b78 3F92      		push r3
 5378 1b7a 4F92      		push r4
 5379 1b7c 5F92      		push r5
 5380 1b7e 6F92      		push r6
 5381 1b80 7F92      		push r7
 5382 1b82 8F92      		push r8
 5383 1b84 9F92      		push r9
 5384 1b86 AF92      		push r10
 5385 1b88 BF92      		push r11
 5386 1b8a CF92      		push r12
 5387 1b8c DF92      		push r13
 5388 1b8e EF92      		push r14
 5389 1b90 FF92      		push r15
 5390 1b92 0F93      		push r16
 5391 1b94 1F93      		push r17
 5392 1b96 CF93      		push r28
 5393 1b98 DF93      		push r29
 5394 1b9a 00D0      		rcall .
 5395 1b9c 00D0      		rcall .
 5396 1b9e CDB7      		in r28,__SP_L__
 5397 1ba0 DEB7      		in r29,__SP_H__
 5398               	/* prologue: function */
 5399               	/* frame size = 4 */
 5400               	/* stack size = 22 */
 5401               	.L__stack_usage = 22
 5402 1ba2 9C83      		std Y+4,r25
 5403 1ba4 8B83      		std Y+3,r24
 5404 1ba6 062F      		mov r16,r22
 5405 1ba8 B72E      		mov r11,r23
 5406 1baa 7A01      		movw r14,r20
 5407 1bac 3A83      		std Y+2,r19
 5408 1bae 2983      		std Y+1,r18
2453:ff.c          **** 	*br = 0;	/* Clear read byte counter */
 5410               	.LM542:
 5411 1bb0 D901      		movw r26,r18
 5412 1bb2 1D92      		st X+,__zero_reg__
 5413 1bb4 1C92      		st X,__zero_reg__
2455:ff.c          **** 	res = validate(fp);							/* Check validity */
 5415               	.LM543:
 5416 1bb6 0E94 0000 		call validate
 5417 1bba 182F      		mov r17,r24
2456:ff.c          **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 5419               	.LM544:
 5420 1bbc 8111      		cpse r24,__zero_reg__
 5421 1bbe 00C0      		rjmp .L401
2457:ff.c          **** 	if (fp->flag & FA__ERROR)					/* Aborted file? */
 5423               	.LM545:
 5424 1bc0 EB81      		ldd r30,Y+3
 5425 1bc2 FC81      		ldd r31,Y+4
 5426 1bc4 8481      		ldd r24,Z+4
 5427 1bc6 87FD      		sbrc r24,7
 5428 1bc8 00C0      		rjmp .L421
2459:ff.c          **** 	if (!(fp->flag & FA_READ)) 					/* Check access mode */
 5430               	.LM546:
 5431 1bca 80FF      		sbrs r24,0
 5432 1bcc 00C0      		rjmp .L422
2461:ff.c          **** 	remain = fp->fsize - fp->fptr;
 5434               	.LM547:
 5435 1bce 8285      		ldd r24,Z+10
 5436 1bd0 9385      		ldd r25,Z+11
 5437 1bd2 A485      		ldd r26,Z+12
 5438 1bd4 B585      		ldd r27,Z+13
 5439 1bd6 4681      		ldd r20,Z+6
 5440 1bd8 5781      		ldd r21,Z+7
 5441 1bda 6085      		ldd r22,Z+8
 5442 1bdc 7185      		ldd r23,Z+9
 5443 1bde 841B      		sub r24,r20
 5444 1be0 950B      		sbc r25,r21
 5445 1be2 A60B      		sbc r26,r22
 5446 1be4 B70B      		sbc r27,r23
2462:ff.c          **** 	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 5448               	.LM548:
 5449 1be6 A701      		movw r20,r14
 5450 1be8 60E0      		ldi r22,0
 5451 1bea 70E0      		ldi r23,0
 5452 1bec 8417      		cp r24,r20
 5453 1bee 9507      		cpc r25,r21
 5454 1bf0 A607      		cpc r26,r22
 5455 1bf2 B707      		cpc r27,r23
 5456 1bf4 00F4      		brsh .L402
2462:ff.c          **** 	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 5458               	.LM549:
 5459 1bf6 7C01      		movw r14,r24
 5460               	.L402:
2446:ff.c          **** {
 5462               	.LM550:
 5463 1bf8 C02E      		mov r12,r16
 5464 1bfa DB2C      		mov r13,r11
2513:ff.c          **** 				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
 5466               	.LM551:
 5467 1bfc 8B80      		ldd r8,Y+3
 5468 1bfe 9C80      		ldd r9,Y+4
 5469 1c00 F0E2      		ldi r31,32
 5470 1c02 8F0E      		add r8,r31
 5471 1c04 911C      		adc r9,__zero_reg__
 5472 1c06 00C0      		rjmp .L403
 5473               	.L420:
2466:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
 5475               	.LM552:
 5476 1c08 AB81      		ldd r26,Y+3
 5477 1c0a BC81      		ldd r27,Y+4
 5478 1c0c 1696      		adiw r26,6
 5479 1c0e 4D91      		ld r20,X+
 5480 1c10 5D91      		ld r21,X+
 5481 1c12 6D91      		ld r22,X+
 5482 1c14 7C91      		ld r23,X
 5483 1c16 1997      		sbiw r26,6+3
 5484 1c18 DB01      		movw r26,r22
 5485 1c1a CA01      		movw r24,r20
 5486 1c1c 9170      		andi r25,1
 5487 1c1e AA27      		clr r26
 5488 1c20 BB27      		clr r27
 5489 1c22 892B      		or r24,r25
 5490 1c24 8A2B      		or r24,r26
 5491 1c26 8B2B      		or r24,r27
 5492 1c28 01F0      		breq .+2
 5493 1c2a 00C0      		rjmp .L404
2467:ff.c          **** 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 5495               	.LM553:
 5496 1c2c EB81      		ldd r30,Y+3
 5497 1c2e FC81      		ldd r31,Y+4
 5498 1c30 8081      		ld r24,Z
 5499 1c32 9181      		ldd r25,Z+1
 5500 1c34 2A01      		movw r4,r20
 5501 1c36 3B01      		movw r6,r22
 5502 1c38 A9E0      		ldi r26,9
 5503               		1:
 5504 1c3a 7694      		lsr r7
 5505 1c3c 6794      		ror r6
 5506 1c3e 5794      		ror r5
 5507 1c40 4794      		ror r4
 5508 1c42 AA95      		dec r26
 5509 1c44 01F4      		brne 1b
 5510 1c46 DC01      		movw r26,r24
 5511 1c48 1296      		adiw r26,2
 5512 1c4a 0C91      		ld r16,X
 5513 1c4c 0150      		subi r16,lo8(-(-1))
 5514 1c4e 0421      		and r16,r4
2468:ff.c          **** 			if (!csect) {						/* On the cluster boundary? */
 5516               	.LM554:
 5517 1c50 01F4      		brne .L405
2469:ff.c          **** 				if (fp->fptr == 0) {			/* On the top of the file? */
 5519               	.LM555:
 5520 1c52 452B      		or r20,r21
 5521 1c54 462B      		or r20,r22
 5522 1c56 472B      		or r20,r23
 5523 1c58 01F4      		brne .L406
2470:ff.c          **** 					clst = fp->sclust;			/* Follow from the origin */
 5525               	.LM556:
 5526 1c5a 6685      		ldd r22,Z+14
 5527 1c5c 7785      		ldd r23,Z+15
 5528 1c5e 8089      		ldd r24,Z+16
 5529 1c60 9189      		ldd r25,Z+17
 5530 1c62 00C0      		rjmp .L407
 5531               	.L406:
2477:ff.c          **** 						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
 5533               	.LM557:
 5534 1c64 EB81      		ldd r30,Y+3
 5535 1c66 FC81      		ldd r31,Y+4
 5536 1c68 4289      		ldd r20,Z+18
 5537 1c6a 5389      		ldd r21,Z+19
 5538 1c6c 6489      		ldd r22,Z+20
 5539 1c6e 7589      		ldd r23,Z+21
 5540 1c70 0E94 0000 		call get_fat
 5541               	.L407:
2479:ff.c          **** 				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
 5543               	.LM558:
 5544 1c74 6230      		cpi r22,2
 5545 1c76 7105      		cpc r23,__zero_reg__
 5546 1c78 8105      		cpc r24,__zero_reg__
 5547 1c7a 9105      		cpc r25,__zero_reg__
 5548 1c7c 00F4      		brsh .L408
 5549 1c7e 00C0      		rjmp .L432
 5550               	.L408:
2480:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 5552               	.LM559:
 5553 1c80 6F3F      		cpi r22,-1
 5554 1c82 BFEF      		ldi r27,-1
 5555 1c84 7B07      		cpc r23,r27
 5556 1c86 8B07      		cpc r24,r27
 5557 1c88 9B07      		cpc r25,r27
 5558 1c8a 01F4      		brne .L409
 5559 1c8c 00C0      		rjmp .L433
 5560               	.L409:
2481:ff.c          **** 				fp->clust = clst;				/* Update current cluster */
 5562               	.LM560:
 5563 1c8e AB81      		ldd r26,Y+3
 5564 1c90 BC81      		ldd r27,Y+4
 5565 1c92 5296      		adiw r26,18
 5566 1c94 6D93      		st X+,r22
 5567 1c96 7D93      		st X+,r23
 5568 1c98 8D93      		st X+,r24
 5569 1c9a 9C93      		st X,r25
 5570 1c9c 5597      		sbiw r26,18+3
 5571               	.L405:
2483:ff.c          **** 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
 5573               	.LM561:
 5574 1c9e EB81      		ldd r30,Y+3
 5575 1ca0 FC81      		ldd r31,Y+4
 5576 1ca2 6080      		ld r6,Z
 5577 1ca4 7180      		ldd r7,Z+1
 5578 1ca6 4289      		ldd r20,Z+18
 5579 1ca8 5389      		ldd r21,Z+19
 5580 1caa 6489      		ldd r22,Z+20
 5581 1cac 7589      		ldd r23,Z+21
 5582 1cae C301      		movw r24,r6
 5583 1cb0 0E94 0000 		call clust2sect
2484:ff.c          **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 5585               	.LM562:
 5586 1cb4 6115      		cp r22,__zero_reg__
 5587 1cb6 7105      		cpc r23,__zero_reg__
 5588 1cb8 8105      		cpc r24,__zero_reg__
 5589 1cba 9105      		cpc r25,__zero_reg__
 5590 1cbc 01F4      		brne .L410
 5591               	.L432:
2484:ff.c          **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 5593               	.LM563:
 5594 1cbe AB81      		ldd r26,Y+3
 5595 1cc0 BC81      		ldd r27,Y+4
 5596 1cc2 1496      		adiw r26,4
 5597 1cc4 8C91      		ld r24,X
 5598 1cc6 1497      		sbiw r26,4
 5599 1cc8 8068      		ori r24,lo8(-128)
 5600 1cca 1496      		adiw r26,4
 5601 1ccc 8C93      		st X,r24
 5602 1cce 00C0      		rjmp .L421
 5603               	.L410:
2485:ff.c          **** 			sect += csect;
 5605               	.LM564:
 5606 1cd0 1B01      		movw r2,r22
 5607 1cd2 2C01      		movw r4,r24
 5608 1cd4 200E      		add r2,r16
 5609 1cd6 311C      		adc r3,__zero_reg__
 5610 1cd8 411C      		adc r4,__zero_reg__
 5611 1cda 511C      		adc r5,__zero_reg__
2486:ff.c          **** 			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
 5613               	.LM565:
 5614 1cdc 5701      		movw r10,r14
 5615 1cde AB2C      		mov r10,r11
 5616 1ce0 BB24      		clr r11
 5617 1ce2 A694      		lsr r10
2487:ff.c          **** 			if (cc) {							/* Read maximum contiguous sectors directly */
 5619               	.LM566:
 5620 1ce4 A114      		cp r10,__zero_reg__
 5621 1ce6 B104      		cpc r11,__zero_reg__
 5622 1ce8 01F4      		brne .+2
 5623 1cea 00C0      		rjmp .L411
2488:ff.c          **** 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 5625               	.LM567:
 5626 1cec F301      		movw r30,r6
 5627 1cee 2281      		ldd r18,Z+2
 5628 1cf0 802F      		mov r24,r16
 5629 1cf2 90E0      		ldi r25,0
 5630 1cf4 A501      		movw r20,r10
 5631 1cf6 480F      		add r20,r24
 5632 1cf8 591F      		adc r21,r25
 5633 1cfa 30E0      		ldi r19,0
 5634 1cfc 2417      		cp r18,r20
 5635 1cfe 3507      		cpc r19,r21
 5636 1d00 00F4      		brsh .L412
2489:ff.c          **** 					cc = fp->fs->csize - csect;
 5638               	.LM568:
 5639 1d02 5901      		movw r10,r18
 5640 1d04 A81A      		sub r10,r24
 5641 1d06 B90A      		sbc r11,r25
 5642               	.L412:
2490:ff.c          **** 				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
 5644               	.LM569:
 5645 1d08 0A2D      		mov r16,r10
 5646 1d0a A201      		movw r20,r4
 5647 1d0c 9101      		movw r18,r2
 5648 1d0e B601      		movw r22,r12
 5649 1d10 D301      		movw r26,r6
 5650 1d12 1196      		adiw r26,1
 5651 1d14 8C91      		ld r24,X
 5652 1d16 0E94 0000 		call disk_read
 5653 1d1a EB81      		ldd r30,Y+3
 5654 1d1c FC81      		ldd r31,Y+4
 5655 1d1e 9481      		ldd r25,Z+4
 5656 1d20 8823      		tst r24
 5657 1d22 01F0      		breq .L413
2491:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 5659               	.LM570:
 5660 1d24 9068      		ori r25,lo8(-128)
 5661 1d26 9483      		std Z+4,r25
 5662 1d28 00C0      		rjmp .L434
 5663               	.L413:
2497:ff.c          **** 				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
 5665               	.LM571:
 5666 1d2a 96FF      		sbrs r25,6
 5667 1d2c 00C0      		rjmp .L414
2497:ff.c          **** 				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
 5669               	.LM572:
 5670 1d2e EB81      		ldd r30,Y+3
 5671 1d30 FC81      		ldd r31,Y+4
 5672 1d32 8689      		ldd r24,Z+22
 5673 1d34 9789      		ldd r25,Z+23
 5674 1d36 A08D      		ldd r26,Z+24
 5675 1d38 B18D      		ldd r27,Z+25
 5676 1d3a 8219      		sub r24,r2
 5677 1d3c 9309      		sbc r25,r3
 5678 1d3e A409      		sbc r26,r4
 5679 1d40 B509      		sbc r27,r5
 5680 1d42 A501      		movw r20,r10
 5681 1d44 60E0      		ldi r22,0
 5682 1d46 70E0      		ldi r23,0
 5683 1d48 8417      		cp r24,r20
 5684 1d4a 9507      		cpc r25,r21
 5685 1d4c A607      		cpc r26,r22
 5686 1d4e B707      		cpc r27,r23
 5687 1d50 00F4      		brsh .L414
2498:ff.c          **** 					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
 5689               	.LM573:
 5690 1d52 982F      		mov r25,r24
 5691 1d54 8827      		clr r24
 5692 1d56 990F      		lsl r25
 5693 1d58 40E0      		ldi r20,0
 5694 1d5a 52E0      		ldi r21,lo8(2)
 5695 1d5c B401      		movw r22,r8
 5696 1d5e 8C0D      		add r24,r12
 5697 1d60 9D1D      		adc r25,r13
 5698 1d62 0E94 0000 		call mem_cpy
 5699               	.L414:
2501:ff.c          **** 				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
 5701               	.LM574:
 5702 1d66 BA2C      		mov r11,r10
 5703 1d68 AA24      		clr r10
 5704 1d6a BB0C      		lsl r11
2502:ff.c          **** 				continue;
 5706               	.LM575:
 5707 1d6c 00C0      		rjmp .L415
 5708               	.L411:
2505:ff.c          **** 			if (fp->dsect != sect) {			/* Load data sector if not in cache */
 5710               	.LM576:
 5711 1d6e AB81      		ldd r26,Y+3
 5712 1d70 BC81      		ldd r27,Y+4
 5713 1d72 5696      		adiw r26,22
 5714 1d74 2D91      		ld r18,X+
 5715 1d76 3D91      		ld r19,X+
 5716 1d78 4D91      		ld r20,X+
 5717 1d7a 5C91      		ld r21,X
 5718 1d7c 5997      		sbiw r26,22+3
 5719 1d7e 2215      		cp r18,r2
 5720 1d80 3305      		cpc r19,r3
 5721 1d82 4405      		cpc r20,r4
 5722 1d84 5505      		cpc r21,r5
 5723 1d86 01F0      		breq .L416
2507:ff.c          **** 				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
 5725               	.LM577:
 5726 1d88 1496      		adiw r26,4
 5727 1d8a 8C91      		ld r24,X
 5728 1d8c 86FF      		sbrs r24,6
 5729 1d8e 00C0      		rjmp .L417
2508:ff.c          **** 					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 5731               	.LM578:
 5732 1d90 01E0      		ldi r16,lo8(1)
 5733 1d92 B401      		movw r22,r8
 5734 1d94 F301      		movw r30,r6
 5735 1d96 8181      		ldd r24,Z+1
 5736 1d98 0E94 0000 		call disk_write
 5737 1d9c AB81      		ldd r26,Y+3
 5738 1d9e BC81      		ldd r27,Y+4
 5739 1da0 1496      		adiw r26,4
 5740 1da2 9C91      		ld r25,X
 5741 1da4 1497      		sbiw r26,4
 5742 1da6 8823      		tst r24
 5743 1da8 01F0      		breq .L418
2509:ff.c          **** 						ABORT(fp->fs, FR_DISK_ERR);
 5745               	.LM579:
 5746 1daa 9068      		ori r25,lo8(-128)
 5747 1dac 1496      		adiw r26,4
 5748 1dae 9C93      		st X,r25
 5749 1db0 00C0      		rjmp .L434
 5750               	.L418:
2510:ff.c          **** 					fp->flag &= ~FA__DIRTY;
 5752               	.LM580:
 5753 1db2 9F7B      		andi r25,lo8(-65)
 5754 1db4 EB81      		ldd r30,Y+3
 5755 1db6 FC81      		ldd r31,Y+4
 5756 1db8 9483      		std Z+4,r25
 5757               	.L417:
2513:ff.c          **** 				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
 5759               	.LM581:
 5760 1dba AB81      		ldd r26,Y+3
 5761 1dbc BC81      		ldd r27,Y+4
 5762 1dbe ED91      		ld r30,X+
 5763 1dc0 FC91      		ld r31,X
 5764 1dc2 01E0      		ldi r16,lo8(1)
 5765 1dc4 A201      		movw r20,r4
 5766 1dc6 9101      		movw r18,r2
 5767 1dc8 B401      		movw r22,r8
 5768 1dca 8181      		ldd r24,Z+1
 5769 1dcc 0E94 0000 		call disk_read
 5770 1dd0 8823      		tst r24
 5771 1dd2 01F0      		breq .L416
 5772               	.L433:
2514:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 5774               	.LM582:
 5775 1dd4 EB81      		ldd r30,Y+3
 5776 1dd6 FC81      		ldd r31,Y+4
 5777 1dd8 8481      		ldd r24,Z+4
 5778 1dda 8068      		ori r24,lo8(-128)
 5779 1ddc 8483      		std Z+4,r24
 5780               	.L434:
 5781 1dde 11E0      		ldi r17,lo8(1)
 5782 1de0 00C0      		rjmp .L401
 5783               	.L416:
2517:ff.c          **** 			fp->dsect = sect;
 5785               	.LM583:
 5786 1de2 AB81      		ldd r26,Y+3
 5787 1de4 BC81      		ldd r27,Y+4
 5788 1de6 5696      		adiw r26,22
 5789 1de8 2D92      		st X+,r2
 5790 1dea 3D92      		st X+,r3
 5791 1dec 4D92      		st X+,r4
 5792 1dee 5C92      		st X,r5
 5793 1df0 5997      		sbiw r26,22+3
 5794               	.L404:
2519:ff.c          **** 		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer 
 5796               	.LM584:
 5797 1df2 EB81      		ldd r30,Y+3
 5798 1df4 FC81      		ldd r31,Y+4
 5799 1df6 8681      		ldd r24,Z+6
 5800 1df8 9781      		ldd r25,Z+7
 5801 1dfa A085      		ldd r26,Z+8
 5802 1dfc B185      		ldd r27,Z+9
 5803 1dfe 9170      		andi r25,1
 5804 1e00 AA27      		clr r26
 5805 1e02 BB27      		clr r27
 5806 1e04 20E0      		ldi r18,0
 5807 1e06 32E0      		ldi r19,lo8(2)
 5808 1e08 281B      		sub r18,r24
 5809 1e0a 390B      		sbc r19,r25
 5810 1e0c 5701      		movw r10,r14
 5811 1e0e 2E15      		cp r18,r14
 5812 1e10 3F05      		cpc r19,r15
 5813 1e12 00F4      		brsh .L419
 5814 1e14 5901      		movw r10,r18
 5815               	.L419:
2526:ff.c          **** 		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
 5817               	.LM585:
 5818 1e16 BC01      		movw r22,r24
 5819 1e18 605E      		subi r22,-32
 5820 1e1a 7F4F      		sbci r23,-1
 5821 1e1c 8B81      		ldd r24,Y+3
 5822 1e1e 9C81      		ldd r25,Y+4
 5823 1e20 680F      		add r22,r24
 5824 1e22 791F      		adc r23,r25
 5825 1e24 A501      		movw r20,r10
 5826 1e26 C601      		movw r24,r12
 5827 1e28 0E94 0000 		call mem_cpy
 5828               	.L415:
2465:ff.c          **** 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 5830               	.LM586:
 5831 1e2c CA0C      		add r12,r10
 5832 1e2e DB1C      		adc r13,r11
 5833 1e30 EB81      		ldd r30,Y+3
 5834 1e32 FC81      		ldd r31,Y+4
 5835 1e34 8681      		ldd r24,Z+6
 5836 1e36 9781      		ldd r25,Z+7
 5837 1e38 A085      		ldd r26,Z+8
 5838 1e3a B185      		ldd r27,Z+9
 5839 1e3c 8A0D      		add r24,r10
 5840 1e3e 9B1D      		adc r25,r11
 5841 1e40 A11D      		adc r26,__zero_reg__
 5842 1e42 B11D      		adc r27,__zero_reg__
 5843 1e44 8683      		std Z+6,r24
 5844 1e46 9783      		std Z+7,r25
 5845 1e48 A087      		std Z+8,r26
 5846 1e4a B187      		std Z+9,r27
 5847 1e4c A981      		ldd r26,Y+1
 5848 1e4e BA81      		ldd r27,Y+2
 5849 1e50 8D91      		ld r24,X+
 5850 1e52 9C91      		ld r25,X
 5851 1e54 1197      		sbiw r26,1
 5852 1e56 8A0D      		add r24,r10
 5853 1e58 9B1D      		adc r25,r11
 5854 1e5a 8D93      		st X+,r24
 5855 1e5c 9C93      		st X,r25
 5856 1e5e EA18      		sub r14,r10
 5857 1e60 FB08      		sbc r15,r11
 5858               	.L403:
2464:ff.c          **** 	for ( ;  btr;								/* Repeat until all data read */
 5860               	.LM587:
 5861 1e62 E114      		cp r14,__zero_reg__
 5862 1e64 F104      		cpc r15,__zero_reg__
 5863 1e66 01F0      		breq .+2
 5864 1e68 00C0      		rjmp .L420
 5865 1e6a 00C0      		rjmp .L401
 5866               	.L421:
2458:ff.c          **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
 5868               	.LM588:
 5869 1e6c 12E0      		ldi r17,lo8(2)
 5870 1e6e 00C0      		rjmp .L401
 5871               	.L422:
2460:ff.c          **** 		LEAVE_FF(fp->fs, FR_DENIED);
 5873               	.LM589:
 5874 1e70 17E0      		ldi r17,lo8(7)
 5875               	.L401:
2531:ff.c          **** }
 5877               	.LM590:
 5878 1e72 812F      		mov r24,r17
 5879               	/* epilogue start */
 5880 1e74 0F90      		pop __tmp_reg__
 5881 1e76 0F90      		pop __tmp_reg__
 5882 1e78 0F90      		pop __tmp_reg__
 5883 1e7a 0F90      		pop __tmp_reg__
 5884 1e7c DF91      		pop r29
 5885 1e7e CF91      		pop r28
 5886 1e80 1F91      		pop r17
 5887 1e82 0F91      		pop r16
 5888 1e84 FF90      		pop r15
 5889 1e86 EF90      		pop r14
 5890 1e88 DF90      		pop r13
 5891 1e8a CF90      		pop r12
 5892 1e8c BF90      		pop r11
 5893 1e8e AF90      		pop r10
 5894 1e90 9F90      		pop r9
 5895 1e92 8F90      		pop r8
 5896 1e94 7F90      		pop r7
 5897 1e96 6F90      		pop r6
 5898 1e98 5F90      		pop r5
 5899 1e9a 4F90      		pop r4
 5900 1e9c 3F90      		pop r3
 5901 1e9e 2F90      		pop r2
 5902 1ea0 0895      		ret
 5912               	.Lscope23:
 5914               		.stabd	78,0,0
 5919               	.global	f_write
 5921               	f_write:
 5922               		.stabd	46,0,0
2547:ff.c          **** {
 5924               	.LM591:
 5925               	.LFBB24:
 5926 1ea2 3F92      		push r3
 5927 1ea4 4F92      		push r4
 5928 1ea6 5F92      		push r5
 5929 1ea8 6F92      		push r6
 5930 1eaa 7F92      		push r7
 5931 1eac 8F92      		push r8
 5932 1eae 9F92      		push r9
 5933 1eb0 AF92      		push r10
 5934 1eb2 BF92      		push r11
 5935 1eb4 CF92      		push r12
 5936 1eb6 DF92      		push r13
 5937 1eb8 EF92      		push r14
 5938 1eba FF92      		push r15
 5939 1ebc 0F93      		push r16
 5940 1ebe 1F93      		push r17
 5941 1ec0 CF93      		push r28
 5942 1ec2 DF93      		push r29
 5943 1ec4 00D0      		rcall .
 5944 1ec6 00D0      		rcall .
 5945 1ec8 00D0      		rcall .
 5946 1eca CDB7      		in r28,__SP_L__
 5947 1ecc DEB7      		in r29,__SP_H__
 5948               	/* prologue: function */
 5949               	/* frame size = 6 */
 5950               	/* stack size = 23 */
 5951               	.L__stack_usage = 23
 5952 1ece 9E83      		std Y+6,r25
 5953 1ed0 8D83      		std Y+5,r24
 5954 1ed2 B62E      		mov r11,r22
 5955 1ed4 A72E      		mov r10,r23
 5956 1ed6 7A01      		movw r14,r20
 5957 1ed8 3C83      		std Y+4,r19
 5958 1eda 2B83      		std Y+3,r18
2555:ff.c          **** 	*bw = 0;	/* Clear write byte counter */
 5960               	.LM592:
 5961 1edc D901      		movw r26,r18
 5962 1ede 1D92      		st X+,__zero_reg__
 5963 1ee0 1C92      		st X,__zero_reg__
2557:ff.c          **** 	res = validate(fp);						/* Check validity */
 5965               	.LM593:
 5966 1ee2 0E94 0000 		call validate
 5967 1ee6 182F      		mov r17,r24
2558:ff.c          **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 5969               	.LM594:
 5970 1ee8 8111      		cpse r24,__zero_reg__
 5971 1eea 00C0      		rjmp .L436
2559:ff.c          **** 	if (fp->flag & FA__ERROR)				/* Aborted file? */
 5973               	.LM595:
 5974 1eec ED81      		ldd r30,Y+5
 5975 1eee FE81      		ldd r31,Y+6
 5976 1ef0 8481      		ldd r24,Z+4
 5977 1ef2 87FD      		sbrc r24,7
 5978 1ef4 00C0      		rjmp .L470
2561:ff.c          **** 	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 5980               	.LM596:
 5981 1ef6 81FF      		sbrs r24,1
 5982 1ef8 00C0      		rjmp .L461
2563:ff.c          **** 	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
 5984               	.LM597:
 5985 1efa 8285      		ldd r24,Z+10
 5986 1efc 9385      		ldd r25,Z+11
 5987 1efe A485      		ldd r26,Z+12
 5988 1f00 B585      		ldd r27,Z+13
 5989 1f02 AC01      		movw r20,r24
 5990 1f04 BD01      		movw r22,r26
 5991 1f06 4E0D      		add r20,r14
 5992 1f08 5F1D      		adc r21,r15
 5993 1f0a 611D      		adc r22,__zero_reg__
 5994 1f0c 711D      		adc r23,__zero_reg__
 5995 1f0e 4817      		cp r20,r24
 5996 1f10 5907      		cpc r21,r25
 5997 1f12 6A07      		cpc r22,r26
 5998 1f14 7B07      		cpc r23,r27
 5999 1f16 00F4      		brsh .L437
 6000 1f18 E12C      		mov r14,__zero_reg__
 6001 1f1a F12C      		mov r15,__zero_reg__
 6002               	.L437:
2563:ff.c          **** 	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
 6004               	.LM598:
 6005 1f1c CB2C      		mov r12,r11
 6006 1f1e DA2C      		mov r13,r10
2628:ff.c          **** 					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
 6008               	.LM599:
 6009 1f20 8D80      		ldd r8,Y+5
 6010 1f22 9E80      		ldd r9,Y+6
 6011 1f24 F0E2      		ldi r31,32
 6012 1f26 8F0E      		add r8,r31
 6013 1f28 911C      		adc r9,__zero_reg__
 6014 1f2a 00C0      		rjmp .L438
 6015               	.L458:
2567:ff.c          **** 		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
 6017               	.LM600:
 6018 1f2c AD81      		ldd r26,Y+5
 6019 1f2e BE81      		ldd r27,Y+6
 6020 1f30 1696      		adiw r26,6
 6021 1f32 4D91      		ld r20,X+
 6022 1f34 5D91      		ld r21,X+
 6023 1f36 6D91      		ld r22,X+
 6024 1f38 7C91      		ld r23,X
 6025 1f3a 1997      		sbiw r26,6+3
 6026 1f3c DB01      		movw r26,r22
 6027 1f3e CA01      		movw r24,r20
 6028 1f40 9170      		andi r25,1
 6029 1f42 AA27      		clr r26
 6030 1f44 BB27      		clr r27
 6031 1f46 892B      		or r24,r25
 6032 1f48 8A2B      		or r24,r26
 6033 1f4a 8B2B      		or r24,r27
 6034 1f4c 01F0      		breq .+2
 6035 1f4e 00C0      		rjmp .L439
2568:ff.c          **** 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 6037               	.LM601:
 6038 1f50 AD81      		ldd r26,Y+5
 6039 1f52 BE81      		ldd r27,Y+6
 6040 1f54 ED91      		ld r30,X+
 6041 1f56 FC91      		ld r31,X
 6042 1f58 DB01      		movw r26,r22
 6043 1f5a CA01      		movw r24,r20
 6044 1f5c 29E0      		ldi r18,9
 6045               		1:
 6046 1f5e B695      		lsr r27
 6047 1f60 A795      		ror r26
 6048 1f62 9795      		ror r25
 6049 1f64 8795      		ror r24
 6050 1f66 2A95      		dec r18
 6051 1f68 01F4      		brne 1b
 6052 1f6a 3280      		ldd r3,Z+2
 6053 1f6c 3A94      		dec r3
 6054 1f6e 3822      		and r3,r24
2569:ff.c          **** 			if (!csect) {					/* On the cluster boundary? */
 6056               	.LM602:
 6057 1f70 01F0      		breq .+2
 6058 1f72 00C0      		rjmp .L440
2571:ff.c          **** 					clst = fp->sclust;		/* Follow from the origin */
 6060               	.LM603:
 6061 1f74 AD81      		ldd r26,Y+5
 6062 1f76 BE81      		ldd r27,Y+6
2570:ff.c          **** 				if (fp->fptr == 0) {		/* On the top of the file? */
 6064               	.LM604:
 6065 1f78 452B      		or r20,r21
 6066 1f7a 462B      		or r20,r22
 6067 1f7c 472B      		or r20,r23
 6068 1f7e 01F4      		brne .L441
2571:ff.c          **** 					clst = fp->sclust;		/* Follow from the origin */
 6070               	.LM605:
 6071 1f80 1E96      		adiw r26,14
 6072 1f82 6D91      		ld r22,X+
 6073 1f84 7D91      		ld r23,X+
 6074 1f86 8D91      		ld r24,X+
 6075 1f88 9C91      		ld r25,X
 6076 1f8a 5197      		sbiw r26,14+3
2572:ff.c          **** 					if (clst == 0)			/* When no cluster is allocated, */
 6078               	.LM606:
 6079 1f8c 6115      		cp r22,__zero_reg__
 6080 1f8e 7105      		cpc r23,__zero_reg__
 6081 1f90 8105      		cpc r24,__zero_reg__
 6082 1f92 9105      		cpc r25,__zero_reg__
 6083 1f94 01F4      		brne .L442
2573:ff.c          **** 						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
 6085               	.LM607:
 6086 1f96 40E0      		ldi r20,0
 6087 1f98 50E0      		ldi r21,0
 6088 1f9a BA01      		movw r22,r20
 6089 1f9c CF01      		movw r24,r30
 6090 1f9e 0E94 0000 		call create_chain
 6091 1fa2 ED81      		ldd r30,Y+5
 6092 1fa4 FE81      		ldd r31,Y+6
 6093 1fa6 6687      		std Z+14,r22
 6094 1fa8 7787      		std Z+15,r23
 6095 1faa 808B      		std Z+16,r24
 6096 1fac 918B      		std Z+17,r25
 6097 1fae 00C0      		rjmp .L443
 6098               	.L441:
2580:ff.c          **** 						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 6100               	.LM608:
 6101 1fb0 5296      		adiw r26,18
 6102 1fb2 4D91      		ld r20,X+
 6103 1fb4 5D91      		ld r21,X+
 6104 1fb6 6D91      		ld r22,X+
 6105 1fb8 7C91      		ld r23,X
 6106 1fba 5597      		sbiw r26,18+3
 6107 1fbc CF01      		movw r24,r30
 6108 1fbe 0E94 0000 		call create_chain
 6109               	.L443:
2582:ff.c          **** 				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 6111               	.LM609:
 6112 1fc2 6115      		cp r22,__zero_reg__
 6113 1fc4 7105      		cpc r23,__zero_reg__
 6114 1fc6 8105      		cpc r24,__zero_reg__
 6115 1fc8 9105      		cpc r25,__zero_reg__
 6116 1fca 01F4      		brne .L442
 6117               	.L459:
2647:ff.c          **** 	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
 6119               	.LM610:
 6120 1fcc ED81      		ldd r30,Y+5
 6121 1fce FE81      		ldd r31,Y+6
 6122 1fd0 8681      		ldd r24,Z+6
 6123 1fd2 9781      		ldd r25,Z+7
 6124 1fd4 A085      		ldd r26,Z+8
 6125 1fd6 B185      		ldd r27,Z+9
 6126 1fd8 4285      		ldd r20,Z+10
 6127 1fda 5385      		ldd r21,Z+11
 6128 1fdc 6485      		ldd r22,Z+12
 6129 1fde 7585      		ldd r23,Z+13
 6130 1fe0 4817      		cp r20,r24
 6131 1fe2 5907      		cpc r21,r25
 6132 1fe4 6A07      		cpc r22,r26
 6133 1fe6 7B07      		cpc r23,r27
 6134 1fe8 00F4      		brsh .+2
 6135 1fea 00C0      		rjmp .L444
 6136 1fec 00C0      		rjmp .L445
 6137               	.L442:
 6138 1fee AD81      		ldd r26,Y+5
 6139 1ff0 BE81      		ldd r27,Y+6
 6140 1ff2 1496      		adiw r26,4
 6141 1ff4 2C91      		ld r18,X
 6142 1ff6 1497      		sbiw r26,4
2583:ff.c          **** 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 6144               	.LM611:
 6145 1ff8 6130      		cpi r22,1
 6146 1ffa 7105      		cpc r23,__zero_reg__
 6147 1ffc 8105      		cpc r24,__zero_reg__
 6148 1ffe 9105      		cpc r25,__zero_reg__
 6149 2000 01F4      		brne .L446
2583:ff.c          **** 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 6151               	.LM612:
 6152 2002 822F      		mov r24,r18
 6153 2004 00C0      		rjmp .L469
 6154               	.L446:
2584:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 6156               	.LM613:
 6157 2006 6F3F      		cpi r22,-1
 6158 2008 BFEF      		ldi r27,-1
 6159 200a 7B07      		cpc r23,r27
 6160 200c 8B07      		cpc r24,r27
 6161 200e 9B07      		cpc r25,r27
 6162 2010 01F4      		brne .L447
2584:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 6164               	.LM614:
 6165 2012 822F      		mov r24,r18
 6166 2014 8068      		ori r24,lo8(-128)
 6167 2016 ED81      		ldd r30,Y+5
 6168 2018 FE81      		ldd r31,Y+6
 6169 201a 00C0      		rjmp .L472
 6170               	.L447:
2585:ff.c          **** 				fp->clust = clst;			/* Update current cluster */
 6172               	.LM615:
 6173 201c AD81      		ldd r26,Y+5
 6174 201e BE81      		ldd r27,Y+6
 6175 2020 5296      		adiw r26,18
 6176 2022 6D93      		st X+,r22
 6177 2024 7D93      		st X+,r23
 6178 2026 8D93      		st X+,r24
 6179 2028 9C93      		st X,r25
 6180 202a 5597      		sbiw r26,18+3
 6181               	.L440:
2591:ff.c          **** 			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
 6183               	.LM616:
 6184 202c ED81      		ldd r30,Y+5
 6185 202e FE81      		ldd r31,Y+6
 6186 2030 8481      		ldd r24,Z+4
 6187 2032 86FF      		sbrs r24,6
 6188 2034 00C0      		rjmp .L448
2592:ff.c          **** 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 6190               	.LM617:
 6191 2036 2689      		ldd r18,Z+22
 6192 2038 3789      		ldd r19,Z+23
 6193 203a 408D      		ldd r20,Z+24
 6194 203c 518D      		ldd r21,Z+25
 6195 203e 0190      		ld __tmp_reg__,Z+
 6196 2040 F081      		ld r31,Z
 6197 2042 E02D      		mov r30,__tmp_reg__
 6198 2044 01E0      		ldi r16,lo8(1)
 6199 2046 B401      		movw r22,r8
 6200 2048 8181      		ldd r24,Z+1
 6201 204a 0E94 0000 		call disk_write
 6202 204e AD81      		ldd r26,Y+5
 6203 2050 BE81      		ldd r27,Y+6
 6204 2052 1496      		adiw r26,4
 6205 2054 9C91      		ld r25,X
 6206 2056 1497      		sbiw r26,4
 6207 2058 8823      		tst r24
 6208 205a 01F0      		breq .L449
2593:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 6210               	.LM618:
 6211 205c 9068      		ori r25,lo8(-128)
 6212 205e 1496      		adiw r26,4
 6213 2060 9C93      		st X,r25
 6214 2062 00C0      		rjmp .L473
 6215               	.L449:
2594:ff.c          **** 				fp->flag &= ~FA__DIRTY;
 6217               	.LM619:
 6218 2064 9F7B      		andi r25,lo8(-65)
 6219 2066 ED81      		ldd r30,Y+5
 6220 2068 FE81      		ldd r31,Y+6
 6221 206a 9483      		std Z+4,r25
 6222               	.L448:
2597:ff.c          **** 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
 6224               	.LM620:
 6225 206c AD81      		ldd r26,Y+5
 6226 206e BE81      		ldd r27,Y+6
 6227 2070 0D90      		ld __tmp_reg__,X+
 6228 2072 BC91      		ld r27,X
 6229 2074 A02D      		mov r26,__tmp_reg__
 6230 2076 BA83      		std Y+2,r27
 6231 2078 A983      		std Y+1,r26
 6232 207a ED81      		ldd r30,Y+5
 6233 207c FE81      		ldd r31,Y+6
 6234 207e 4289      		ldd r20,Z+18
 6235 2080 5389      		ldd r21,Z+19
 6236 2082 6489      		ldd r22,Z+20
 6237 2084 7589      		ldd r23,Z+21
 6238 2086 CD01      		movw r24,r26
 6239 2088 0E94 0000 		call clust2sect
2598:ff.c          **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 6241               	.LM621:
 6242 208c 6115      		cp r22,__zero_reg__
 6243 208e 7105      		cpc r23,__zero_reg__
 6244 2090 8105      		cpc r24,__zero_reg__
 6245 2092 9105      		cpc r25,__zero_reg__
 6246 2094 01F4      		brne .L450
2598:ff.c          **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 6248               	.LM622:
 6249 2096 AD81      		ldd r26,Y+5
 6250 2098 BE81      		ldd r27,Y+6
 6251 209a 1496      		adiw r26,4
 6252 209c 8C91      		ld r24,X
 6253 209e 1497      		sbiw r26,4
 6254               	.L469:
 6255 20a0 8068      		ori r24,lo8(-128)
 6256 20a2 1496      		adiw r26,4
 6257 20a4 8C93      		st X,r24
 6258               	.L470:
 6259 20a6 12E0      		ldi r17,lo8(2)
 6260 20a8 00C0      		rjmp .L436
 6261               	.L450:
2599:ff.c          **** 			sect += csect;
 6263               	.LM623:
 6264 20aa 2B01      		movw r4,r22
 6265 20ac 3C01      		movw r6,r24
 6266 20ae 430C      		add r4,r3
 6267 20b0 511C      		adc r5,__zero_reg__
 6268 20b2 611C      		adc r6,__zero_reg__
 6269 20b4 711C      		adc r7,__zero_reg__
2600:ff.c          **** 			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
 6271               	.LM624:
 6272 20b6 5701      		movw r10,r14
 6273 20b8 AB2C      		mov r10,r11
 6274 20ba BB24      		clr r11
 6275 20bc A694      		lsr r10
2601:ff.c          **** 			if (cc) {						/* Write maximum contiguous sectors directly */
 6277               	.LM625:
 6278 20be A114      		cp r10,__zero_reg__
 6279 20c0 B104      		cpc r11,__zero_reg__
 6280 20c2 01F4      		brne .+2
 6281 20c4 00C0      		rjmp .L451
2602:ff.c          **** 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 6283               	.LM626:
 6284 20c6 E981      		ldd r30,Y+1
 6285 20c8 FA81      		ldd r31,Y+2
 6286 20ca 2281      		ldd r18,Z+2
 6287 20cc 832D      		mov r24,r3
 6288 20ce 90E0      		ldi r25,0
 6289 20d0 A501      		movw r20,r10
 6290 20d2 480F      		add r20,r24
 6291 20d4 591F      		adc r21,r25
 6292 20d6 30E0      		ldi r19,0
 6293 20d8 2417      		cp r18,r20
 6294 20da 3507      		cpc r19,r21
 6295 20dc 00F4      		brsh .L452
2603:ff.c          **** 					cc = fp->fs->csize - csect;
 6297               	.LM627:
 6298 20de 5901      		movw r10,r18
 6299 20e0 A81A      		sub r10,r24
 6300 20e2 B90A      		sbc r11,r25
 6301               	.L452:
2604:ff.c          **** 				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
 6303               	.LM628:
 6304 20e4 0A2D      		mov r16,r10
 6305 20e6 A301      		movw r20,r6
 6306 20e8 9201      		movw r18,r4
 6307 20ea B601      		movw r22,r12
 6308 20ec A981      		ldd r26,Y+1
 6309 20ee BA81      		ldd r27,Y+2
 6310 20f0 1196      		adiw r26,1
 6311 20f2 8C91      		ld r24,X
 6312 20f4 0E94 0000 		call disk_write
2605:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 6314               	.LM629:
 6315 20f8 ED81      		ldd r30,Y+5
 6316 20fa FE81      		ldd r31,Y+6
2604:ff.c          **** 				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
 6318               	.LM630:
 6319 20fc 8111      		cpse r24,__zero_reg__
 6320 20fe 00C0      		rjmp .L471
 6321               	.L453:
2612:ff.c          **** 				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write 
 6323               	.LM631:
 6324 2100 8689      		ldd r24,Z+22
 6325 2102 9789      		ldd r25,Z+23
 6326 2104 A08D      		ldd r26,Z+24
 6327 2106 B18D      		ldd r27,Z+25
 6328 2108 8419      		sub r24,r4
 6329 210a 9509      		sbc r25,r5
 6330 210c A609      		sbc r26,r6
 6331 210e B709      		sbc r27,r7
 6332 2110 A501      		movw r20,r10
 6333 2112 60E0      		ldi r22,0
 6334 2114 70E0      		ldi r23,0
 6335 2116 8417      		cp r24,r20
 6336 2118 9507      		cpc r25,r21
 6337 211a A607      		cpc r26,r22
 6338 211c B707      		cpc r27,r23
 6339 211e 00F4      		brsh .L454
2613:ff.c          **** 					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
 6341               	.LM632:
 6342 2120 BC01      		movw r22,r24
 6343 2122 762F      		mov r23,r22
 6344 2124 6627      		clr r22
 6345 2126 770F      		lsl r23
 6346 2128 6C0D      		add r22,r12
 6347 212a 7D1D      		adc r23,r13
 6348 212c 40E0      		ldi r20,0
 6349 212e 52E0      		ldi r21,lo8(2)
 6350 2130 C401      		movw r24,r8
 6351 2132 0E94 0000 		call mem_cpy
2614:ff.c          **** 					fp->flag &= ~FA__DIRTY;
 6353               	.LM633:
 6354 2136 AD81      		ldd r26,Y+5
 6355 2138 BE81      		ldd r27,Y+6
 6356 213a 1496      		adiw r26,4
 6357 213c 8C91      		ld r24,X
 6358 213e 1497      		sbiw r26,4
 6359 2140 8F7B      		andi r24,lo8(-65)
 6360 2142 1496      		adiw r26,4
 6361 2144 8C93      		st X,r24
 6362               	.L454:
2617:ff.c          **** 				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
 6364               	.LM634:
 6365 2146 BA2C      		mov r11,r10
 6366 2148 AA24      		clr r10
 6367 214a BB0C      		lsl r11
2618:ff.c          **** 				continue;
 6369               	.LM635:
 6370 214c 00C0      		rjmp .L455
 6371               	.L451:
2626:ff.c          **** 			if (fp->dsect != sect) {		/* Fill sector cache with file data */
 6373               	.LM636:
 6374 214e ED81      		ldd r30,Y+5
 6375 2150 FE81      		ldd r31,Y+6
 6376 2152 8689      		ldd r24,Z+22
 6377 2154 9789      		ldd r25,Z+23
 6378 2156 A08D      		ldd r26,Z+24
 6379 2158 B18D      		ldd r27,Z+25
 6380 215a 8415      		cp r24,r4
 6381 215c 9505      		cpc r25,r5
 6382 215e A605      		cpc r26,r6
 6383 2160 B705      		cpc r27,r7
 6384 2162 01F0      		breq .L456
2627:ff.c          **** 				if (fp->fptr < fp->fsize &&
 6386               	.LM637:
 6387 2164 4681      		ldd r20,Z+6
 6388 2166 5781      		ldd r21,Z+7
 6389 2168 6085      		ldd r22,Z+8
 6390 216a 7185      		ldd r23,Z+9
 6391 216c 8285      		ldd r24,Z+10
 6392 216e 9385      		ldd r25,Z+11
 6393 2170 A485      		ldd r26,Z+12
 6394 2172 B585      		ldd r27,Z+13
 6395 2174 4817      		cp r20,r24
 6396 2176 5907      		cpc r21,r25
 6397 2178 6A07      		cpc r22,r26
 6398 217a 7B07      		cpc r23,r27
 6399 217c 00F4      		brsh .L456
2628:ff.c          **** 					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
 6401               	.LM638:
 6402 217e 01E0      		ldi r16,lo8(1)
 6403 2180 A301      		movw r20,r6
 6404 2182 9201      		movw r18,r4
 6405 2184 B401      		movw r22,r8
 6406 2186 A981      		ldd r26,Y+1
 6407 2188 BA81      		ldd r27,Y+2
 6408 218a 1196      		adiw r26,1
 6409 218c 8C91      		ld r24,X
 6410 218e 0E94 0000 		call disk_read
2627:ff.c          **** 				if (fp->fptr < fp->fsize &&
 6412               	.LM639:
 6413 2192 8823      		tst r24
 6414 2194 01F0      		breq .L456
2629:ff.c          **** 						ABORT(fp->fs, FR_DISK_ERR);
 6416               	.LM640:
 6417 2196 ED81      		ldd r30,Y+5
 6418 2198 FE81      		ldd r31,Y+6
 6419               	.L471:
 6420 219a 8481      		ldd r24,Z+4
 6421 219c 8068      		ori r24,lo8(-128)
 6422               	.L472:
 6423 219e 8483      		std Z+4,r24
 6424               	.L473:
 6425 21a0 11E0      		ldi r17,lo8(1)
 6426 21a2 00C0      		rjmp .L436
 6427               	.L456:
2632:ff.c          **** 			fp->dsect = sect;
 6429               	.LM641:
 6430 21a4 AD81      		ldd r26,Y+5
 6431 21a6 BE81      		ldd r27,Y+6
 6432 21a8 5696      		adiw r26,22
 6433 21aa 4D92      		st X+,r4
 6434 21ac 5D92      		st X+,r5
 6435 21ae 6D92      		st X+,r6
 6436 21b0 7C92      		st X,r7
 6437 21b2 5997      		sbiw r26,22+3
 6438               	.L439:
2634:ff.c          **** 		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
 6440               	.LM642:
 6441 21b4 ED81      		ldd r30,Y+5
 6442 21b6 FE81      		ldd r31,Y+6
 6443 21b8 8681      		ldd r24,Z+6
 6444 21ba 9781      		ldd r25,Z+7
 6445 21bc A085      		ldd r26,Z+8
 6446 21be B185      		ldd r27,Z+9
 6447 21c0 9170      		andi r25,1
 6448 21c2 AA27      		clr r26
 6449 21c4 BB27      		clr r27
 6450 21c6 20E0      		ldi r18,0
 6451 21c8 32E0      		ldi r19,lo8(2)
 6452 21ca 281B      		sub r18,r24
 6453 21cc 390B      		sbc r19,r25
 6454 21ce 5701      		movw r10,r14
 6455 21d0 2E15      		cp r18,r14
 6456 21d2 3F05      		cpc r19,r15
 6457 21d4 00F4      		brsh .L457
 6458 21d6 5901      		movw r10,r18
 6459               	.L457:
2642:ff.c          **** 		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
 6461               	.LM643:
 6462 21d8 8096      		adiw r24,32
 6463 21da A501      		movw r20,r10
 6464 21dc B601      		movw r22,r12
 6465 21de 2D81      		ldd r18,Y+5
 6466 21e0 3E81      		ldd r19,Y+6
 6467 21e2 820F      		add r24,r18
 6468 21e4 931F      		adc r25,r19
 6469 21e6 0E94 0000 		call mem_cpy
2643:ff.c          **** 		fp->flag |= FA__DIRTY;
 6471               	.LM644:
 6472 21ea AD81      		ldd r26,Y+5
 6473 21ec BE81      		ldd r27,Y+6
 6474 21ee 1496      		adiw r26,4
 6475 21f0 8C91      		ld r24,X
 6476 21f2 1497      		sbiw r26,4
 6477 21f4 8064      		ori r24,lo8(64)
 6478 21f6 1496      		adiw r26,4
 6479 21f8 8C93      		st X,r24
 6480               	.L455:
2566:ff.c          **** 		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 6482               	.LM645:
 6483 21fa CA0C      		add r12,r10
 6484 21fc DB1C      		adc r13,r11
 6485 21fe ED81      		ldd r30,Y+5
 6486 2200 FE81      		ldd r31,Y+6
 6487 2202 8681      		ldd r24,Z+6
 6488 2204 9781      		ldd r25,Z+7
 6489 2206 A085      		ldd r26,Z+8
 6490 2208 B185      		ldd r27,Z+9
 6491 220a 8A0D      		add r24,r10
 6492 220c 9B1D      		adc r25,r11
 6493 220e A11D      		adc r26,__zero_reg__
 6494 2210 B11D      		adc r27,__zero_reg__
 6495 2212 8683      		std Z+6,r24
 6496 2214 9783      		std Z+7,r25
 6497 2216 A087      		std Z+8,r26
 6498 2218 B187      		std Z+9,r27
 6499 221a AB81      		ldd r26,Y+3
 6500 221c BC81      		ldd r27,Y+4
 6501 221e 8D91      		ld r24,X+
 6502 2220 9C91      		ld r25,X
 6503 2222 1197      		sbiw r26,1
 6504 2224 8A0D      		add r24,r10
 6505 2226 9B1D      		adc r25,r11
 6506 2228 8D93      		st X+,r24
 6507 222a 9C93      		st X,r25
 6508 222c EA18      		sub r14,r10
 6509 222e FB08      		sbc r15,r11
 6510               	.L438:
2565:ff.c          **** 	for ( ;  btw;							/* Repeat until all data written */
 6512               	.LM646:
 6513 2230 E114      		cp r14,__zero_reg__
 6514 2232 F104      		cpc r15,__zero_reg__
 6515 2234 01F0      		breq .+2
 6516 2236 00C0      		rjmp .L458
 6517 2238 00C0      		rjmp .L459
 6518               	.L444:
2647:ff.c          **** 	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
 6520               	.LM647:
 6521 223a ED81      		ldd r30,Y+5
 6522 223c FE81      		ldd r31,Y+6
 6523 223e 8287      		std Z+10,r24
 6524 2240 9387      		std Z+11,r25
 6525 2242 A487      		std Z+12,r26
 6526 2244 B587      		std Z+13,r27
 6527               	.L445:
2648:ff.c          **** 	fp->flag |= FA__WRITTEN;						/* Set file change flag */
 6529               	.LM648:
 6530 2246 AD81      		ldd r26,Y+5
 6531 2248 BE81      		ldd r27,Y+6
 6532 224a 1496      		adiw r26,4
 6533 224c 8C91      		ld r24,X
 6534 224e 1497      		sbiw r26,4
 6535 2250 8062      		ori r24,lo8(32)
 6536 2252 1496      		adiw r26,4
 6537 2254 8C93      		st X,r24
2650:ff.c          **** 	LEAVE_FF(fp->fs, FR_OK);
 6539               	.LM649:
 6540 2256 00C0      		rjmp .L436
 6541               	.L461:
2562:ff.c          **** 		LEAVE_FF(fp->fs, FR_DENIED);
 6543               	.LM650:
 6544 2258 17E0      		ldi r17,lo8(7)
 6545               	.L436:
2651:ff.c          **** }
 6547               	.LM651:
 6548 225a 812F      		mov r24,r17
 6549               	/* epilogue start */
 6550 225c 2696      		adiw r28,6
 6551 225e 0FB6      		in __tmp_reg__,__SREG__
 6552 2260 F894      		cli
 6553 2262 DEBF      		out __SP_H__,r29
 6554 2264 0FBE      		out __SREG__,__tmp_reg__
 6555 2266 CDBF      		out __SP_L__,r28
 6556 2268 DF91      		pop r29
 6557 226a CF91      		pop r28
 6558 226c 1F91      		pop r17
 6559 226e 0F91      		pop r16
 6560 2270 FF90      		pop r15
 6561 2272 EF90      		pop r14
 6562 2274 DF90      		pop r13
 6563 2276 CF90      		pop r12
 6564 2278 BF90      		pop r11
 6565 227a AF90      		pop r10
 6566 227c 9F90      		pop r9
 6567 227e 8F90      		pop r8
 6568 2280 7F90      		pop r7
 6569 2282 6F90      		pop r6
 6570 2284 5F90      		pop r5
 6571 2286 4F90      		pop r4
 6572 2288 3F90      		pop r3
 6573 228a 0895      		ret
 6582               	.Lscope24:
 6584               		.stabd	78,0,0
 6587               	.global	f_sync
 6589               	f_sync:
 6590               		.stabd	46,0,0
2663:ff.c          **** {
 6592               	.LM652:
 6593               	.LFBB25:
 6594 228c 0F93      		push r16
 6595 228e 1F93      		push r17
 6596 2290 CF93      		push r28
 6597 2292 DF93      		push r29
 6598               	/* prologue: function */
 6599               	/* frame size = 0 */
 6600               	/* stack size = 4 */
 6601               	.L__stack_usage = 4
 6602 2294 EC01      		movw r28,r24
2669:ff.c          **** 	res = validate(fp);					/* Check validity of the object */
 6604               	.LM653:
 6605 2296 0E94 0000 		call validate
2670:ff.c          **** 	if (res == FR_OK) {
 6607               	.LM654:
 6608 229a 8111      		cpse r24,__zero_reg__
 6609 229c 00C0      		rjmp .L475
2671:ff.c          **** 		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
 6611               	.LM655:
 6612 229e 9C81      		ldd r25,Y+4
 6613 22a0 95FF      		sbrs r25,5
 6614 22a2 00C0      		rjmp .L475
2673:ff.c          **** 			if (fp->flag & FA__DIRTY) {
 6616               	.LM656:
 6617 22a4 96FF      		sbrs r25,6
 6618 22a6 00C0      		rjmp .L476
2674:ff.c          **** 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 6620               	.LM657:
 6621 22a8 2E89      		ldd r18,Y+22
 6622 22aa 3F89      		ldd r19,Y+23
 6623 22ac 488D      		ldd r20,Y+24
 6624 22ae 598D      		ldd r21,Y+25
 6625 22b0 BE01      		movw r22,r28
 6626 22b2 605E      		subi r22,-32
 6627 22b4 7F4F      		sbci r23,-1
 6628 22b6 E881      		ld r30,Y
 6629 22b8 F981      		ldd r31,Y+1
 6630 22ba 01E0      		ldi r16,lo8(1)
 6631 22bc 8181      		ldd r24,Z+1
 6632 22be 0E94 0000 		call disk_write
 6633 22c2 8111      		cpse r24,__zero_reg__
 6634 22c4 00C0      		rjmp .L477
2676:ff.c          **** 				fp->flag &= ~FA__DIRTY;
 6636               	.LM658:
 6637 22c6 8C81      		ldd r24,Y+4
 6638 22c8 8F7B      		andi r24,lo8(-65)
 6639 22ca 8C83      		std Y+4,r24
 6640               	.L476:
2680:ff.c          **** 			res = move_window(fp->fs, fp->dir_sect);
 6642               	.LM659:
 6643 22cc 4A8D      		ldd r20,Y+26
 6644 22ce 5B8D      		ldd r21,Y+27
 6645 22d0 6C8D      		ldd r22,Y+28
 6646 22d2 7D8D      		ldd r23,Y+29
 6647 22d4 8881      		ld r24,Y
 6648 22d6 9981      		ldd r25,Y+1
 6649 22d8 0E94 0000 		call move_window
2681:ff.c          **** 			if (res == FR_OK) {
 6651               	.LM660:
 6652 22dc 8111      		cpse r24,__zero_reg__
 6653 22de 00C0      		rjmp .L475
2682:ff.c          **** 				dir = fp->dir_ptr;
 6655               	.LM661:
 6656 22e0 0E8D      		ldd r16,Y+30
 6657 22e2 1F8D      		ldd r17,Y+31
2683:ff.c          **** 				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
 6659               	.LM662:
 6660 22e4 F801      		movw r30,r16
 6661 22e6 8385      		ldd r24,Z+11
 6662 22e8 8062      		ori r24,lo8(32)
 6663 22ea 8387      		std Z+11,r24
2684:ff.c          **** 				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
 6665               	.LM663:
 6666 22ec 8A85      		ldd r24,Y+10
 6667 22ee 848F      		std Z+28,r24
 6668 22f0 8B85      		ldd r24,Y+11
 6669 22f2 858F      		std Z+29,r24
 6670 22f4 8C85      		ldd r24,Y+12
 6671 22f6 868F      		std Z+30,r24
 6672 22f8 8D85      		ldd r24,Y+13
 6673 22fa 878F      		std Z+31,r24
2685:ff.c          **** 				st_clust(dir, fp->sclust);					/* Update start cluster */
 6675               	.LM664:
 6676 22fc 4E85      		ldd r20,Y+14
 6677 22fe 5F85      		ldd r21,Y+15
 6678 2300 6889      		ldd r22,Y+16
 6679 2302 7989      		ldd r23,Y+17
 6680               	.LBB99:
 6681               	.LBB100:
1261:ff.c          **** 	ST_WORD(dir+DIR_FstClusLO, cl);
 6683               	.LM665:
 6684 2304 428F      		std Z+26,r20
 6685 2306 538F      		std Z+27,r21
1262:ff.c          **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 6687               	.LM666:
 6688 2308 AB01      		movw r20,r22
 6689 230a 6627      		clr r22
 6690 230c 7727      		clr r23
 6691 230e 448B      		std Z+20,r20
 6692 2310 558B      		std Z+21,r21
 6693               	.LBE100:
 6694               	.LBE99:
2686:ff.c          **** 				tm = get_fattime();							/* Update updated time */
 6696               	.LM667:
 6697 2312 0E94 0000 		call get_fattime
2687:ff.c          **** 				ST_DWORD(dir+DIR_WrtTime, tm);
 6699               	.LM668:
 6700 2316 F801      		movw r30,r16
 6701 2318 668B      		std Z+22,r22
 6702 231a 778B      		std Z+23,r23
 6703 231c 808F      		std Z+24,r24
 6704 231e 918F      		std Z+25,r25
2688:ff.c          **** 				ST_WORD(dir+DIR_LstAccDate, 0);
 6706               	.LM669:
 6707 2320 128A      		std Z+18,__zero_reg__
 6708 2322 138A      		std Z+19,__zero_reg__
2689:ff.c          **** 				fp->flag &= ~FA__WRITTEN;
 6710               	.LM670:
 6711 2324 8C81      		ldd r24,Y+4
 6712 2326 8F7D      		andi r24,lo8(-33)
 6713 2328 8C83      		std Y+4,r24
2690:ff.c          **** 				fp->fs->wflag = 1;
 6715               	.LM671:
 6716 232a E881      		ld r30,Y
 6717 232c F981      		ldd r31,Y+1
 6718 232e 81E0      		ldi r24,lo8(1)
 6719 2330 8483      		std Z+4,r24
2691:ff.c          **** 				res = sync_fs(fp->fs);
 6721               	.LM672:
 6722 2332 8881      		ld r24,Y
 6723 2334 9981      		ldd r25,Y+1
 6724               	/* epilogue start */
2697:ff.c          **** }
 6726               	.LM673:
 6727 2336 DF91      		pop r29
 6728 2338 CF91      		pop r28
 6729 233a 1F91      		pop r17
 6730 233c 0F91      		pop r16
2691:ff.c          **** 				res = sync_fs(fp->fs);
 6732               	.LM674:
 6733 233e 0C94 0000 		jmp sync_fs
 6734               	.L477:
2675:ff.c          **** 					LEAVE_FF(fp->fs, FR_DISK_ERR);
 6736               	.LM675:
 6737 2342 81E0      		ldi r24,lo8(1)
 6738               	.L475:
 6739               	/* epilogue start */
2697:ff.c          **** }
 6741               	.LM676:
 6742 2344 DF91      		pop r29
 6743 2346 CF91      		pop r28
 6744 2348 1F91      		pop r17
 6745 234a 0F91      		pop r16
 6746 234c 0895      		ret
 6752               	.Lscope25:
 6754               		.stabd	78,0,0
 6757               	.global	f_close
 6759               	f_close:
 6760               		.stabd	46,0,0
2711:ff.c          **** {
 6762               	.LM677:
 6763               	.LFBB26:
 6764 234e CF93      		push r28
 6765 2350 DF93      		push r29
 6766               	/* prologue: function */
 6767               	/* frame size = 0 */
 6768               	/* stack size = 2 */
 6769               	.L__stack_usage = 2
 6770 2352 EC01      		movw r28,r24
2725:ff.c          **** 	res = f_sync(fp);		/* Flush cached data */
 6772               	.LM678:
 6773 2354 0E94 0000 		call f_sync
2740:ff.c          **** 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
 6775               	.LM679:
 6776 2358 8111      		cpse r24,__zero_reg__
 6777 235a 00C0      		rjmp .L485
2740:ff.c          **** 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
 6779               	.LM680:
 6780 235c 1982      		std Y+1,__zero_reg__
 6781 235e 1882      		st Y,__zero_reg__
 6782               	.L485:
 6783               	/* epilogue start */
2743:ff.c          **** }
 6785               	.LM681:
 6786 2360 DF91      		pop r29
 6787 2362 CF91      		pop r28
 6788 2364 0895      		ret
 6793               	.Lscope26:
 6795               		.stabd	78,0,0
 6799               	.global	f_lseek
 6801               	f_lseek:
 6802               		.stabd	46,0,0
2881:ff.c          **** {
 6804               	.LM682:
 6805               	.LFBB27:
 6806 2366 2F92      		push r2
 6807 2368 3F92      		push r3
 6808 236a 4F92      		push r4
 6809 236c 5F92      		push r5
 6810 236e 6F92      		push r6
 6811 2370 7F92      		push r7
 6812 2372 8F92      		push r8
 6813 2374 9F92      		push r9
 6814 2376 AF92      		push r10
 6815 2378 BF92      		push r11
 6816 237a CF92      		push r12
 6817 237c DF92      		push r13
 6818 237e EF92      		push r14
 6819 2380 FF92      		push r15
 6820 2382 0F93      		push r16
 6821 2384 1F93      		push r17
 6822 2386 CF93      		push r28
 6823 2388 DF93      		push r29
 6824 238a 00D0      		rcall .
 6825 238c 00D0      		rcall .
 6826 238e 00D0      		rcall .
 6827 2390 CDB7      		in r28,__SP_L__
 6828 2392 DEB7      		in r29,__SP_H__
 6829               	/* prologue: function */
 6830               	/* frame size = 6 */
 6831               	/* stack size = 24 */
 6832               	.L__stack_usage = 24
 6833 2394 9E83      		std Y+6,r25
 6834 2396 8D83      		std Y+5,r24
 6835 2398 6A01      		movw r12,r20
 6836 239a 7B01      		movw r14,r22
2885:ff.c          **** 	res = validate(fp);					/* Check validity of the object */
 6838               	.LM683:
 6839 239c 0E94 0000 		call validate
 6840 23a0 182F      		mov r17,r24
2886:ff.c          **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 6842               	.LM684:
 6843 23a2 8111      		cpse r24,__zero_reg__
 6844 23a4 00C0      		rjmp .L487
2887:ff.c          **** 	if (fp->flag & FA__ERROR)			/* Check abort flag */
 6846               	.LM685:
 6847 23a6 AD81      		ldd r26,Y+5
 6848 23a8 BE81      		ldd r27,Y+6
 6849 23aa 1496      		adiw r26,4
 6850 23ac 2C91      		ld r18,X
 6851 23ae 1497      		sbiw r26,4
 6852 23b0 27FD      		sbrc r18,7
 6853 23b2 00C0      		rjmp .L510
 6854               	.LBB101:
2951:ff.c          **** 		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
 6856               	.LM686:
 6857 23b4 1A96      		adiw r26,10
 6858 23b6 8D91      		ld r24,X+
 6859 23b8 9D91      		ld r25,X+
 6860 23ba 0D90      		ld __tmp_reg__,X+
 6861 23bc BC91      		ld r27,X
 6862 23be A02D      		mov r26,__tmp_reg__
 6863 23c0 8C15      		cp r24,r12
 6864 23c2 9D05      		cpc r25,r13
 6865 23c4 AE05      		cpc r26,r14
 6866 23c6 BF05      		cpc r27,r15
 6867 23c8 00F4      		brsh .L488
2953:ff.c          **** 			 && !(fp->flag & FA_WRITE)
 6869               	.LM687:
 6870 23ca 21FD      		sbrc r18,1
 6871 23cc 00C0      		rjmp .L488
 6872 23ce 6C01      		movw r12,r24
 6873 23d0 7D01      		movw r14,r26
 6874               	.L488:
2957:ff.c          **** 		ifptr = fp->fptr;
 6876               	.LM688:
 6877 23d2 ED81      		ldd r30,Y+5
 6878 23d4 FE81      		ldd r31,Y+6
 6879 23d6 8680      		ldd r8,Z+6
 6880 23d8 9780      		ldd r9,Z+7
 6881 23da A084      		ldd r10,Z+8
 6882 23dc B184      		ldd r11,Z+9
2958:ff.c          **** 		fp->fptr = nsect = 0;
 6884               	.LM689:
 6885 23de 1682      		std Z+6,__zero_reg__
 6886 23e0 1782      		std Z+7,__zero_reg__
 6887 23e2 1086      		std Z+8,__zero_reg__
 6888 23e4 1186      		std Z+9,__zero_reg__
2959:ff.c          **** 		if (ofs) {
 6890               	.LM690:
 6891 23e6 C114      		cp r12,__zero_reg__
 6892 23e8 D104      		cpc r13,__zero_reg__
 6893 23ea E104      		cpc r14,__zero_reg__
 6894 23ec F104      		cpc r15,__zero_reg__
 6895 23ee 01F4      		brne .L489
 6896               	.L496:
2958:ff.c          **** 		fp->fptr = nsect = 0;
 6898               	.LM691:
 6899 23f0 C12C      		mov r12,__zero_reg__
 6900 23f2 D12C      		mov r13,__zero_reg__
 6901 23f4 7601      		movw r14,r12
 6902 23f6 00C0      		rjmp .L490
 6903               	.L489:
2960:ff.c          **** 			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
 6905               	.LM692:
 6906 23f8 ED81      		ldd r30,Y+5
 6907 23fa FE81      		ldd r31,Y+6
 6908 23fc 2080      		ld r2,Z
 6909 23fe 3180      		ldd r3,Z+1
 6910 2400 D101      		movw r26,r2
 6911 2402 1296      		adiw r26,2
 6912 2404 8C91      		ld r24,X
 6913 2406 482E      		mov r4,r24
 6914 2408 512C      		mov r5,__zero_reg__
 6915 240a 612C      		mov r6,__zero_reg__
 6916 240c 712C      		mov r7,__zero_reg__
 6917 240e 59E0      		ldi r21,9
 6918               		1:
 6919 2410 440C      		lsl r4
 6920 2412 551C      		rol r5
 6921 2414 661C      		rol r6
 6922 2416 771C      		rol r7
 6923 2418 5A95      		dec r21
 6924 241a 01F4      		brne 1b
2961:ff.c          **** 			if (ifptr > 0 &&
 6926               	.LM693:
 6927 241c 8114      		cp r8,__zero_reg__
 6928 241e 9104      		cpc r9,__zero_reg__
 6929 2420 A104      		cpc r10,__zero_reg__
 6930 2422 B104      		cpc r11,__zero_reg__
 6931 2424 01F0      		breq .L491
2962:ff.c          **** 				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 6933               	.LM694:
 6934 2426 B1E0      		ldi r27,1
 6935 2428 8B1A      		sub r8,r27
 6936 242a 9108      		sbc r9,__zero_reg__
 6937 242c A108      		sbc r10,__zero_reg__
 6938 242e B108      		sbc r11,__zero_reg__
 6939 2430 C701      		movw r24,r14
 6940 2432 B601      		movw r22,r12
 6941 2434 6150      		subi r22,1
 6942 2436 7109      		sbc r23,__zero_reg__
 6943 2438 8109      		sbc r24,__zero_reg__
 6944 243a 9109      		sbc r25,__zero_reg__
 6945 243c A301      		movw r20,r6
 6946 243e 9201      		movw r18,r4
 6947 2440 0E94 0000 		call __udivmodsi4
 6948 2444 2983      		std Y+1,r18
 6949 2446 3A83      		std Y+2,r19
 6950 2448 4B83      		std Y+3,r20
 6951 244a 5C83      		std Y+4,r21
 6952 244c C501      		movw r24,r10
 6953 244e B401      		movw r22,r8
 6954 2450 A301      		movw r20,r6
 6955 2452 9201      		movw r18,r4
 6956 2454 0E94 0000 		call __udivmodsi4
2961:ff.c          **** 			if (ifptr > 0 &&
 6958               	.LM695:
 6959 2458 8981      		ldd r24,Y+1
 6960 245a 9A81      		ldd r25,Y+2
 6961 245c AB81      		ldd r26,Y+3
 6962 245e BC81      		ldd r27,Y+4
 6963 2460 8217      		cp r24,r18
 6964 2462 9307      		cpc r25,r19
 6965 2464 A407      		cpc r26,r20
 6966 2466 B507      		cpc r27,r21
 6967 2468 00F0      		brlo .L491
2963:ff.c          **** 				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
 6969               	.LM696:
 6970 246a 8827      		clr r24
 6971 246c 9927      		clr r25
 6972 246e DC01      		movw r26,r24
 6973 2470 8419      		sub r24,r4
 6974 2472 9509      		sbc r25,r5
 6975 2474 A609      		sbc r26,r6
 6976 2476 B709      		sbc r27,r7
 6977 2478 8821      		and r24,r8
 6978 247a 9921      		and r25,r9
 6979 247c AA21      		and r26,r10
 6980 247e BB21      		and r27,r11
 6981 2480 ED81      		ldd r30,Y+5
 6982 2482 FE81      		ldd r31,Y+6
 6983 2484 8683      		std Z+6,r24
 6984 2486 9783      		std Z+7,r25
 6985 2488 A087      		std Z+8,r26
 6986 248a B187      		std Z+9,r27
2964:ff.c          **** 				ofs -= fp->fptr;
 6988               	.LM697:
 6989 248c C81A      		sub r12,r24
 6990 248e D90A      		sbc r13,r25
 6991 2490 EA0A      		sbc r14,r26
 6992 2492 FB0A      		sbc r15,r27
2965:ff.c          **** 				clst = fp->clust;
 6994               	.LM698:
 6995 2494 4289      		ldd r20,Z+18
 6996 2496 5389      		ldd r21,Z+19
 6997 2498 6489      		ldd r22,Z+20
 6998 249a 7589      		ldd r23,Z+21
 6999 249c 00C0      		rjmp .L492
 7000               	.L491:
2967:ff.c          **** 				clst = fp->sclust;						/* start from the first cluster */
 7002               	.LM699:
 7003 249e AD81      		ldd r26,Y+5
 7004 24a0 BE81      		ldd r27,Y+6
 7005 24a2 1E96      		adiw r26,14
 7006 24a4 4D91      		ld r20,X+
 7007 24a6 5D91      		ld r21,X+
 7008 24a8 6D91      		ld r22,X+
 7009 24aa 7C91      		ld r23,X
 7010 24ac 5197      		sbiw r26,14+3
2969:ff.c          **** 				if (clst == 0) {						/* If no cluster chain, create a new chain */
 7012               	.LM700:
 7013 24ae 4115      		cp r20,__zero_reg__
 7014 24b0 5105      		cpc r21,__zero_reg__
 7015 24b2 6105      		cpc r22,__zero_reg__
 7016 24b4 7105      		cpc r23,__zero_reg__
 7017 24b6 01F4      		brne .L493
2970:ff.c          **** 					clst = create_chain(fp->fs, 0);
 7019               	.LM701:
 7020 24b8 40E0      		ldi r20,0
 7021 24ba 50E0      		ldi r21,0
 7022 24bc BA01      		movw r22,r20
 7023 24be C101      		movw r24,r2
 7024 24c0 0E94 0000 		call create_chain
 7025 24c4 AB01      		movw r20,r22
 7026 24c6 BC01      		movw r22,r24
2971:ff.c          **** 					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 7028               	.LM702:
 7029 24c8 4130      		cpi r20,1
 7030 24ca 5105      		cpc r21,__zero_reg__
 7031 24cc 6105      		cpc r22,__zero_reg__
 7032 24ce 7105      		cpc r23,__zero_reg__
 7033 24d0 01F4      		brne .L494
 7034 24d2 00C0      		rjmp .L502
 7035               	.L494:
2972:ff.c          **** 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 7037               	.LM703:
 7038 24d4 4F3F      		cpi r20,-1
 7039 24d6 FFEF      		ldi r31,-1
 7040 24d8 5F07      		cpc r21,r31
 7041 24da 6F07      		cpc r22,r31
 7042 24dc 7F07      		cpc r23,r31
 7043 24de 01F4      		brne .L495
 7044 24e0 00C0      		rjmp .L530
 7045               	.L495:
2973:ff.c          **** 					fp->sclust = clst;
 7047               	.LM704:
 7048 24e2 ED81      		ldd r30,Y+5
 7049 24e4 FE81      		ldd r31,Y+6
 7050 24e6 4687      		std Z+14,r20
 7051 24e8 5787      		std Z+15,r21
 7052 24ea 608B      		std Z+16,r22
 7053 24ec 718B      		std Z+17,r23
 7054               	.L493:
2976:ff.c          **** 				fp->clust = clst;
 7056               	.LM705:
 7057 24ee AD81      		ldd r26,Y+5
 7058 24f0 BE81      		ldd r27,Y+6
 7059 24f2 5296      		adiw r26,18
 7060 24f4 4D93      		st X+,r20
 7061 24f6 5D93      		st X+,r21
 7062 24f8 6D93      		st X+,r22
 7063 24fa 7C93      		st X,r23
 7064 24fc 5597      		sbiw r26,18+3
 7065               	.L492:
2978:ff.c          **** 			if (clst != 0) {
 7067               	.LM706:
 7068 24fe 4115      		cp r20,__zero_reg__
 7069 2500 5105      		cpc r21,__zero_reg__
 7070 2502 6105      		cpc r22,__zero_reg__
 7071 2504 7105      		cpc r23,__zero_reg__
 7072 2506 01F4      		brne .+2
 7073 2508 00C0      		rjmp .L496
 7074 250a 00C0      		rjmp .L528
 7075               	.L504:
2981:ff.c          **** 					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 7077               	.LM707:
 7078 250c ED81      		ldd r30,Y+5
 7079 250e FE81      		ldd r31,Y+6
 7080 2510 2481      		ldd r18,Z+4
 7081 2512 8081      		ld r24,Z
 7082 2514 9181      		ldd r25,Z+1
 7083 2516 21FF      		sbrs r18,1
 7084 2518 00C0      		rjmp .L498
2982:ff.c          **** 						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
 7086               	.LM708:
 7087 251a 0E94 0000 		call create_chain
 7088 251e AB01      		movw r20,r22
 7089 2520 BC01      		movw r22,r24
2983:ff.c          **** 						if (clst == 0) {				/* When disk gets full, clip file size */
 7091               	.LM709:
 7092 2522 4115      		cp r20,__zero_reg__
 7093 2524 5105      		cpc r21,__zero_reg__
 7094 2526 6105      		cpc r22,__zero_reg__
 7095 2528 7105      		cpc r23,__zero_reg__
 7096 252a 01F4      		brne .L500
 7097 252c 00C0      		rjmp .L512
 7098               	.L498:
2988:ff.c          **** 						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
 7100               	.LM710:
 7101 252e 0E94 0000 		call get_fat
 7102 2532 AB01      		movw r20,r22
 7103 2534 BC01      		movw r22,r24
 7104               	.L500:
2989:ff.c          **** 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 7106               	.LM711:
 7107 2536 4F3F      		cpi r20,-1
 7108 2538 FFEF      		ldi r31,-1
 7109 253a 5F07      		cpc r21,r31
 7110 253c 6F07      		cpc r22,r31
 7111 253e 7F07      		cpc r23,r31
 7112 2540 01F4      		brne .L501
 7113               	.L530:
2989:ff.c          **** 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 7115               	.LM712:
 7116 2542 AD81      		ldd r26,Y+5
 7117 2544 BE81      		ldd r27,Y+6
 7118 2546 1496      		adiw r26,4
 7119 2548 8C91      		ld r24,X
 7120 254a 1497      		sbiw r26,4
 7121 254c 8068      		ori r24,lo8(-128)
 7122 254e 1496      		adiw r26,4
 7123 2550 8C93      		st X,r24
 7124 2552 00C0      		rjmp .L529
 7125               	.L501:
2990:ff.c          **** 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
 7127               	.LM713:
 7128 2554 4230      		cpi r20,2
 7129 2556 5105      		cpc r21,__zero_reg__
 7130 2558 6105      		cpc r22,__zero_reg__
 7131 255a 7105      		cpc r23,__zero_reg__
 7132 255c 00F0      		brlo .L502
2990:ff.c          **** 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
 7134               	.LM714:
 7135 255e AD81      		ldd r26,Y+5
 7136 2560 BE81      		ldd r27,Y+6
 7137 2562 ED91      		ld r30,X+
 7138 2564 FC91      		ld r31,X
 7139 2566 8689      		ldd r24,Z+22
 7140 2568 9789      		ldd r25,Z+23
 7141 256a A08D      		ldd r26,Z+24
 7142 256c B18D      		ldd r27,Z+25
 7143 256e 4817      		cp r20,r24
 7144 2570 5907      		cpc r21,r25
 7145 2572 6A07      		cpc r22,r26
 7146 2574 7B07      		cpc r23,r27
 7147 2576 00F0      		brlo .L503
 7148               	.L502:
2990:ff.c          **** 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
 7150               	.LM715:
 7151 2578 ED81      		ldd r30,Y+5
 7152 257a FE81      		ldd r31,Y+6
 7153 257c 8481      		ldd r24,Z+4
 7154 257e 8068      		ori r24,lo8(-128)
 7155 2580 8483      		std Z+4,r24
 7156 2582 00C0      		rjmp .L510
 7157               	.L503:
2991:ff.c          **** 					fp->clust = clst;
 7159               	.LM716:
 7160 2584 AD81      		ldd r26,Y+5
 7161 2586 BE81      		ldd r27,Y+6
 7162 2588 5296      		adiw r26,18
 7163 258a 4D93      		st X+,r20
 7164 258c 5D93      		st X+,r21
 7165 258e 6D93      		st X+,r22
 7166 2590 7C93      		st X,r23
 7167 2592 5597      		sbiw r26,18+3
2992:ff.c          **** 					fp->fptr += bcs;
 7169               	.LM717:
 7170 2594 FD01      		movw r30,r26
 7171 2596 8681      		ldd r24,Z+6
 7172 2598 9781      		ldd r25,Z+7
 7173 259a A085      		ldd r26,Z+8
 7174 259c B185      		ldd r27,Z+9
 7175 259e 840D      		add r24,r4
 7176 25a0 951D      		adc r25,r5
 7177 25a2 A61D      		adc r26,r6
 7178 25a4 B71D      		adc r27,r7
 7179 25a6 8683      		std Z+6,r24
 7180 25a8 9783      		std Z+7,r25
 7181 25aa A087      		std Z+8,r26
 7182 25ac B187      		std Z+9,r27
2993:ff.c          **** 					ofs -= bcs;
 7184               	.LM718:
 7185 25ae C418      		sub r12,r4
 7186 25b0 D508      		sbc r13,r5
 7187 25b2 E608      		sbc r14,r6
 7188 25b4 F708      		sbc r15,r7
 7189               	.L528:
2979:ff.c          **** 				while (ofs > bcs) {						/* Cluster following loop */
 7191               	.LM719:
 7192 25b6 4C14      		cp r4,r12
 7193 25b8 5D04      		cpc r5,r13
 7194 25ba 6E04      		cpc r6,r14
 7195 25bc 7F04      		cpc r7,r15
 7196 25be 00F4      		brsh .+2
 7197 25c0 00C0      		rjmp .L504
 7198 25c2 00C0      		rjmp .L499
 7199               	.L512:
2983:ff.c          **** 						if (clst == 0) {				/* When disk gets full, clip file size */
 7201               	.LM720:
 7202 25c4 7301      		movw r14,r6
 7203 25c6 6201      		movw r12,r4
 7204               	.L499:
2995:ff.c          **** 				fp->fptr += ofs;
 7206               	.LM721:
 7207 25c8 ED81      		ldd r30,Y+5
 7208 25ca FE81      		ldd r31,Y+6
 7209 25cc 8681      		ldd r24,Z+6
 7210 25ce 9781      		ldd r25,Z+7
 7211 25d0 A085      		ldd r26,Z+8
 7212 25d2 B185      		ldd r27,Z+9
 7213 25d4 8C0D      		add r24,r12
 7214 25d6 9D1D      		adc r25,r13
 7215 25d8 AE1D      		adc r26,r14
 7216 25da BF1D      		adc r27,r15
 7217 25dc 8683      		std Z+6,r24
 7218 25de 9783      		std Z+7,r25
 7219 25e0 A087      		std Z+8,r26
 7220 25e2 B187      		std Z+9,r27
2996:ff.c          **** 				if (ofs % SS(fp->fs)) {
 7222               	.LM722:
 7223 25e4 D701      		movw r26,r14
 7224 25e6 C601      		movw r24,r12
 7225 25e8 9170      		andi r25,1
 7226 25ea AA27      		clr r26
 7227 25ec BB27      		clr r27
 7228 25ee 892B      		or r24,r25
 7229 25f0 8A2B      		or r24,r26
 7230 25f2 8B2B      		or r24,r27
 7231 25f4 01F4      		brne .+2
 7232 25f6 00C0      		rjmp .L496
2997:ff.c          **** 					nsect = clust2sect(fp->fs, clst);	/* Current sector */
 7234               	.LM723:
 7235 25f8 8081      		ld r24,Z
 7236 25fa 9181      		ldd r25,Z+1
 7237 25fc 0E94 0000 		call clust2sect
2998:ff.c          **** 					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
 7239               	.LM724:
 7240 2600 6115      		cp r22,__zero_reg__
 7241 2602 7105      		cpc r23,__zero_reg__
 7242 2604 8105      		cpc r24,__zero_reg__
 7243 2606 9105      		cpc r25,__zero_reg__
 7244 2608 01F4      		brne .L505
2998:ff.c          **** 					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
 7246               	.LM725:
 7247 260a AD81      		ldd r26,Y+5
 7248 260c BE81      		ldd r27,Y+6
 7249 260e 1496      		adiw r26,4
 7250 2610 8C91      		ld r24,X
 7251 2612 1497      		sbiw r26,4
 7252 2614 8068      		ori r24,lo8(-128)
 7253 2616 1496      		adiw r26,4
 7254 2618 8C93      		st X,r24
 7255 261a 00C0      		rjmp .L510
 7256               	.L505:
2999:ff.c          **** 					nsect += ofs / SS(fp->fs);
 7258               	.LM726:
 7259 261c 49E0      		ldi r20,9
 7260               		1:
 7261 261e F694      		lsr r15
 7262 2620 E794      		ror r14
 7263 2622 D794      		ror r13
 7264 2624 C794      		ror r12
 7265 2626 4A95      		dec r20
 7266 2628 01F4      		brne 1b
 7267 262a C60E      		add r12,r22
 7268 262c D71E      		adc r13,r23
 7269 262e E81E      		adc r14,r24
 7270 2630 F91E      		adc r15,r25
 7271               	.L490:
3003:ff.c          **** 		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
 7273               	.LM727:
 7274 2632 ED81      		ldd r30,Y+5
 7275 2634 FE81      		ldd r31,Y+6
 7276 2636 8681      		ldd r24,Z+6
 7277 2638 9781      		ldd r25,Z+7
 7278 263a A085      		ldd r26,Z+8
 7279 263c B185      		ldd r27,Z+9
 7280 263e 9170      		andi r25,1
 7281 2640 AA27      		clr r26
 7282 2642 BB27      		clr r27
 7283 2644 892B      		or r24,r25
 7284 2646 8A2B      		or r24,r26
 7285 2648 8B2B      		or r24,r27
 7286 264a 01F4      		brne .+2
 7287 264c 00C0      		rjmp .L506
3003:ff.c          **** 		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
 7289               	.LM728:
 7290 264e 2689      		ldd r18,Z+22
 7291 2650 3789      		ldd r19,Z+23
 7292 2652 408D      		ldd r20,Z+24
 7293 2654 518D      		ldd r21,Z+25
 7294 2656 C216      		cp r12,r18
 7295 2658 D306      		cpc r13,r19
 7296 265a E406      		cpc r14,r20
 7297 265c F506      		cpc r15,r21
 7298 265e 01F0      		breq .L506
3006:ff.c          **** 			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
 7300               	.LM729:
 7301 2660 8481      		ldd r24,Z+4
 7302 2662 86FF      		sbrs r24,6
 7303 2664 00C0      		rjmp .L507
3007:ff.c          **** 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 7305               	.LM730:
 7306 2666 BF01      		movw r22,r30
 7307 2668 605E      		subi r22,-32
 7308 266a 7F4F      		sbci r23,-1
 7309 266c 0190      		ld __tmp_reg__,Z+
 7310 266e F081      		ld r31,Z
 7311 2670 E02D      		mov r30,__tmp_reg__
 7312 2672 01E0      		ldi r16,lo8(1)
 7313 2674 8181      		ldd r24,Z+1
 7314 2676 0E94 0000 		call disk_write
 7315 267a AD81      		ldd r26,Y+5
 7316 267c BE81      		ldd r27,Y+6
 7317 267e 1496      		adiw r26,4
 7318 2680 9C91      		ld r25,X
 7319 2682 1497      		sbiw r26,4
 7320 2684 8823      		tst r24
 7321 2686 01F0      		breq .L508
3008:ff.c          **** 					ABORT(fp->fs, FR_DISK_ERR);
 7323               	.LM731:
 7324 2688 9068      		ori r25,lo8(-128)
 7325 268a 1496      		adiw r26,4
 7326 268c 9C93      		st X,r25
 7327 268e 00C0      		rjmp .L529
 7328               	.L508:
3009:ff.c          **** 				fp->flag &= ~FA__DIRTY;
 7330               	.LM732:
 7331 2690 9F7B      		andi r25,lo8(-65)
 7332 2692 ED81      		ldd r30,Y+5
 7333 2694 FE81      		ldd r31,Y+6
 7334 2696 9483      		std Z+4,r25
 7335               	.L507:
3012:ff.c          **** 			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
 7337               	.LM733:
 7338 2698 6D81      		ldd r22,Y+5
 7339 269a 7E81      		ldd r23,Y+6
 7340 269c 605E      		subi r22,-32
 7341 269e 7F4F      		sbci r23,-1
 7342 26a0 AD81      		ldd r26,Y+5
 7343 26a2 BE81      		ldd r27,Y+6
 7344 26a4 ED91      		ld r30,X+
 7345 26a6 FC91      		ld r31,X
 7346 26a8 01E0      		ldi r16,lo8(1)
 7347 26aa A701      		movw r20,r14
 7348 26ac 9601      		movw r18,r12
 7349 26ae 8181      		ldd r24,Z+1
 7350 26b0 0E94 0000 		call disk_read
 7351 26b4 8823      		tst r24
 7352 26b6 01F0      		breq .L509
3013:ff.c          **** 				ABORT(fp->fs, FR_DISK_ERR);
 7354               	.LM734:
 7355 26b8 ED81      		ldd r30,Y+5
 7356 26ba FE81      		ldd r31,Y+6
 7357 26bc 8481      		ldd r24,Z+4
 7358 26be 8068      		ori r24,lo8(-128)
 7359 26c0 8483      		std Z+4,r24
 7360               	.L529:
 7361 26c2 11E0      		ldi r17,lo8(1)
 7362 26c4 00C0      		rjmp .L487
 7363               	.L509:
3015:ff.c          **** 			fp->dsect = nsect;
 7365               	.LM735:
 7366 26c6 AD81      		ldd r26,Y+5
 7367 26c8 BE81      		ldd r27,Y+6
 7368 26ca 5696      		adiw r26,22
 7369 26cc CD92      		st X+,r12
 7370 26ce DD92      		st X+,r13
 7371 26d0 ED92      		st X+,r14
 7372 26d2 FC92      		st X,r15
 7373 26d4 5997      		sbiw r26,22+3
 7374               	.L506:
3018:ff.c          **** 		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
 7376               	.LM736:
 7377 26d6 ED81      		ldd r30,Y+5
 7378 26d8 FE81      		ldd r31,Y+6
 7379 26da 8681      		ldd r24,Z+6
 7380 26dc 9781      		ldd r25,Z+7
 7381 26de A085      		ldd r26,Z+8
 7382 26e0 B185      		ldd r27,Z+9
 7383 26e2 4285      		ldd r20,Z+10
 7384 26e4 5385      		ldd r21,Z+11
 7385 26e6 6485      		ldd r22,Z+12
 7386 26e8 7585      		ldd r23,Z+13
 7387 26ea 4817      		cp r20,r24
 7388 26ec 5907      		cpc r21,r25
 7389 26ee 6A07      		cpc r22,r26
 7390 26f0 7B07      		cpc r23,r27
 7391 26f2 00F4      		brsh .L487
3019:ff.c          **** 			fp->fsize = fp->fptr;
 7393               	.LM737:
 7394 26f4 8287      		std Z+10,r24
 7395 26f6 9387      		std Z+11,r25
 7396 26f8 A487      		std Z+12,r26
 7397 26fa B587      		std Z+13,r27
3020:ff.c          **** 			fp->flag |= FA__WRITTEN;
 7399               	.LM738:
 7400 26fc 8481      		ldd r24,Z+4
 7401 26fe 8062      		ori r24,lo8(32)
 7402 2700 8483      		std Z+4,r24
 7403 2702 00C0      		rjmp .L487
 7404               	.L510:
 7405               	.LBE101:
2888:ff.c          **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
 7407               	.LM739:
 7408 2704 12E0      		ldi r17,lo8(2)
 7409               	.L487:
3026:ff.c          **** }
 7411               	.LM740:
 7412 2706 812F      		mov r24,r17
 7413               	/* epilogue start */
 7414 2708 2696      		adiw r28,6
 7415 270a 0FB6      		in __tmp_reg__,__SREG__
 7416 270c F894      		cli
 7417 270e DEBF      		out __SP_H__,r29
 7418 2710 0FBE      		out __SREG__,__tmp_reg__
 7419 2712 CDBF      		out __SP_L__,r28
 7420 2714 DF91      		pop r29
 7421 2716 CF91      		pop r28
 7422 2718 1F91      		pop r17
 7423 271a 0F91      		pop r16
 7424 271c FF90      		pop r15
 7425 271e EF90      		pop r14
 7426 2720 DF90      		pop r13
 7427 2722 CF90      		pop r12
 7428 2724 BF90      		pop r11
 7429 2726 AF90      		pop r10
 7430 2728 9F90      		pop r9
 7431 272a 8F90      		pop r8
 7432 272c 7F90      		pop r7
 7433 272e 6F90      		pop r6
 7434 2730 5F90      		pop r5
 7435 2732 4F90      		pop r4
 7436 2734 3F90      		pop r3
 7437 2736 2F90      		pop r2
 7438 2738 0895      		ret
 7448               	.Lscope27:
 7450               		.stabd	78,0,0
 7454               	.global	f_opendir
 7456               	f_opendir:
 7457               		.stabd	46,0,0
3039:ff.c          **** {
 7459               	.LM741:
 7460               	.LFBB28:
 7461 273a EF92      		push r14
 7462 273c FF92      		push r15
 7463 273e 0F93      		push r16
 7464 2740 1F93      		push r17
 7465 2742 CF93      		push r28
 7466 2744 DF93      		push r29
 7467 2746 CDB7      		in r28,__SP_L__
 7468 2748 DEB7      		in r29,__SP_H__
 7469 274a 2E97      		sbiw r28,14
 7470 274c 0FB6      		in __tmp_reg__,__SREG__
 7471 274e F894      		cli
 7472 2750 DEBF      		out __SP_H__,r29
 7473 2752 0FBE      		out __SREG__,__tmp_reg__
 7474 2754 CDBF      		out __SP_L__,r28
 7475               	/* prologue: function */
 7476               	/* frame size = 14 */
 7477               	/* stack size = 20 */
 7478               	.L__stack_usage = 20
 7479 2756 8C01      		movw r16,r24
 7480 2758 7E87      		std Y+14,r23
 7481 275a 6D87      		std Y+13,r22
3045:ff.c          **** 	if (!dj) return FR_INVALID_OBJECT;
 7483               	.LM742:
 7484 275c 0097      		sbiw r24,0
 7485 275e 01F0      		breq .L537
3047:ff.c          **** 	res = chk_mounted(&path, &dj->fs, 0);
 7487               	.LM743:
 7488 2760 40E0      		ldi r20,0
 7489 2762 BC01      		movw r22,r24
 7490 2764 CE01      		movw r24,r28
 7491 2766 0D96      		adiw r24,13
 7492 2768 0E94 0000 		call chk_mounted
3048:ff.c          **** 	fs = dj->fs;
 7494               	.LM744:
 7495 276c F801      		movw r30,r16
 7496 276e E080      		ld r14,Z
 7497 2770 F180      		ldd r15,Z+1
3049:ff.c          **** 	if (res == FR_OK) {
 7499               	.LM745:
 7500 2772 8111      		cpse r24,__zero_reg__
 7501 2774 00C0      		rjmp .L533
3050:ff.c          **** 		INIT_BUF(*dj);
 7503               	.LM746:
 7504 2776 CE01      		movw r24,r28
 7505 2778 0196      		adiw r24,1
 7506 277a 958B      		std Z+21,r25
 7507 277c 848B      		std Z+20,r24
3051:ff.c          **** 		res = follow_path(dj, path);			/* Follow the path to the directory */
 7509               	.LM747:
 7510 277e 6D85      		ldd r22,Y+13
 7511 2780 7E85      		ldd r23,Y+14
 7512 2782 C801      		movw r24,r16
 7513 2784 0E94 0000 		call follow_path
3053:ff.c          **** 		if (res == FR_OK) {						/* Follow completed */
 7515               	.LM748:
 7516 2788 8111      		cpse r24,__zero_reg__
 7517 278a 00C0      		rjmp .L534
3054:ff.c          **** 			if (dj->dir) {						/* It is not the root dir */
 7519               	.LM749:
 7520 278c F801      		movw r30,r16
 7521 278e 6289      		ldd r22,Z+18
 7522 2790 7389      		ldd r23,Z+19
 7523 2792 6115      		cp r22,__zero_reg__
 7524 2794 7105      		cpc r23,__zero_reg__
 7525 2796 01F0      		breq .L535
3055:ff.c          **** 				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
 7527               	.LM750:
 7528 2798 FB01      		movw r30,r22
 7529 279a 8385      		ldd r24,Z+11
 7530 279c 84FF      		sbrs r24,4
 7531 279e 00C0      		rjmp .L539
3056:ff.c          **** 					dj->sclust = ld_clust(fs, dj->dir);
 7533               	.LM751:
 7534 27a0 F701      		movw r30,r14
 7535 27a2 8081      		ld r24,Z
 7536 27a4 0E94 0000 		call ld_clust.isra.0
 7537 27a8 F801      		movw r30,r16
 7538 27aa 6683      		std Z+6,r22
 7539 27ac 7783      		std Z+7,r23
 7540 27ae 8087      		std Z+8,r24
 7541 27b0 9187      		std Z+9,r25
 7542 27b2 00C0      		rjmp .L535
 7543               	.L534:
3066:ff.c          **** 		if (res == FR_NO_FILE) res = FR_NO_PATH;
 7545               	.LM752:
 7546 27b4 8430      		cpi r24,lo8(4)
 7547 27b6 01F0      		breq .L539
3067:ff.c          **** 		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
 7549               	.LM753:
 7550 27b8 8823      		tst r24
 7551 27ba 01F0      		breq .L542
 7552 27bc 00C0      		rjmp .L533
 7553               	.L539:
3066:ff.c          **** 		if (res == FR_NO_FILE) res = FR_NO_PATH;
 7555               	.LM754:
 7556 27be 85E0      		ldi r24,lo8(5)
 7557               	.L533:
3069:ff.c          **** 		dj->fs = 0;
 7559               	.LM755:
 7560 27c0 F801      		movw r30,r16
 7561 27c2 1182      		std Z+1,__zero_reg__
 7562 27c4 1082      		st Z,__zero_reg__
 7563 27c6 00C0      		rjmp .L542
 7564               	.L537:
3045:ff.c          **** 	if (!dj) return FR_INVALID_OBJECT;
 7566               	.LM756:
 7567 27c8 89E0      		ldi r24,lo8(9)
 7568 27ca 00C0      		rjmp .L542
 7569               	.L535:
3062:ff.c          **** 				dj->id = fs->id;
 7571               	.LM757:
 7572 27cc F701      		movw r30,r14
 7573 27ce 8681      		ldd r24,Z+6
 7574 27d0 9781      		ldd r25,Z+7
 7575 27d2 F801      		movw r30,r16
 7576 27d4 9383      		std Z+3,r25
 7577 27d6 8283      		std Z+2,r24
3063:ff.c          **** 				res = dir_sdi(dj, 0);			/* Rewind dir */
 7579               	.LM758:
 7580 27d8 60E0      		ldi r22,0
 7581 27da 70E0      		ldi r23,0
 7582 27dc C801      		movw r24,r16
 7583 27de 0E94 0000 		call dir_sdi
 7584 27e2 00C0      		rjmp .L534
 7585               	.L542:
 7586               	/* epilogue start */
3073:ff.c          **** }
 7588               	.LM759:
 7589 27e4 2E96      		adiw r28,14
 7590 27e6 0FB6      		in __tmp_reg__,__SREG__
 7591 27e8 F894      		cli
 7592 27ea DEBF      		out __SP_H__,r29
 7593 27ec 0FBE      		out __SREG__,__tmp_reg__
 7594 27ee CDBF      		out __SP_L__,r28
 7595 27f0 DF91      		pop r29
 7596 27f2 CF91      		pop r28
 7597 27f4 1F91      		pop r17
 7598 27f6 0F91      		pop r16
 7599 27f8 FF90      		pop r15
 7600 27fa EF90      		pop r14
 7601 27fc 0895      		ret
 7608               	.Lscope28:
 7610               		.stabd	78,0,0
 7614               	.global	f_readdir
 7616               	f_readdir:
 7617               		.stabd	46,0,0
3086:ff.c          **** {
 7619               	.LM760:
 7620               	.LFBB29:
 7621 27fe DF92      		push r13
 7622 2800 EF92      		push r14
 7623 2802 FF92      		push r15
 7624 2804 0F93      		push r16
 7625 2806 1F93      		push r17
 7626 2808 CF93      		push r28
 7627 280a DF93      		push r29
 7628 280c CDB7      		in r28,__SP_L__
 7629 280e DEB7      		in r29,__SP_H__
 7630 2810 2C97      		sbiw r28,12
 7631 2812 0FB6      		in __tmp_reg__,__SREG__
 7632 2814 F894      		cli
 7633 2816 DEBF      		out __SP_H__,r29
 7634 2818 0FBE      		out __SREG__,__tmp_reg__
 7635 281a CDBF      		out __SP_L__,r28
 7636               	/* prologue: function */
 7637               	/* frame size = 12 */
 7638               	/* stack size = 19 */
 7639               	.L__stack_usage = 19
 7640 281c 8C01      		movw r16,r24
 7641 281e 7B01      		movw r14,r22
3091:ff.c          **** 	res = validate(dj);						/* Check validity of the object */
 7643               	.LM761:
 7644 2820 0E94 0000 		call validate
 7645 2824 D82E      		mov r13,r24
3092:ff.c          **** 	if (res == FR_OK) {
 7647               	.LM762:
 7648 2826 8111      		cpse r24,__zero_reg__
 7649 2828 00C0      		rjmp .L548
3093:ff.c          **** 		if (!fno) {
 7651               	.LM763:
 7652 282a E114      		cp r14,__zero_reg__
 7653 282c F104      		cpc r15,__zero_reg__
 7654 282e 01F4      		brne .L549
3094:ff.c          **** 			res = dir_sdi(dj, 0);			/* Rewind the directory object */
 7656               	.LM764:
 7657 2830 60E0      		ldi r22,0
 7658 2832 70E0      		ldi r23,0
 7659 2834 C801      		movw r24,r16
 7660 2836 0E94 0000 		call dir_sdi
 7661 283a 00C0      		rjmp .L553
 7662               	.L549:
3096:ff.c          **** 			INIT_BUF(*dj);
 7664               	.LM765:
 7665 283c 9E01      		movw r18,r28
 7666 283e 2F5F      		subi r18,-1
 7667 2840 3F4F      		sbci r19,-1
 7668 2842 F801      		movw r30,r16
 7669 2844 358B      		std Z+21,r19
 7670 2846 248B      		std Z+20,r18
3097:ff.c          **** 			res = dir_read(dj, 0);			/* Read an item */
 7672               	.LM766:
 7673 2848 C801      		movw r24,r16
 7674 284a 0E94 0000 		call dir_read.constprop.10
3098:ff.c          **** 			if (res == FR_NO_FILE) {		/* Reached end of dir */
 7676               	.LM767:
 7677 284e 8430      		cpi r24,lo8(4)
 7678 2850 01F4      		brne .L550
3099:ff.c          **** 				dj->sect = 0;
 7680               	.LM768:
 7681 2852 F801      		movw r30,r16
 7682 2854 1686      		std Z+14,__zero_reg__
 7683 2856 1786      		std Z+15,__zero_reg__
 7684 2858 108A      		std Z+16,__zero_reg__
 7685 285a 118A      		std Z+17,__zero_reg__
 7686 285c 00C0      		rjmp .L551
 7687               	.L550:
3102:ff.c          **** 			if (res == FR_OK) {				/* A valid entry is found */
 7689               	.LM769:
 7690 285e 8111      		cpse r24,__zero_reg__
 7691 2860 00C0      		rjmp .L553
 7692               	.L551:
3103:ff.c          **** 				get_fileinfo(dj, fno);		/* Get the object information */
 7694               	.LM770:
 7695 2862 B701      		movw r22,r14
 7696 2864 C801      		movw r24,r16
 7697 2866 0E94 0000 		call get_fileinfo
3104:ff.c          **** 				res = dir_next(dj, 0);		/* Increment index for next */
 7699               	.LM771:
 7700 286a 60E0      		ldi r22,0
 7701 286c 70E0      		ldi r23,0
 7702 286e C801      		movw r24,r16
 7703 2870 0E94 0000 		call dir_next
3105:ff.c          **** 				if (res == FR_NO_FILE) {
 7705               	.LM772:
 7706 2874 8430      		cpi r24,lo8(4)
 7707 2876 01F4      		brne .L553
3106:ff.c          **** 					dj->sect = 0;
 7709               	.LM773:
 7710 2878 F801      		movw r30,r16
 7711 287a 1686      		std Z+14,__zero_reg__
 7712 287c 1786      		std Z+15,__zero_reg__
 7713 287e 108A      		std Z+16,__zero_reg__
 7714 2880 118A      		std Z+17,__zero_reg__
 7715 2882 00C0      		rjmp .L548
 7716               	.L553:
3105:ff.c          **** 				if (res == FR_NO_FILE) {
 7718               	.LM774:
 7719 2884 D82E      		mov r13,r24
 7720               	.L548:
3115:ff.c          **** }
 7722               	.LM775:
 7723 2886 8D2D      		mov r24,r13
 7724               	/* epilogue start */
 7725 2888 2C96      		adiw r28,12
 7726 288a 0FB6      		in __tmp_reg__,__SREG__
 7727 288c F894      		cli
 7728 288e DEBF      		out __SP_H__,r29
 7729 2890 0FBE      		out __SREG__,__tmp_reg__
 7730 2892 CDBF      		out __SP_L__,r28
 7731 2894 DF91      		pop r29
 7732 2896 CF91      		pop r28
 7733 2898 1F91      		pop r17
 7734 289a 0F91      		pop r16
 7735 289c FF90      		pop r15
 7736 289e EF90      		pop r14
 7737 28a0 DF90      		pop r13
 7738 28a2 0895      		ret
 7743               	.Lscope29:
 7745               		.stabd	78,0,0
 7749               	.global	f_stat
 7751               	f_stat:
 7752               		.stabd	46,0,0
3128:ff.c          **** {
 7754               	.LM776:
 7755               	.LFBB30:
 7756 28a4 FF92      		push r15
 7757 28a6 0F93      		push r16
 7758 28a8 1F93      		push r17
 7759 28aa CF93      		push r28
 7760 28ac DF93      		push r29
 7761 28ae CDB7      		in r28,__SP_L__
 7762 28b0 DEB7      		in r29,__SP_H__
 7763 28b2 A497      		sbiw r28,36
 7764 28b4 0FB6      		in __tmp_reg__,__SREG__
 7765 28b6 F894      		cli
 7766 28b8 DEBF      		out __SP_H__,r29
 7767 28ba 0FBE      		out __SREG__,__tmp_reg__
 7768 28bc CDBF      		out __SP_L__,r28
 7769               	/* prologue: function */
 7770               	/* frame size = 36 */
 7771               	/* stack size = 41 */
 7772               	.L__stack_usage = 41
 7773 28be 9CA3      		std Y+36,r25
 7774 28c0 8BA3      		std Y+35,r24
 7775 28c2 8B01      		movw r16,r22
3134:ff.c          **** 	res = chk_mounted(&path, &dj.fs, 0);
 7777               	.LM777:
 7778 28c4 40E0      		ldi r20,0
 7779 28c6 BE01      		movw r22,r28
 7780 28c8 6F5F      		subi r22,-1
 7781 28ca 7F4F      		sbci r23,-1
 7782 28cc CE01      		movw r24,r28
 7783 28ce 8396      		adiw r24,35
 7784 28d0 0E94 0000 		call chk_mounted
 7785 28d4 F82E      		mov r15,r24
3135:ff.c          **** 	if (res == FR_OK) {
 7787               	.LM778:
 7788 28d6 8111      		cpse r24,__zero_reg__
 7789 28d8 00C0      		rjmp .L555
3136:ff.c          **** 		INIT_BUF(dj);
 7791               	.LM779:
 7792 28da CE01      		movw r24,r28
 7793 28dc 4796      		adiw r24,23
 7794 28de 9E8B      		std Y+22,r25
 7795 28e0 8D8B      		std Y+21,r24
3137:ff.c          **** 		res = follow_path(&dj, path);	/* Follow the file path */
 7797               	.LM780:
 7798 28e2 6BA1      		ldd r22,Y+35
 7799 28e4 7CA1      		ldd r23,Y+36
 7800 28e6 CE01      		movw r24,r28
 7801 28e8 0196      		adiw r24,1
 7802 28ea 0E94 0000 		call follow_path
 7803 28ee F82E      		mov r15,r24
3138:ff.c          **** 		if (res == FR_OK) {				/* Follow completed */
 7805               	.LM781:
 7806 28f0 8111      		cpse r24,__zero_reg__
 7807 28f2 00C0      		rjmp .L555
3139:ff.c          **** 			if (dj.dir)		/* Found an object */
 7809               	.LM782:
 7810 28f4 2B89      		ldd r18,Y+19
 7811 28f6 3C89      		ldd r19,Y+20
 7812 28f8 232B      		or r18,r19
 7813 28fa 01F0      		breq .L556
3140:ff.c          **** 				get_fileinfo(&dj, fno);
 7815               	.LM783:
 7816 28fc B801      		movw r22,r16
 7817 28fe CE01      		movw r24,r28
 7818 2900 0196      		adiw r24,1
 7819 2902 0E94 0000 		call get_fileinfo
 7820 2906 00C0      		rjmp .L555
 7821               	.L556:
3142:ff.c          **** 				res = FR_INVALID_NAME;
 7823               	.LM784:
 7824 2908 66E0      		ldi r22,lo8(6)
 7825 290a F62E      		mov r15,r22
 7826               	.L555:
3148:ff.c          **** }
 7828               	.LM785:
 7829 290c 8F2D      		mov r24,r15
 7830               	/* epilogue start */
 7831 290e A496      		adiw r28,36
 7832 2910 0FB6      		in __tmp_reg__,__SREG__
 7833 2912 F894      		cli
 7834 2914 DEBF      		out __SP_H__,r29
 7835 2916 0FBE      		out __SREG__,__tmp_reg__
 7836 2918 CDBF      		out __SP_L__,r28
 7837 291a DF91      		pop r29
 7838 291c CF91      		pop r28
 7839 291e 1F91      		pop r17
 7840 2920 0F91      		pop r16
 7841 2922 FF90      		pop r15
 7842 2924 0895      		ret
 7849               	.Lscope30:
 7851               		.stabd	78,0,0
 7856               	.global	f_getfree
 7858               	f_getfree:
 7859               		.stabd	46,0,0
3162:ff.c          **** {
 7861               	.LM786:
 7862               	.LFBB31:
 7863 2926 2F92      		push r2
 7864 2928 3F92      		push r3
 7865 292a 4F92      		push r4
 7866 292c 5F92      		push r5
 7867 292e 6F92      		push r6
 7868 2930 7F92      		push r7
 7869 2932 8F92      		push r8
 7870 2934 9F92      		push r9
 7871 2936 AF92      		push r10
 7872 2938 BF92      		push r11
 7873 293a CF92      		push r12
 7874 293c DF92      		push r13
 7875 293e EF92      		push r14
 7876 2940 FF92      		push r15
 7877 2942 0F93      		push r16
 7878 2944 1F93      		push r17
 7879 2946 CF93      		push r28
 7880 2948 DF93      		push r29
 7881 294a CDB7      		in r28,__SP_L__
 7882 294c DEB7      		in r29,__SP_H__
 7883 294e 6097      		sbiw r28,16
 7884 2950 0FB6      		in __tmp_reg__,__SREG__
 7885 2952 F894      		cli
 7886 2954 DEBF      		out __SP_H__,r29
 7887 2956 0FBE      		out __SREG__,__tmp_reg__
 7888 2958 CDBF      		out __SP_L__,r28
 7889               	/* prologue: function */
 7890               	/* frame size = 16 */
 7891               	/* stack size = 34 */
 7892               	.L__stack_usage = 34
 7893 295a 9A83      		std Y+2,r25
 7894 295c 8983      		std Y+1,r24
 7895 295e 7C83      		std Y+4,r23
 7896 2960 6B83      		std Y+3,r22
 7897 2962 8A01      		movw r16,r20
3171:ff.c          **** 	res = chk_mounted(&path, fatfs, 0);
 7899               	.LM787:
 7900 2964 40E0      		ldi r20,0
 7901 2966 B801      		movw r22,r16
 7902 2968 CE01      		movw r24,r28
 7903 296a 0196      		adiw r24,1
 7904 296c 0E94 0000 		call chk_mounted
 7905 2970 382E      		mov r3,r24
3172:ff.c          **** 	fs = *fatfs;
 7907               	.LM788:
 7908 2972 D801      		movw r26,r16
 7909 2974 0D91      		ld r16,X+
 7910 2976 1C91      		ld r17,X
3173:ff.c          **** 	if (res == FR_OK) {
 7912               	.LM789:
 7913 2978 8111      		cpse r24,__zero_reg__
 7914 297a 00C0      		rjmp .L558
3175:ff.c          **** 		if (fs->free_clust <= fs->n_fatent - 2) {
 7916               	.LM790:
 7917 297c F801      		movw r30,r16
 7918 297e 8685      		ldd r24,Z+14
 7919 2980 9785      		ldd r25,Z+15
 7920 2982 A089      		ldd r26,Z+16
 7921 2984 B189      		ldd r27,Z+17
 7922 2986 8688      		ldd r8,Z+22
 7923 2988 9788      		ldd r9,Z+23
 7924 298a A08C      		ldd r10,Z+24
 7925 298c B18C      		ldd r11,Z+25
 7926 298e B501      		movw r22,r10
 7927 2990 A401      		movw r20,r8
 7928 2992 4250      		subi r20,2
 7929 2994 5109      		sbc r21,__zero_reg__
 7930 2996 6109      		sbc r22,__zero_reg__
 7931 2998 7109      		sbc r23,__zero_reg__
 7932 299a 4817      		cp r20,r24
 7933 299c 5907      		cpc r21,r25
 7934 299e 6A07      		cpc r22,r26
 7935 29a0 7B07      		cpc r23,r27
 7936 29a2 00F0      		brlo .L559
3176:ff.c          **** 			*nclst = fs->free_clust;
 7938               	.LM791:
 7939 29a4 EB81      		ldd r30,Y+3
 7940 29a6 FC81      		ldd r31,Y+4
 7941 29a8 8083      		st Z,r24
 7942 29aa 9183      		std Z+1,r25
 7943 29ac A283      		std Z+2,r26
 7944 29ae B383      		std Z+3,r27
 7945 29b0 00C0      		rjmp .L558
 7946               	.L559:
3179:ff.c          **** 			fat = fs->fs_type;
 7948               	.LM792:
 7949 29b2 2080      		ld r2,Z
3181:ff.c          **** 			if (fat == FS_FAT12) {
 7951               	.LM793:
 7952 29b4 B1E0      		ldi r27,lo8(1)
 7953 29b6 2B12      		cpse r2,r27
 7954 29b8 00C0      		rjmp .L560
 7955 29ba 82E0      		ldi r24,lo8(2)
 7956 29bc 882E      		mov r8,r24
 7957 29be 912C      		mov r9,__zero_reg__
 7958 29c0 A12C      		mov r10,__zero_reg__
 7959 29c2 B12C      		mov r11,__zero_reg__
 7960 29c4 C12C      		mov r12,__zero_reg__
 7961 29c6 D12C      		mov r13,__zero_reg__
 7962 29c8 7601      		movw r14,r12
 7963               	.L563:
3184:ff.c          **** 					stat = get_fat(fs, clst);
 7965               	.LM794:
 7966 29ca B501      		movw r22,r10
 7967 29cc A401      		movw r20,r8
 7968 29ce C801      		movw r24,r16
 7969 29d0 0E94 0000 		call get_fat
3185:ff.c          **** 					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
 7971               	.LM795:
 7972 29d4 6F3F      		cpi r22,-1
 7973 29d6 EFEF      		ldi r30,-1
 7974 29d8 7E07      		cpc r23,r30
 7975 29da 8E07      		cpc r24,r30
 7976 29dc 9E07      		cpc r25,r30
 7977 29de 01F4      		brne .+2
 7978 29e0 00C0      		rjmp .L571
3186:ff.c          **** 					if (stat == 1) { res = FR_INT_ERR; break; }
 7980               	.LM796:
 7981 29e2 6130      		cpi r22,1
 7982 29e4 7105      		cpc r23,__zero_reg__
 7983 29e6 8105      		cpc r24,__zero_reg__
 7984 29e8 9105      		cpc r25,__zero_reg__
 7985 29ea 01F4      		brne .+2
 7986 29ec 00C0      		rjmp .L572
3187:ff.c          **** 					if (stat == 0) n++;
 7988               	.LM797:
 7989 29ee 672B      		or r22,r23
 7990 29f0 682B      		or r22,r24
 7991 29f2 692B      		or r22,r25
 7992 29f4 01F4      		brne .L562
3187:ff.c          **** 					if (stat == 0) n++;
 7994               	.LM798:
 7995 29f6 FFEF      		ldi r31,-1
 7996 29f8 CF1A      		sub r12,r31
 7997 29fa DF0A      		sbc r13,r31
 7998 29fc EF0A      		sbc r14,r31
 7999 29fe FF0A      		sbc r15,r31
 8000               	.L562:
3188:ff.c          **** 				} while (++clst < fs->n_fatent);
 8002               	.LM799:
 8003 2a00 2FEF      		ldi r18,-1
 8004 2a02 821A      		sub r8,r18
 8005 2a04 920A      		sbc r9,r18
 8006 2a06 A20A      		sbc r10,r18
 8007 2a08 B20A      		sbc r11,r18
 8008 2a0a F801      		movw r30,r16
 8009 2a0c 8689      		ldd r24,Z+22
 8010 2a0e 9789      		ldd r25,Z+23
 8011 2a10 A08D      		ldd r26,Z+24
 8012 2a12 B18D      		ldd r27,Z+25
 8013 2a14 8816      		cp r8,r24
 8014 2a16 9906      		cpc r9,r25
 8015 2a18 AA06      		cpc r10,r26
 8016 2a1a BB06      		cpc r11,r27
 8017 2a1c 00F0      		brlo .L563
 8018 2a1e 00C0      		rjmp .L561
 8019               	.L560:
3191:ff.c          **** 				sect = fs->fatbase;
 8021               	.LM800:
 8022 2a20 42A1      		ldd r20,Z+34
 8023 2a22 53A1      		ldd r21,Z+35
 8024 2a24 64A1      		ldd r22,Z+36
 8025 2a26 75A1      		ldd r23,Z+37
3192:ff.c          **** 				i = 0; p = 0;
 8027               	.LM801:
 8028 2a28 E0E0      		ldi r30,0
 8029 2a2a F0E0      		ldi r31,0
 8030 2a2c 188A      		std Y+16,__zero_reg__
 8031 2a2e 1F86      		std Y+15,__zero_reg__
3180:ff.c          **** 			n = 0;
 8033               	.LM802:
 8034 2a30 C12C      		mov r12,__zero_reg__
 8035 2a32 D12C      		mov r13,__zero_reg__
 8036 2a34 7601      		movw r14,r12
3197:ff.c          **** 						p = fs->win;
 8038               	.LM803:
 8039 2a36 9801      		movw r18,r16
 8040 2a38 2E5C      		subi r18,-50
 8041 2a3a 3F4F      		sbci r19,-1
 8042 2a3c 3E87      		std Y+14,r19
 8043 2a3e 2D87      		std Y+13,r18
 8044               	.L569:
3194:ff.c          **** 					if (!i) {
 8046               	.LM804:
 8047 2a40 8F85      		ldd r24,Y+15
 8048 2a42 9889      		ldd r25,Y+16
 8049 2a44 892B      		or r24,r25
 8050 2a46 01F4      		brne .L564
3195:ff.c          **** 						res = move_window(fs, sect++);
 8052               	.LM805:
 8053 2a48 412C      		mov r4,__zero_reg__
 8054 2a4a 512C      		mov r5,__zero_reg__
 8055 2a4c 3201      		movw r6,r4
 8056 2a4e 4394      		inc r4
 8057 2a50 440E      		add r4,r20
 8058 2a52 551E      		adc r5,r21
 8059 2a54 661E      		adc r6,r22
 8060 2a56 771E      		adc r7,r23
 8061 2a58 C801      		movw r24,r16
 8062 2a5a 0E94 0000 		call move_window
3196:ff.c          **** 						if (res != FR_OK) break;
 8064               	.LM806:
 8065 2a5e 8111      		cpse r24,__zero_reg__
 8066 2a60 00C0      		rjmp .L573
3197:ff.c          **** 						p = fs->win;
 8068               	.LM807:
 8069 2a62 ED85      		ldd r30,Y+13
 8070 2a64 FE85      		ldd r31,Y+14
3195:ff.c          **** 						res = move_window(fs, sect++);
 8072               	.LM808:
 8073 2a66 B301      		movw r22,r6
 8074 2a68 A201      		movw r20,r4
3198:ff.c          **** 						i = SS(fs);
 8076               	.LM809:
 8077 2a6a A0E0      		ldi r26,0
 8078 2a6c B2E0      		ldi r27,lo8(2)
 8079 2a6e B88B      		std Y+16,r27
 8080 2a70 AF87      		std Y+15,r26
 8081               	.L564:
3200:ff.c          **** 					if (fat == FS_FAT16) {
 8083               	.LM810:
 8084 2a72 B2E0      		ldi r27,lo8(2)
 8085 2a74 2B12      		cpse r2,r27
 8086 2a76 00C0      		rjmp .L565
3201:ff.c          **** 						if (LD_WORD(p) == 0) n++;
 8088               	.LM811:
 8089 2a78 2181      		ldd r18,Z+1
 8090 2a7a 2E83      		std Y+6,r18
 8091 2a7c 1D82      		std Y+5,__zero_reg__
 8092 2a7e 2081      		ld r18,Z
 8093 2a80 8D81      		ldd r24,Y+5
 8094 2a82 9E81      		ldd r25,Y+6
 8095 2a84 822B      		or r24,r18
 8096 2a86 9C01      		movw r18,r24
 8097 2a88 232B      		or r18,r19
 8098 2a8a 01F4      		brne .L566
3201:ff.c          **** 						if (LD_WORD(p) == 0) n++;
 8100               	.LM812:
 8101 2a8c 9FEF      		ldi r25,-1
 8102 2a8e C91A      		sub r12,r25
 8103 2a90 D90A      		sbc r13,r25
 8104 2a92 E90A      		sbc r14,r25
 8105 2a94 F90A      		sbc r15,r25
 8106               	.L566:
3202:ff.c          **** 						p += 2; i -= 2;
 8108               	.LM813:
 8109 2a96 3296      		adiw r30,2
 8110 2a98 AF85      		ldd r26,Y+15
 8111 2a9a B889      		ldd r27,Y+16
 8112 2a9c 1297      		sbiw r26,2
 8113 2a9e B88B      		std Y+16,r27
 8114 2aa0 AF87      		std Y+15,r26
 8115 2aa2 00C0      		rjmp .L567
 8116               	.L565:
3204:ff.c          **** 						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
 8118               	.LM814:
 8119 2aa4 2381      		ldd r18,Z+3
 8120 2aa6 4280      		ldd r4,Z+2
 8121 2aa8 512C      		mov r5,__zero_reg__
 8122 2aaa 612C      		mov r6,__zero_reg__
 8123 2aac 712C      		mov r7,__zero_reg__
 8124 2aae 3201      		movw r6,r4
 8125 2ab0 5524      		clr r5
 8126 2ab2 4424      		clr r4
 8127 2ab4 722A      		or r7,r18
 8128 2ab6 2081      		ld r18,Z
 8129 2ab8 422A      		or r4,r18
 8130 2aba B181      		ldd r27,Z+1
 8131 2abc B887      		std Y+8,r27
 8132 2abe 1F82      		std Y+7,__zero_reg__
 8133 2ac0 AF81      		ldd r26,Y+7
 8134 2ac2 B885      		ldd r27,Y+8
 8135 2ac4 CD01      		movw r24,r26
 8136 2ac6 A0E0      		ldi r26,0
 8137 2ac8 B0E0      		ldi r27,0
 8138 2aca 482A      		or r4,r24
 8139 2acc 592A      		or r5,r25
 8140 2ace 6A2A      		or r6,r26
 8141 2ad0 7B2A      		or r7,r27
 8142 2ad2 BFE0      		ldi r27,15
 8143 2ad4 7B22      		and r7,r27
 8144 2ad6 4528      		or r4,r5
 8145 2ad8 4628      		or r4,r6
 8146 2ada 4728      		or r4,r7
 8147 2adc 01F4      		brne .L568
3204:ff.c          **** 						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
 8149               	.LM815:
 8150 2ade 2FEF      		ldi r18,-1
 8151 2ae0 C21A      		sub r12,r18
 8152 2ae2 D20A      		sbc r13,r18
 8153 2ae4 E20A      		sbc r14,r18
 8154 2ae6 F20A      		sbc r15,r18
 8155               	.L568:
3205:ff.c          **** 						p += 4; i -= 4;
 8157               	.LM816:
 8158 2ae8 3496      		adiw r30,4
 8159 2aea 8F85      		ldd r24,Y+15
 8160 2aec 9889      		ldd r25,Y+16
 8161 2aee 0497      		sbiw r24,4
 8162 2af0 988B      		std Y+16,r25
 8163 2af2 8F87      		std Y+15,r24
 8164               	.L567:
3207:ff.c          **** 				} while (--clst);
 8166               	.LM817:
 8167 2af4 91E0      		ldi r25,1
 8168 2af6 891A      		sub r8,r25
 8169 2af8 9108      		sbc r9,__zero_reg__
 8170 2afa A108      		sbc r10,__zero_reg__
 8171 2afc B108      		sbc r11,__zero_reg__
 8172 2afe 01F0      		breq .+2
 8173 2b00 00C0      		rjmp .L569
 8174 2b02 00C0      		rjmp .L561
 8175               	.L571:
3185:ff.c          **** 					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
 8177               	.LM818:
 8178 2b04 3324      		clr r3
 8179 2b06 3394      		inc r3
 8180 2b08 00C0      		rjmp .L561
 8181               	.L572:
3186:ff.c          **** 					if (stat == 1) { res = FR_INT_ERR; break; }
 8183               	.LM819:
 8184 2b0a 72E0      		ldi r23,lo8(2)
 8185 2b0c 372E      		mov r3,r23
 8186 2b0e 00C0      		rjmp .L561
 8187               	.L573:
3195:ff.c          **** 						res = move_window(fs, sect++);
 8189               	.LM820:
 8190 2b10 382E      		mov r3,r24
 8191               	.L561:
3209:ff.c          **** 			fs->free_clust = n;
 8193               	.LM821:
 8194 2b12 D801      		movw r26,r16
 8195 2b14 1E96      		adiw r26,14
 8196 2b16 CD92      		st X+,r12
 8197 2b18 DD92      		st X+,r13
 8198 2b1a ED92      		st X+,r14
 8199 2b1c FC92      		st X,r15
 8200 2b1e 5197      		sbiw r26,14+3
3210:ff.c          **** 			if (fat == FS_FAT32) fs->fsi_flag = 1;
 8202               	.LM822:
 8203 2b20 B3E0      		ldi r27,lo8(3)
 8204 2b22 2B12      		cpse r2,r27
 8205 2b24 00C0      		rjmp .L570
3210:ff.c          **** 			if (fat == FS_FAT32) fs->fsi_flag = 1;
 8207               	.LM823:
 8208 2b26 81E0      		ldi r24,lo8(1)
 8209 2b28 F801      		movw r30,r16
 8210 2b2a 8583      		std Z+5,r24
 8211               	.L570:
3211:ff.c          **** 			*nclst = n;
 8213               	.LM824:
 8214 2b2c AB81      		ldd r26,Y+3
 8215 2b2e BC81      		ldd r27,Y+4
 8216 2b30 CD92      		st X+,r12
 8217 2b32 DD92      		st X+,r13
 8218 2b34 ED92      		st X+,r14
 8219 2b36 FC92      		st X,r15
 8220 2b38 1397      		sbiw r26,3
 8221               	.L558:
3215:ff.c          **** }
 8223               	.LM825:
 8224 2b3a 832D      		mov r24,r3
 8225               	/* epilogue start */
 8226 2b3c 6096      		adiw r28,16
 8227 2b3e 0FB6      		in __tmp_reg__,__SREG__
 8228 2b40 F894      		cli
 8229 2b42 DEBF      		out __SP_H__,r29
 8230 2b44 0FBE      		out __SREG__,__tmp_reg__
 8231 2b46 CDBF      		out __SP_L__,r28
 8232 2b48 DF91      		pop r29
 8233 2b4a CF91      		pop r28
 8234 2b4c 1F91      		pop r17
 8235 2b4e 0F91      		pop r16
 8236 2b50 FF90      		pop r15
 8237 2b52 EF90      		pop r14
 8238 2b54 DF90      		pop r13
 8239 2b56 CF90      		pop r12
 8240 2b58 BF90      		pop r11
 8241 2b5a AF90      		pop r10
 8242 2b5c 9F90      		pop r9
 8243 2b5e 8F90      		pop r8
 8244 2b60 7F90      		pop r7
 8245 2b62 6F90      		pop r6
 8246 2b64 5F90      		pop r5
 8247 2b66 4F90      		pop r4
 8248 2b68 3F90      		pop r3
 8249 2b6a 2F90      		pop r2
 8250 2b6c 0895      		ret
 8260               	.Lscope31:
 8262               		.stabd	78,0,0
 8265               	.global	f_truncate
 8267               	f_truncate:
 8268               		.stabd	46,0,0
3227:ff.c          **** {
 8270               	.LM826:
 8271               	.LFBB32:
 8272 2b6e CF92      		push r12
 8273 2b70 DF92      		push r13
 8274 2b72 EF92      		push r14
 8275 2b74 FF92      		push r15
 8276 2b76 0F93      		push r16
 8277 2b78 1F93      		push r17
 8278 2b7a CF93      		push r28
 8279 2b7c DF93      		push r29
 8280               	/* prologue: function */
 8281               	/* frame size = 0 */
 8282               	/* stack size = 8 */
 8283               	.L__stack_usage = 8
 8284 2b7e EC01      		movw r28,r24
3232:ff.c          **** 	res = validate(fp);						/* Check validity of the object */
 8286               	.LM827:
 8287 2b80 0E94 0000 		call validate
 8288 2b84 182F      		mov r17,r24
3233:ff.c          **** 	if (res == FR_OK) {
 8290               	.LM828:
 8291 2b86 8111      		cpse r24,__zero_reg__
 8292 2b88 00C0      		rjmp .L593
3234:ff.c          **** 		if (fp->flag & FA__ERROR) {			/* Check abort flag */
 8294               	.LM829:
 8295 2b8a 2C81      		ldd r18,Y+4
 8296 2b8c 27FD      		sbrc r18,7
 8297 2b8e 00C0      		rjmp .L588
3237:ff.c          **** 			if (!(fp->flag & FA_WRITE))		/* Check access mode */
 8299               	.LM830:
 8300 2b90 21FF      		sbrs r18,1
 8301 2b92 00C0      		rjmp .L589
 8302 2b94 00C0      		rjmp .L596
 8303               	.L584:
3243:ff.c          **** 			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
 8305               	.LM831:
 8306 2b96 4A87      		std Y+10,r20
 8307 2b98 5B87      		std Y+11,r21
 8308 2b9a 6C87      		std Y+12,r22
 8309 2b9c 7D87      		std Y+13,r23
3244:ff.c          **** 			fp->flag |= FA__WRITTEN;
 8311               	.LM832:
 8312 2b9e 2062      		ori r18,lo8(32)
 8313 2ba0 2C83      		std Y+4,r18
 8314 2ba2 8881      		ld r24,Y
 8315 2ba4 9981      		ldd r25,Y+1
3245:ff.c          **** 			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
 8317               	.LM833:
 8318 2ba6 452B      		or r20,r21
 8319 2ba8 462B      		or r20,r22
 8320 2baa 472B      		or r20,r23
 8321 2bac 01F4      		brne .L579
3246:ff.c          **** 				res = remove_chain(fp->fs, fp->sclust);
 8323               	.LM834:
 8324 2bae 4E85      		ldd r20,Y+14
 8325 2bb0 5F85      		ldd r21,Y+15
 8326 2bb2 6889      		ldd r22,Y+16
 8327 2bb4 7989      		ldd r23,Y+17
 8328 2bb6 0E94 0000 		call remove_chain
 8329 2bba 182F      		mov r17,r24
3247:ff.c          **** 				fp->sclust = 0;
 8331               	.LM835:
 8332 2bbc 1E86      		std Y+14,__zero_reg__
 8333 2bbe 1F86      		std Y+15,__zero_reg__
 8334 2bc0 188A      		std Y+16,__zero_reg__
 8335 2bc2 198A      		std Y+17,__zero_reg__
 8336 2bc4 00C0      		rjmp .L580
 8337               	.L579:
3249:ff.c          **** 				ncl = get_fat(fp->fs, fp->clust);
 8339               	.LM836:
 8340 2bc6 4A89      		ldd r20,Y+18
 8341 2bc8 5B89      		ldd r21,Y+19
 8342 2bca 6C89      		ldd r22,Y+20
 8343 2bcc 7D89      		ldd r23,Y+21
 8344 2bce 0E94 0000 		call get_fat
 8345 2bd2 6B01      		movw r12,r22
 8346 2bd4 7C01      		movw r14,r24
3251:ff.c          **** 				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
 8348               	.LM837:
 8349 2bd6 8FEF      		ldi r24,-1
 8350 2bd8 C816      		cp r12,r24
 8351 2bda D806      		cpc r13,r24
 8352 2bdc E806      		cpc r14,r24
 8353 2bde F806      		cpc r15,r24
 8354 2be0 01F0      		breq .L590
3252:ff.c          **** 				if (ncl == 1) res = FR_INT_ERR;
 8356               	.LM838:
 8357 2be2 E1E0      		ldi r30,1
 8358 2be4 CE16      		cp r12,r30
 8359 2be6 D104      		cpc r13,__zero_reg__
 8360 2be8 E104      		cpc r14,__zero_reg__
 8361 2bea F104      		cpc r15,__zero_reg__
 8362 2bec 01F4      		brne .L597
 8363 2bee 00C0      		rjmp .L591
 8364               	.L587:
3254:ff.c          **** 					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
 8366               	.LM839:
 8367 2bf0 4A89      		ldd r20,Y+18
 8368 2bf2 5B89      		ldd r21,Y+19
 8369 2bf4 6C89      		ldd r22,Y+20
 8370 2bf6 7D89      		ldd r23,Y+21
 8371 2bf8 0FEF      		ldi r16,lo8(-1)
 8372 2bfa 1FEF      		ldi r17,lo8(-1)
 8373 2bfc 2FEF      		ldi r18,lo8(-1)
 8374 2bfe 3FE0      		ldi r19,lo8(15)
 8375 2c00 0E94 0000 		call put_fat
 8376 2c04 182F      		mov r17,r24
3255:ff.c          **** 					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
 8378               	.LM840:
 8379 2c06 8111      		cpse r24,__zero_reg__
 8380 2c08 00C0      		rjmp .L586
3255:ff.c          **** 					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
 8382               	.LM841:
 8383 2c0a B701      		movw r22,r14
 8384 2c0c A601      		movw r20,r12
 8385 2c0e 8881      		ld r24,Y
 8386 2c10 9981      		ldd r25,Y+1
 8387 2c12 0E94 0000 		call remove_chain
 8388 2c16 182F      		mov r17,r24
 8389               	.L580:
3259:ff.c          **** 		if (res != FR_OK) fp->flag |= FA__ERROR;
 8391               	.LM842:
 8392 2c18 1123      		tst r17
 8393 2c1a 01F0      		breq .L593
 8394               	.L586:
3259:ff.c          **** 		if (res != FR_OK) fp->flag |= FA__ERROR;
 8396               	.LM843:
 8397 2c1c 8C81      		ldd r24,Y+4
 8398 2c1e 8068      		ori r24,lo8(-128)
 8399 2c20 8C83      		std Y+4,r24
 8400 2c22 00C0      		rjmp .L593
 8401               	.L596:
3242:ff.c          **** 		if (fp->fsize > fp->fptr) {
 8403               	.LM844:
 8404 2c24 4E81      		ldd r20,Y+6
 8405 2c26 5F81      		ldd r21,Y+7
 8406 2c28 6885      		ldd r22,Y+8
 8407 2c2a 7985      		ldd r23,Y+9
 8408 2c2c 8A85      		ldd r24,Y+10
 8409 2c2e 9B85      		ldd r25,Y+11
 8410 2c30 AC85      		ldd r26,Y+12
 8411 2c32 BD85      		ldd r27,Y+13
 8412 2c34 4817      		cp r20,r24
 8413 2c36 5907      		cpc r21,r25
 8414 2c38 6A07      		cpc r22,r26
 8415 2c3a 7B07      		cpc r23,r27
 8416 2c3c 00F4      		brsh .+2
 8417 2c3e 00C0      		rjmp .L584
 8418 2c40 00C0      		rjmp .L593
 8419               	.L588:
3235:ff.c          **** 			res = FR_INT_ERR;
 8421               	.LM845:
 8422 2c42 12E0      		ldi r17,lo8(2)
 8423 2c44 00C0      		rjmp .L593
 8424               	.L589:
3238:ff.c          **** 				res = FR_DENIED;
 8426               	.LM846:
 8427 2c46 17E0      		ldi r17,lo8(7)
 8428 2c48 00C0      		rjmp .L593
 8429               	.L590:
3251:ff.c          **** 				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
 8431               	.LM847:
 8432 2c4a 11E0      		ldi r17,lo8(1)
 8433 2c4c 00C0      		rjmp .L586
 8434               	.L591:
3252:ff.c          **** 				if (ncl == 1) res = FR_INT_ERR;
 8436               	.LM848:
 8437 2c4e 12E0      		ldi r17,lo8(2)
 8438 2c50 00C0      		rjmp .L586
 8439               	.L597:
3253:ff.c          **** 				if (res == FR_OK && ncl < fp->fs->n_fatent) {
 8441               	.LM849:
 8442 2c52 8881      		ld r24,Y
 8443 2c54 9981      		ldd r25,Y+1
 8444 2c56 FC01      		movw r30,r24
 8445 2c58 4689      		ldd r20,Z+22
 8446 2c5a 5789      		ldd r21,Z+23
 8447 2c5c 608D      		ldd r22,Z+24
 8448 2c5e 718D      		ldd r23,Z+25
 8449 2c60 C416      		cp r12,r20
 8450 2c62 D506      		cpc r13,r21
 8451 2c64 E606      		cpc r14,r22
 8452 2c66 F706      		cpc r15,r23
 8453 2c68 00F0      		brlo .L587
 8454               	.L593:
3263:ff.c          **** }
 8456               	.LM850:
 8457 2c6a 812F      		mov r24,r17
 8458               	/* epilogue start */
 8459 2c6c DF91      		pop r29
 8460 2c6e CF91      		pop r28
 8461 2c70 1F91      		pop r17
 8462 2c72 0F91      		pop r16
 8463 2c74 FF90      		pop r15
 8464 2c76 EF90      		pop r14
 8465 2c78 DF90      		pop r13
 8466 2c7a CF90      		pop r12
 8467 2c7c 0895      		ret
 8473               	.Lscope32:
 8475               		.stabd	78,0,0
 8478               	.global	f_unlink
 8480               	f_unlink:
 8481               		.stabd	46,0,0
3275:ff.c          **** {
 8483               	.LM851:
 8484               	.LFBB33:
 8485 2c7e CF92      		push r12
 8486 2c80 DF92      		push r13
 8487 2c82 EF92      		push r14
 8488 2c84 FF92      		push r15
 8489 2c86 0F93      		push r16
 8490 2c88 1F93      		push r17
 8491 2c8a CF93      		push r28
 8492 2c8c DF93      		push r29
 8493 2c8e CDB7      		in r28,__SP_L__
 8494 2c90 DEB7      		in r29,__SP_H__
 8495 2c92 EB97      		sbiw r28,59
 8496 2c94 0FB6      		in __tmp_reg__,__SREG__
 8497 2c96 F894      		cli
 8498 2c98 DEBF      		out __SP_H__,r29
 8499 2c9a 0FBE      		out __SREG__,__tmp_reg__
 8500 2c9c CDBF      		out __SP_L__,r28
 8501               	/* prologue: function */
 8502               	/* frame size = 59 */
 8503               	/* stack size = 67 */
 8504               	.L__stack_usage = 67
 8505 2c9e 9AAF      		std Y+58,r25
 8506 2ca0 89AF      		std Y+57,r24
3283:ff.c          **** 	res = chk_mounted(&path, &dj.fs, 1);
 8508               	.LM852:
 8509 2ca2 41E0      		ldi r20,lo8(1)
 8510 2ca4 BE01      		movw r22,r28
 8511 2ca6 695E      		subi r22,-23
 8512 2ca8 7F4F      		sbci r23,-1
 8513 2caa CE01      		movw r24,r28
 8514 2cac C996      		adiw r24,57
 8515 2cae 0E94 0000 		call chk_mounted
 8516 2cb2 282F      		mov r18,r24
3284:ff.c          **** 	if (res == FR_OK) {
 8518               	.LM853:
 8519 2cb4 8111      		cpse r24,__zero_reg__
 8520 2cb6 00C0      		rjmp .L613
3285:ff.c          **** 		INIT_BUF(dj);
 8522               	.LM854:
 8523 2cb8 CE01      		movw r24,r28
 8524 2cba 8D96      		adiw r24,45
 8525 2cbc 9CA7      		std Y+44,r25
 8526 2cbe 8BA7      		std Y+43,r24
3286:ff.c          **** 		res = follow_path(&dj, path);		/* Follow the file path */
 8528               	.LM855:
 8529 2cc0 69AD      		ldd r22,Y+57
 8530 2cc2 7AAD      		ldd r23,Y+58
 8531 2cc4 CE01      		movw r24,r28
 8532 2cc6 4796      		adiw r24,23
 8533 2cc8 0E94 0000 		call follow_path
 8534 2ccc 282F      		mov r18,r24
3292:ff.c          **** 		if (res == FR_OK) {					/* The object is accessible */
 8536               	.LM856:
 8537 2cce 8111      		cpse r24,__zero_reg__
 8538 2cd0 00C0      		rjmp .L613
3293:ff.c          **** 			dir = dj.dir;
 8540               	.LM857:
 8541 2cd2 09A5      		ldd r16,Y+41
 8542 2cd4 1AA5      		ldd r17,Y+42
3294:ff.c          **** 			if (!dir) {
 8544               	.LM858:
 8545 2cd6 0115      		cp r16,__zero_reg__
 8546 2cd8 1105      		cpc r17,__zero_reg__
 8547 2cda 01F0      		breq .L606
3297:ff.c          **** 				if (dir[DIR_Attr] & AM_RDO)
 8549               	.LM859:
 8550 2cdc F801      		movw r30,r16
 8551 2cde 8385      		ldd r24,Z+11
 8552 2ce0 80FD      		sbrc r24,0
 8553 2ce2 00C0      		rjmp .L607
 8554 2ce4 00C0      		rjmp .L600
 8555               	.L606:
3295:ff.c          **** 				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
 8557               	.LM860:
 8558 2ce6 26E0      		ldi r18,lo8(6)
 8559 2ce8 00C0      		rjmp .L600
 8560               	.L607:
3298:ff.c          **** 					res = FR_DENIED;		/* Cannot remove R/O object */
 8562               	.LM861:
 8563 2cea 27E0      		ldi r18,lo8(7)
 8564               	.L600:
 8566               	.LM862:
 8567 2cec EF89      		ldd r30,Y+23
 8568 2cee F88D      		ldd r31,Y+24
3300:ff.c          **** 			dclst = ld_clust(dj.fs, dir);
 8570               	.LM863:
 8571 2cf0 B801      		movw r22,r16
 8572 2cf2 8081      		ld r24,Z
 8573 2cf4 2BAF      		std Y+59,r18
 8574 2cf6 0E94 0000 		call ld_clust.isra.0
 8575 2cfa 6B01      		movw r12,r22
 8576 2cfc 7C01      		movw r14,r24
3301:ff.c          **** 			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
 8578               	.LM864:
 8579 2cfe 2BAD      		ldd r18,Y+59
 8580 2d00 2111      		cpse r18,__zero_reg__
 8581 2d02 00C0      		rjmp .L613
3301:ff.c          **** 			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
 8583               	.LM865:
 8584 2d04 F801      		movw r30,r16
 8585 2d06 8385      		ldd r24,Z+11
 8586 2d08 84FF      		sbrs r24,4
 8587 2d0a 00C0      		rjmp .L602
3302:ff.c          **** 				if (dclst < 2) {
 8589               	.LM866:
 8590 2d0c F2E0      		ldi r31,2
 8591 2d0e CF16      		cp r12,r31
 8592 2d10 D104      		cpc r13,__zero_reg__
 8593 2d12 E104      		cpc r14,__zero_reg__
 8594 2d14 F104      		cpc r15,__zero_reg__
 8595 2d16 00F0      		brlo .L608
3305:ff.c          **** 					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
 8597               	.LM867:
 8598 2d18 46E1      		ldi r20,lo8(22)
 8599 2d1a 50E0      		ldi r21,0
 8600 2d1c BE01      		movw r22,r28
 8601 2d1e 695E      		subi r22,-23
 8602 2d20 7F4F      		sbci r23,-1
 8603 2d22 CE01      		movw r24,r28
 8604 2d24 0196      		adiw r24,1
 8605 2d26 0E94 0000 		call mem_cpy
3306:ff.c          **** 					sdj.sclust = dclst;
 8607               	.LM868:
 8608 2d2a CF82      		std Y+7,r12
 8609 2d2c D886      		std Y+8,r13
 8610 2d2e E986      		std Y+9,r14
 8611 2d30 FA86      		std Y+10,r15
3307:ff.c          **** 					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
 8613               	.LM869:
 8614 2d32 62E0      		ldi r22,lo8(2)
 8615 2d34 70E0      		ldi r23,0
 8616 2d36 CE01      		movw r24,r28
 8617 2d38 0196      		adiw r24,1
 8618 2d3a 0E94 0000 		call dir_sdi
 8619 2d3e 282F      		mov r18,r24
3308:ff.c          **** 					if (res == FR_OK) {
 8621               	.LM870:
 8622 2d40 8111      		cpse r24,__zero_reg__
 8623 2d42 00C0      		rjmp .L613
3309:ff.c          **** 						res = dir_read(&sdj, 0);	/* Read an item */
 8625               	.LM871:
 8626 2d44 CE01      		movw r24,r28
 8627 2d46 0196      		adiw r24,1
 8628 2d48 0E94 0000 		call dir_read.constprop.10
 8629 2d4c 282F      		mov r18,r24
3310:ff.c          **** 						if (res == FR_OK		/* Not empty dir */
 8631               	.LM872:
 8632 2d4e 8823      		tst r24
 8633 2d50 01F0      		breq .L609
3315:ff.c          **** 						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
 8635               	.LM873:
 8636 2d52 8430      		cpi r24,lo8(4)
 8637 2d54 01F0      		breq .L602
 8638 2d56 00C0      		rjmp .L613
 8639               	.L605:
3322:ff.c          **** 					if (dclst)				/* Remove the cluster chain if exist */
 8641               	.LM874:
 8642 2d58 C114      		cp r12,__zero_reg__
 8643 2d5a D104      		cpc r13,__zero_reg__
 8644 2d5c E104      		cpc r14,__zero_reg__
 8645 2d5e F104      		cpc r15,__zero_reg__
 8646 2d60 01F4      		brne .L603
 8647               	.L604:
3324:ff.c          **** 					if (res == FR_OK) res = sync_fs(dj.fs);
 8649               	.LM875:
 8650 2d62 8F89      		ldd r24,Y+23
 8651 2d64 988D      		ldd r25,Y+24
 8652 2d66 0E94 0000 		call sync_fs
 8653 2d6a 282F      		mov r18,r24
 8654 2d6c 00C0      		rjmp .L613
 8655               	.L603:
3323:ff.c          **** 						res = remove_chain(dj.fs, dclst);
 8657               	.LM876:
 8658 2d6e B701      		movw r22,r14
 8659 2d70 A601      		movw r20,r12
 8660 2d72 8F89      		ldd r24,Y+23
 8661 2d74 988D      		ldd r25,Y+24
 8662 2d76 0E94 0000 		call remove_chain
 8663 2d7a 282F      		mov r18,r24
3324:ff.c          **** 					if (res == FR_OK) res = sync_fs(dj.fs);
 8665               	.LM877:
 8666 2d7c 8111      		cpse r24,__zero_reg__
 8667 2d7e 00C0      		rjmp .L613
 8668 2d80 00C0      		rjmp .L604
 8669               	.L608:
3303:ff.c          **** 					res = FR_INT_ERR;
 8671               	.LM878:
 8672 2d82 22E0      		ldi r18,lo8(2)
 8673 2d84 00C0      		rjmp .L613
 8674               	.L609:
3314:ff.c          **** 						) res = FR_DENIED;
 8676               	.LM879:
 8677 2d86 27E0      		ldi r18,lo8(7)
 8678 2d88 00C0      		rjmp .L613
 8679               	.L602:
3320:ff.c          **** 				res = dir_remove(&dj);		/* Remove the directory entry */
 8681               	.LM880:
 8682 2d8a CE01      		movw r24,r28
 8683 2d8c 4796      		adiw r24,23
 8684 2d8e 0E94 0000 		call dir_remove
 8685 2d92 282F      		mov r18,r24
3321:ff.c          **** 				if (res == FR_OK) {
 8687               	.LM881:
 8688 2d94 8823      		tst r24
 8689 2d96 01F0      		breq .L605
 8690               	.L613:
3332:ff.c          **** }
 8692               	.LM882:
 8693 2d98 822F      		mov r24,r18
 8694               	/* epilogue start */
 8695 2d9a EB96      		adiw r28,59
 8696 2d9c 0FB6      		in __tmp_reg__,__SREG__
 8697 2d9e F894      		cli
 8698 2da0 DEBF      		out __SP_H__,r29
 8699 2da2 0FBE      		out __SREG__,__tmp_reg__
 8700 2da4 CDBF      		out __SP_L__,r28
 8701 2da6 DF91      		pop r29
 8702 2da8 CF91      		pop r28
 8703 2daa 1F91      		pop r17
 8704 2dac 0F91      		pop r16
 8705 2dae FF90      		pop r15
 8706 2db0 EF90      		pop r14
 8707 2db2 DF90      		pop r13
 8708 2db4 CF90      		pop r12
 8709 2db6 0895      		ret
 8719               	.Lscope33:
 8721               		.stabd	78,0,0
 8724               	.global	f_mkdir
 8726               	f_mkdir:
 8727               		.stabd	46,0,0
3344:ff.c          **** {
 8729               	.LM883:
 8730               	.LFBB34:
 8731 2db8 2F92      		push r2
 8732 2dba 3F92      		push r3
 8733 2dbc 4F92      		push r4
 8734 2dbe 5F92      		push r5
 8735 2dc0 6F92      		push r6
 8736 2dc2 7F92      		push r7
 8737 2dc4 8F92      		push r8
 8738 2dc6 9F92      		push r9
 8739 2dc8 AF92      		push r10
 8740 2dca BF92      		push r11
 8741 2dcc CF92      		push r12
 8742 2dce DF92      		push r13
 8743 2dd0 EF92      		push r14
 8744 2dd2 FF92      		push r15
 8745 2dd4 0F93      		push r16
 8746 2dd6 1F93      		push r17
 8747 2dd8 CF93      		push r28
 8748 2dda DF93      		push r29
 8749 2ddc CDB7      		in r28,__SP_L__
 8750 2dde DEB7      		in r29,__SP_H__
 8751 2de0 AB97      		sbiw r28,43
 8752 2de2 0FB6      		in __tmp_reg__,__SREG__
 8753 2de4 F894      		cli
 8754 2de6 DEBF      		out __SP_H__,r29
 8755 2de8 0FBE      		out __SREG__,__tmp_reg__
 8756 2dea CDBF      		out __SP_L__,r28
 8757               	/* prologue: function */
 8758               	/* frame size = 43 */
 8759               	/* stack size = 61 */
 8760               	.L__stack_usage = 61
 8761 2dec 9CA3      		std Y+36,r25
 8762 2dee 8BA3      		std Y+35,r24
3348:ff.c          **** 	DWORD dsc, dcl, pcl, tm = get_fattime();
 8764               	.LM884:
 8765 2df0 0E94 0000 		call get_fattime
 8766 2df4 2B01      		movw r4,r22
 8767 2df6 3C01      		movw r6,r24
3352:ff.c          **** 	res = chk_mounted(&path, &dj.fs, 1);
 8769               	.LM885:
 8770 2df8 41E0      		ldi r20,lo8(1)
 8771 2dfa BE01      		movw r22,r28
 8772 2dfc 6F5F      		subi r22,-1
 8773 2dfe 7F4F      		sbci r23,-1
 8774 2e00 CE01      		movw r24,r28
 8775 2e02 8396      		adiw r24,35
 8776 2e04 0E94 0000 		call chk_mounted
 8777 2e08 182F      		mov r17,r24
3353:ff.c          **** 	if (res == FR_OK) {
 8779               	.LM886:
 8780 2e0a 8111      		cpse r24,__zero_reg__
 8781 2e0c 00C0      		rjmp .L642
3354:ff.c          **** 		INIT_BUF(dj);
 8783               	.LM887:
 8784 2e0e CE01      		movw r24,r28
 8785 2e10 4796      		adiw r24,23
 8786 2e12 9E8B      		std Y+22,r25
 8787 2e14 8D8B      		std Y+21,r24
3355:ff.c          **** 		res = follow_path(&dj, path);			/* Follow the file path */
 8789               	.LM888:
 8790 2e16 6BA1      		ldd r22,Y+35
 8791 2e18 7CA1      		ldd r23,Y+36
 8792 2e1a CE01      		movw r24,r28
 8793 2e1c 0196      		adiw r24,1
 8794 2e1e 0E94 0000 		call follow_path
 8795 2e22 182F      		mov r17,r24
3356:ff.c          **** 		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 8797               	.LM889:
 8798 2e24 8823      		tst r24
 8799 2e26 01F4      		brne .+2
 8800 2e28 00C0      		rjmp .L637
3359:ff.c          **** 		if (res == FR_NO_FILE) {				/* Can create a new directory */
 8802               	.LM890:
 8803 2e2a 8430      		cpi r24,lo8(4)
 8804 2e2c 01F0      		breq .+2
 8805 2e2e 00C0      		rjmp .L642
3360:ff.c          **** 			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
 8807               	.LM891:
 8808 2e30 40E0      		ldi r20,0
 8809 2e32 50E0      		ldi r21,0
 8810 2e34 BA01      		movw r22,r20
 8811 2e36 8981      		ldd r24,Y+1
 8812 2e38 9A81      		ldd r25,Y+2
 8813 2e3a 0E94 0000 		call create_chain
 8814 2e3e 6B01      		movw r12,r22
 8815 2e40 7C01      		movw r14,r24
3362:ff.c          **** 			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 8817               	.LM892:
 8818 2e42 6115      		cp r22,__zero_reg__
 8819 2e44 7105      		cpc r23,__zero_reg__
 8820 2e46 8105      		cpc r24,__zero_reg__
 8821 2e48 9105      		cpc r25,__zero_reg__
 8822 2e4a 01F4      		brne .+2
 8823 2e4c 00C0      		rjmp .L638
3363:ff.c          **** 			if (dcl == 1) res = FR_INT_ERR;
 8825               	.LM893:
 8826 2e4e 6130      		cpi r22,1
 8827 2e50 7105      		cpc r23,__zero_reg__
 8828 2e52 8105      		cpc r24,__zero_reg__
 8829 2e54 9105      		cpc r25,__zero_reg__
 8830 2e56 01F4      		brne .+2
 8831 2e58 00C0      		rjmp .L639
3364:ff.c          **** 			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
 8833               	.LM894:
 8834 2e5a 8FEF      		ldi r24,-1
 8835 2e5c C816      		cp r12,r24
 8836 2e5e D806      		cpc r13,r24
 8837 2e60 E806      		cpc r14,r24
 8838 2e62 F806      		cpc r15,r24
 8839 2e64 01F4      		brne .+2
 8840 2e66 00C0      		rjmp .L640
 8841 2e68 00C0      		rjmp .L643
 8842               	.L636:
3368:ff.c          **** 				dsc = clust2sect(dj.fs, dcl);
 8844               	.LM895:
 8845 2e6a 0981      		ldd r16,Y+1
 8846 2e6c 1A81      		ldd r17,Y+2
 8847 2e6e B701      		movw r22,r14
 8848 2e70 A601      		movw r20,r12
 8849 2e72 C801      		movw r24,r16
 8850 2e74 0E94 0000 		call clust2sect
 8851 2e78 4B01      		movw r8,r22
 8852 2e7a 5C01      		movw r10,r24
3369:ff.c          **** 				dir = dj.fs->win;
 8854               	.LM896:
 8855 2e7c 1801      		movw r2,r16
 8856 2e7e 92E3      		ldi r25,50
 8857 2e80 290E      		add r2,r25
 8858 2e82 311C      		adc r3,__zero_reg__
3341:ff.c          **** FRESULT f_mkdir (
 8860               	.LM897:
 8861 2e84 F801      		movw r30,r16
 8862 2e86 EE5C      		subi r30,-50
 8863 2e88 FD4F      		sbci r31,-3
 8864 2e8a FEA3      		std Y+38,r31
 8865 2e8c EDA3      		std Y+37,r30
 557:ff.c          **** 	BYTE *d = (BYTE*)dst;
 8867               	.LM898:
 8868 2e8e F101      		movw r30,r2
 8869 2e90 00C0      		rjmp .L624
 8870               	.L625:
 8871               	.LBB114:
 8872               	.LBB115:
 560:ff.c          **** 		*d++ = (BYTE)val;
 8874               	.LM899:
 8875 2e92 1192      		st Z+,__zero_reg__
 8876               	.L624:
 559:ff.c          **** 	while (cnt--)
 8878               	.LM900:
 8879 2e94 8DA1      		ldd r24,Y+37
 8880 2e96 9EA1      		ldd r25,Y+38
 8881 2e98 E817      		cp r30,r24
 8882 2e9a F907      		cpc r31,r25
 8883 2e9c 01F4      		brne .L625
3341:ff.c          **** FRESULT f_mkdir (
 8885               	.LM901:
 8886 2e9e C801      		movw r24,r16
 8887 2ea0 CD96      		adiw r24,61
 8888               	.LBE115:
 8889               	.LBE114:
 8890 2ea2 F101      		movw r30,r2
 8891               	.LBB116:
 8892               	.LBB117:
 560:ff.c          **** 		*d++ = (BYTE)val;
 8894               	.LM902:
 8895 2ea4 20E2      		ldi r18,lo8(32)
 8896 2ea6 00C0      		rjmp .L626
 8897               	.L627:
 8898 2ea8 2193      		st Z+,r18
 8899               	.L626:
 559:ff.c          **** 	while (cnt--)
 8901               	.LM903:
 8902 2eaa E817      		cp r30,r24
 8903 2eac F907      		cpc r31,r25
 8904 2eae 01F4      		brne .L627
 8905               	.LBE117:
 8906               	.LBE116:
3372:ff.c          **** 				dir[DIR_Name] = '.';
 8908               	.LM904:
 8909 2eb0 2EE2      		ldi r18,lo8(46)
 8910 2eb2 F801      		movw r30,r16
 8911 2eb4 22AB      		std Z+50,r18
3373:ff.c          **** 				dir[DIR_Attr] = AM_DIR;
 8913               	.LM905:
 8914 2eb6 80E1      		ldi r24,lo8(16)
 8915 2eb8 85AF      		std Z+61,r24
3374:ff.c          **** 				ST_DWORD(dir+DIR_WrtTime, tm);
 8917               	.LM906:
 8918 2eba 4FA2      		std Y+39,r4
 8919 2ebc E85B      		subi r30,-72
 8920 2ebe FF4F      		sbci r31,-1
 8921 2ec0 4082      		st Z,r4
 8922 2ec2 852D      		mov r24,r5
 8923 2ec4 9927      		clr r25
 8924 2ec6 88A7      		std Y+40,r24
 8925 2ec8 F801      		movw r30,r16
 8926 2eca E75B      		subi r30,-73
 8927 2ecc FF4F      		sbci r31,-1
 8928 2ece 8083      		st Z,r24
 8929 2ed0 C301      		movw r24,r6
 8930 2ed2 AA27      		clr r26
 8931 2ed4 BB27      		clr r27
 8932 2ed6 89A7      		std Y+41,r24
 8933 2ed8 F801      		movw r30,r16
 8934 2eda E65B      		subi r30,-74
 8935 2edc FF4F      		sbci r31,-1
 8936 2ede 8083      		st Z,r24
 8937 2ee0 872D      		mov r24,r7
 8938 2ee2 9927      		clr r25
 8939 2ee4 AA27      		clr r26
 8940 2ee6 BB27      		clr r27
 8941 2ee8 782E      		mov r7,r24
 8942 2eea F801      		movw r30,r16
 8943 2eec E55B      		subi r30,-75
 8944 2eee FF4F      		sbci r31,-1
 8945 2ef0 8083      		st Z,r24
 8946               	.LBB118:
 8947               	.LBB119:
1261:ff.c          **** 	ST_WORD(dir+DIR_FstClusLO, cl);
 8949               	.LM907:
 8950 2ef2 6C2C      		mov r6,r12
 8951 2ef4 F801      		movw r30,r16
 8952 2ef6 E45B      		subi r30,-76
 8953 2ef8 FF4F      		sbci r31,-1
 8954 2efa C082      		st Z,r12
 8955 2efc 8D2D      		mov r24,r13
 8956 2efe 9927      		clr r25
 8957 2f00 582E      		mov r5,r24
 8958 2f02 F801      		movw r30,r16
 8959 2f04 E35B      		subi r30,-77
 8960 2f06 FF4F      		sbci r31,-1
 8961 2f08 8083      		st Z,r24
1262:ff.c          **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8963               	.LM908:
 8964 2f0a C701      		movw r24,r14
 8965 2f0c AA27      		clr r26
 8966 2f0e BB27      		clr r27
 8967 2f10 482E      		mov r4,r24
 8968 2f12 F801      		movw r30,r16
 8969 2f14 EA5B      		subi r30,-70
 8970 2f16 FF4F      		sbci r31,-1
 8971 2f18 8083      		st Z,r24
 8972 2f1a 892F      		mov r24,r25
 8973 2f1c 9927      		clr r25
 8974 2f1e 8AA7      		std Y+42,r24
 8975 2f20 F801      		movw r30,r16
 8976 2f22 E95B      		subi r30,-71
 8977 2f24 FF4F      		sbci r31,-1
 8978 2f26 8083      		st Z,r24
 8979               	.LBE119:
 8980               	.LBE118:
3376:ff.c          **** 				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
 8982               	.LM909:
 8983 2f28 40E2      		ldi r20,lo8(32)
 8984 2f2a 50E0      		ldi r21,0
 8985 2f2c B101      		movw r22,r2
 8986 2f2e C801      		movw r24,r16
 8987 2f30 8E5A      		subi r24,-82
 8988 2f32 9F4F      		sbci r25,-1
 8989 2f34 2BA7      		std Y+43,r18
 8990 2f36 0E94 0000 		call mem_cpy
3377:ff.c          **** 				dir[33] = '.'; pcl = dj.sclust;
 8992               	.LM910:
 8993 2f3a F801      		movw r30,r16
 8994 2f3c ED5A      		subi r30,-83
 8995 2f3e FF4F      		sbci r31,-1
 8996 2f40 2BA5      		ldd r18,Y+43
 8997 2f42 2083      		st Z,r18
 8998 2f44 4F81      		ldd r20,Y+7
 8999 2f46 5885      		ldd r21,Y+8
 9000 2f48 6985      		ldd r22,Y+9
 9001 2f4a 7A85      		ldd r23,Y+10
3378:ff.c          **** 				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
 9003               	.LM911:
 9004 2f4c E981      		ldd r30,Y+1
 9005 2f4e FA81      		ldd r31,Y+2
 9006 2f50 8081      		ld r24,Z
 9007 2f52 8330      		cpi r24,lo8(3)
 9008 2f54 01F4      		brne .L628
3378:ff.c          **** 				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
 9010               	.LM912:
 9011 2f56 86A1      		ldd r24,Z+38
 9012 2f58 97A1      		ldd r25,Z+39
 9013 2f5a A0A5      		ldd r26,Z+40
 9014 2f5c B1A5      		ldd r27,Z+41
 9015 2f5e 4817      		cp r20,r24
 9016 2f60 5907      		cpc r21,r25
 9017 2f62 6A07      		cpc r22,r26
 9018 2f64 7B07      		cpc r23,r27
 9019 2f66 01F4      		brne .L628
3379:ff.c          **** 					pcl = 0;
 9021               	.LM913:
 9022 2f68 40E0      		ldi r20,0
 9023 2f6a 50E0      		ldi r21,0
 9024 2f6c BA01      		movw r22,r20
 9025               	.L628:
 9026               	.LBB120:
 9027               	.LBB121:
1261:ff.c          **** 	ST_WORD(dir+DIR_FstClusLO, cl);
 9029               	.LM914:
 9030 2f6e D801      		movw r26,r16
 9031 2f70 A459      		subi r26,-108
 9032 2f72 BF4F      		sbci r27,-1
 9033 2f74 4C93      		st X,r20
 9034 2f76 D801      		movw r26,r16
 9035 2f78 A359      		subi r26,-109
 9036 2f7a BF4F      		sbci r27,-1
 9037 2f7c 5C93      		st X,r21
1262:ff.c          **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 9039               	.LM915:
 9040 2f7e AB01      		movw r20,r22
 9041 2f80 6627      		clr r22
 9042 2f82 7727      		clr r23
 9043 2f84 D801      		movw r26,r16
 9044 2f86 AA59      		subi r26,-102
 9045 2f88 BF4F      		sbci r27,-1
 9046 2f8a 4C93      		st X,r20
 9047 2f8c D801      		movw r26,r16
 9048 2f8e A959      		subi r26,-103
 9049 2f90 BF4F      		sbci r27,-1
 9050 2f92 5C93      		st X,r21
 9051               	.LBE121:
 9052               	.LBE120:
3381:ff.c          **** 				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 9054               	.LM916:
 9055 2f94 0281      		ldd r16,Z+2
3383:ff.c          **** 					dj.fs->wflag = 1;
 9057               	.LM917:
 9058 2f96 21E0      		ldi r18,lo8(1)
3381:ff.c          **** 				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 9060               	.LM918:
 9061 2f98 00C0      		rjmp .L629
 9062               	.L633:
3382:ff.c          **** 					dj.fs->winsect = dsc++;
 9064               	.LM919:
 9065 2f9a 8981      		ldd r24,Y+1
 9066 2f9c 9A81      		ldd r25,Y+2
 9067 2f9e FC01      		movw r30,r24
 9068 2fa0 86A6      		std Z+46,r8
 9069 2fa2 97A6      		std Z+47,r9
 9070 2fa4 A0AA      		std Z+48,r10
 9071 2fa6 B1AA      		std Z+49,r11
 9072 2fa8 FFEF      		ldi r31,-1
 9073 2faa 8F1A      		sub r8,r31
 9074 2fac 9F0A      		sbc r9,r31
 9075 2fae AF0A      		sbc r10,r31
 9076 2fb0 BF0A      		sbc r11,r31
3383:ff.c          **** 					dj.fs->wflag = 1;
 9078               	.LM920:
 9079 2fb2 FC01      		movw r30,r24
 9080 2fb4 2483      		std Z+4,r18
3384:ff.c          **** 					res = sync_window(dj.fs);
 9082               	.LM921:
 9083 2fb6 2BA7      		std Y+43,r18
 9084 2fb8 0E94 0000 		call sync_window
 9085 2fbc 182F      		mov r17,r24
3385:ff.c          **** 					if (res != FR_OK) break;
 9087               	.LM922:
 9088 2fbe 2BA5      		ldd r18,Y+43
 9089 2fc0 8111      		cpse r24,__zero_reg__
 9090 2fc2 00C0      		rjmp .L635
 9091 2fc4 F101      		movw r30,r2
 9092 2fc6 00C0      		rjmp .L631
 9093               	.L632:
 9094               	.LBB122:
 9095               	.LBB123:
 560:ff.c          **** 		*d++ = (BYTE)val;
 9097               	.LM923:
 9098 2fc8 1192      		st Z+,__zero_reg__
 9099               	.L631:
 559:ff.c          **** 	while (cnt--)
 9101               	.LM924:
 9102 2fca 8DA1      		ldd r24,Y+37
 9103 2fcc 9EA1      		ldd r25,Y+38
 9104 2fce E817      		cp r30,r24
 9105 2fd0 F907      		cpc r31,r25
 9106 2fd2 01F4      		brne .L632
 9107               	.LBE123:
 9108               	.LBE122:
3381:ff.c          **** 				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 9110               	.LM925:
 9111 2fd4 0150      		subi r16,lo8(-(-1))
 9112               	.L629:
3381:ff.c          **** 				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 9114               	.LM926:
 9115 2fd6 0111      		cpse r16,__zero_reg__
 9116 2fd8 00C0      		rjmp .L633
3389:ff.c          **** 			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
 9118               	.LM927:
 9119 2fda CE01      		movw r24,r28
 9120 2fdc 0196      		adiw r24,1
 9121 2fde 0E94 0000 		call dir_register
 9122 2fe2 182F      		mov r17,r24
3390:ff.c          **** 			if (res != FR_OK) {
 9124               	.LM928:
 9125 2fe4 8823      		tst r24
 9126 2fe6 01F0      		breq .L634
 9127               	.L635:
3391:ff.c          **** 				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
 9129               	.LM929:
 9130 2fe8 B701      		movw r22,r14
 9131 2fea A601      		movw r20,r12
 9132 2fec 8981      		ldd r24,Y+1
 9133 2fee 9A81      		ldd r25,Y+2
 9134 2ff0 0E94 0000 		call remove_chain
 9135 2ff4 00C0      		rjmp .L642
 9136               	.L634:
3393:ff.c          **** 				dir = dj.dir;
 9138               	.LM930:
 9139 2ff6 EB89      		ldd r30,Y+19
 9140 2ff8 FC89      		ldd r31,Y+20
3394:ff.c          **** 				dir[DIR_Attr] = AM_DIR;				/* Attribute */
 9142               	.LM931:
 9143 2ffa 80E1      		ldi r24,lo8(16)
 9144 2ffc 8387      		std Z+11,r24
3395:ff.c          **** 				ST_DWORD(dir+DIR_WrtTime, tm);		/* Created time */
 9146               	.LM932:
 9147 2ffe 3FA1      		ldd r19,Y+39
 9148 3000 368B      		std Z+22,r19
 9149 3002 38A5      		ldd r19,Y+40
 9150 3004 378B      		std Z+23,r19
 9151 3006 39A5      		ldd r19,Y+41
 9152 3008 308F      		std Z+24,r19
 9153 300a 718E      		std Z+25,r7
 9154               	.LBB124:
 9155               	.LBB125:
1261:ff.c          **** 	ST_WORD(dir+DIR_FstClusLO, cl);
 9157               	.LM933:
 9158 300c 628E      		std Z+26,r6
 9159 300e 538E      		std Z+27,r5
1262:ff.c          **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 9161               	.LM934:
 9162 3010 448A      		std Z+20,r4
 9163 3012 3AA5      		ldd r19,Y+42
 9164 3014 358B      		std Z+21,r19
 9165               	.LBE125:
 9166               	.LBE124:
3397:ff.c          **** 				dj.fs->wflag = 1;
 9168               	.LM935:
 9169 3016 8981      		ldd r24,Y+1
 9170 3018 9A81      		ldd r25,Y+2
 9171 301a 21E0      		ldi r18,lo8(1)
 9172 301c FC01      		movw r30,r24
 9173 301e 2483      		std Z+4,r18
3398:ff.c          **** 				res = sync_fs(dj.fs);
 9175               	.LM936:
 9176 3020 0E94 0000 		call sync_fs
 9177 3024 182F      		mov r17,r24
 9178 3026 00C0      		rjmp .L642
 9179               	.L637:
3356:ff.c          **** 		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 9181               	.LM937:
 9182 3028 18E0      		ldi r17,lo8(8)
 9183 302a 00C0      		rjmp .L642
 9184               	.L638:
3362:ff.c          **** 			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 9186               	.LM938:
 9187 302c 17E0      		ldi r17,lo8(7)
 9188 302e 00C0      		rjmp .L635
 9189               	.L639:
3363:ff.c          **** 			if (dcl == 1) res = FR_INT_ERR;
 9191               	.LM939:
 9192 3030 12E0      		ldi r17,lo8(2)
 9193 3032 00C0      		rjmp .L635
 9194               	.L640:
3364:ff.c          **** 			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
 9196               	.LM940:
 9197 3034 11E0      		ldi r17,lo8(1)
 9198 3036 00C0      		rjmp .L635
 9199               	.L643:
3366:ff.c          **** 				res = sync_window(dj.fs);
 9201               	.LM941:
 9202 3038 8981      		ldd r24,Y+1
 9203 303a 9A81      		ldd r25,Y+2
 9204 303c 0E94 0000 		call sync_window
 9205 3040 182F      		mov r17,r24
3367:ff.c          **** 			if (res == FR_OK) {					/* Initialize the new directory table */
 9207               	.LM942:
 9208 3042 8823      		tst r24
 9209 3044 01F4      		brne .+2
 9210 3046 00C0      		rjmp .L636
 9211 3048 00C0      		rjmp .L635
 9212               	.L642:
3405:ff.c          **** }
 9214               	.LM943:
 9215 304a 812F      		mov r24,r17
 9216               	/* epilogue start */
 9217 304c AB96      		adiw r28,43
 9218 304e 0FB6      		in __tmp_reg__,__SREG__
 9219 3050 F894      		cli
 9220 3052 DEBF      		out __SP_H__,r29
 9221 3054 0FBE      		out __SREG__,__tmp_reg__
 9222 3056 CDBF      		out __SP_L__,r28
 9223 3058 DF91      		pop r29
 9224 305a CF91      		pop r28
 9225 305c 1F91      		pop r17
 9226 305e 0F91      		pop r16
 9227 3060 FF90      		pop r15
 9228 3062 EF90      		pop r14
 9229 3064 DF90      		pop r13
 9230 3066 CF90      		pop r12
 9231 3068 BF90      		pop r11
 9232 306a AF90      		pop r10
 9233 306c 9F90      		pop r9
 9234 306e 8F90      		pop r8
 9235 3070 7F90      		pop r7
 9236 3072 6F90      		pop r6
 9237 3074 5F90      		pop r5
 9238 3076 4F90      		pop r4
 9239 3078 3F90      		pop r3
 9240 307a 2F90      		pop r2
 9241 307c 0895      		ret
 9253               	.Lscope34:
 9255               		.stabd	78,0,0
 9260               	.global	f_chmod
 9262               	f_chmod:
 9263               		.stabd	46,0,0
3419:ff.c          **** {
 9265               	.LM944:
 9266               	.LFBB35:
 9267 307e 0F93      		push r16
 9268 3080 1F93      		push r17
 9269 3082 CF93      		push r28
 9270 3084 DF93      		push r29
 9271 3086 CDB7      		in r28,__SP_L__
 9272 3088 DEB7      		in r29,__SP_H__
 9273 308a A497      		sbiw r28,36
 9274 308c 0FB6      		in __tmp_reg__,__SREG__
 9275 308e F894      		cli
 9276 3090 DEBF      		out __SP_H__,r29
 9277 3092 0FBE      		out __SREG__,__tmp_reg__
 9278 3094 CDBF      		out __SP_L__,r28
 9279               	/* prologue: function */
 9280               	/* frame size = 36 */
 9281               	/* stack size = 40 */
 9282               	.L__stack_usage = 40
 9283 3096 9CA3      		std Y+36,r25
 9284 3098 8BA3      		std Y+35,r24
 9285 309a 162F      		mov r17,r22
 9286 309c 042F      		mov r16,r20
3426:ff.c          **** 	res = chk_mounted(&path, &dj.fs, 1);
 9288               	.LM945:
 9289 309e 41E0      		ldi r20,lo8(1)
 9290 30a0 BE01      		movw r22,r28
 9291 30a2 6F5F      		subi r22,-1
 9292 30a4 7F4F      		sbci r23,-1
 9293 30a6 CE01      		movw r24,r28
 9294 30a8 8396      		adiw r24,35
 9295 30aa 0E94 0000 		call chk_mounted
3427:ff.c          **** 	if (res == FR_OK) {
 9297               	.LM946:
 9298 30ae 8111      		cpse r24,__zero_reg__
 9299 30b0 00C0      		rjmp .L645
3428:ff.c          **** 		INIT_BUF(dj);
 9301               	.LM947:
 9302 30b2 CE01      		movw r24,r28
 9303 30b4 4796      		adiw r24,23
 9304 30b6 9E8B      		std Y+22,r25
 9305 30b8 8D8B      		std Y+21,r24
3429:ff.c          **** 		res = follow_path(&dj, path);		/* Follow the file path */
 9307               	.LM948:
 9308 30ba 6BA1      		ldd r22,Y+35
 9309 30bc 7CA1      		ldd r23,Y+36
 9310 30be CE01      		movw r24,r28
 9311 30c0 0196      		adiw r24,1
 9312 30c2 0E94 0000 		call follow_path
3433:ff.c          **** 		if (res == FR_OK) {
 9314               	.LM949:
 9315 30c6 8111      		cpse r24,__zero_reg__
 9316 30c8 00C0      		rjmp .L645
3434:ff.c          **** 			dir = dj.dir;
 9318               	.LM950:
 9319 30ca EB89      		ldd r30,Y+19
 9320 30cc FC89      		ldd r31,Y+20
3435:ff.c          **** 			if (!dir) {						/* Is it a root directory? */
 9322               	.LM951:
 9323 30ce 3097      		sbiw r30,0
 9324 30d0 01F0      		breq .L646
3438:ff.c          **** 				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
 9326               	.LM952:
 9327 30d2 402F      		mov r20,r16
 9328 30d4 4772      		andi r20,lo8(39)
3439:ff.c          **** 				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
 9330               	.LM953:
 9331 30d6 842F      		mov r24,r20
 9332 30d8 8095      		com r24
 9333 30da 9385      		ldd r25,Z+11
 9334 30dc 8923      		and r24,r25
 9335 30de 4123      		and r20,r17
 9336 30e0 842B      		or r24,r20
 9337 30e2 8387      		std Z+11,r24
3440:ff.c          **** 				dj.fs->wflag = 1;
 9339               	.LM954:
 9340 30e4 8981      		ldd r24,Y+1
 9341 30e6 9A81      		ldd r25,Y+2
 9342 30e8 21E0      		ldi r18,lo8(1)
 9343 30ea FC01      		movw r30,r24
 9344 30ec 2483      		std Z+4,r18
3441:ff.c          **** 				res = sync_fs(dj.fs);
 9346               	.LM955:
 9347 30ee 0E94 0000 		call sync_fs
 9348 30f2 00C0      		rjmp .L645
 9349               	.L646:
3436:ff.c          **** 				res = FR_INVALID_NAME;
 9351               	.LM956:
 9352 30f4 86E0      		ldi r24,lo8(6)
 9353               	.L645:
 9354               	/* epilogue start */
3447:ff.c          **** }
 9356               	.LM957:
 9357 30f6 A496      		adiw r28,36
 9358 30f8 0FB6      		in __tmp_reg__,__SREG__
 9359 30fa F894      		cli
 9360 30fc DEBF      		out __SP_H__,r29
 9361 30fe 0FBE      		out __SREG__,__tmp_reg__
 9362 3100 CDBF      		out __SP_L__,r28
 9363 3102 DF91      		pop r29
 9364 3104 CF91      		pop r28
 9365 3106 1F91      		pop r17
 9366 3108 0F91      		pop r16
 9367 310a 0895      		ret
 9375               	.Lscope35:
 9377               		.stabd	78,0,0
 9381               	.global	f_utime
 9383               	f_utime:
 9384               		.stabd	46,0,0
3460:ff.c          **** {
 9386               	.LM958:
 9387               	.LFBB36:
 9388 310c 0F93      		push r16
 9389 310e 1F93      		push r17
 9390 3110 CF93      		push r28
 9391 3112 DF93      		push r29
 9392 3114 CDB7      		in r28,__SP_L__
 9393 3116 DEB7      		in r29,__SP_H__
 9394 3118 A497      		sbiw r28,36
 9395 311a 0FB6      		in __tmp_reg__,__SREG__
 9396 311c F894      		cli
 9397 311e DEBF      		out __SP_H__,r29
 9398 3120 0FBE      		out __SREG__,__tmp_reg__
 9399 3122 CDBF      		out __SP_L__,r28
 9400               	/* prologue: function */
 9401               	/* frame size = 36 */
 9402               	/* stack size = 40 */
 9403               	.L__stack_usage = 40
 9404 3124 9CA3      		std Y+36,r25
 9405 3126 8BA3      		std Y+35,r24
 9406 3128 8B01      		movw r16,r22
3467:ff.c          **** 	res = chk_mounted(&path, &dj.fs, 1);
 9408               	.LM959:
 9409 312a 41E0      		ldi r20,lo8(1)
 9410 312c BE01      		movw r22,r28
 9411 312e 6F5F      		subi r22,-1
 9412 3130 7F4F      		sbci r23,-1
 9413 3132 CE01      		movw r24,r28
 9414 3134 8396      		adiw r24,35
 9415 3136 0E94 0000 		call chk_mounted
3468:ff.c          **** 	if (res == FR_OK) {
 9417               	.LM960:
 9418 313a 8111      		cpse r24,__zero_reg__
 9419 313c 00C0      		rjmp .L648
3469:ff.c          **** 		INIT_BUF(dj);
 9421               	.LM961:
 9422 313e CE01      		movw r24,r28
 9423 3140 4796      		adiw r24,23
 9424 3142 9E8B      		std Y+22,r25
 9425 3144 8D8B      		std Y+21,r24
3470:ff.c          **** 		res = follow_path(&dj, path);	/* Follow the file path */
 9427               	.LM962:
 9428 3146 6BA1      		ldd r22,Y+35
 9429 3148 7CA1      		ldd r23,Y+36
 9430 314a CE01      		movw r24,r28
 9431 314c 0196      		adiw r24,1
 9432 314e 0E94 0000 		call follow_path
3474:ff.c          **** 		if (res == FR_OK) {
 9434               	.LM963:
 9435 3152 8111      		cpse r24,__zero_reg__
 9436 3154 00C0      		rjmp .L648
3475:ff.c          **** 			dir = dj.dir;
 9438               	.LM964:
 9439 3156 EB89      		ldd r30,Y+19
 9440 3158 FC89      		ldd r31,Y+20
3476:ff.c          **** 			if (!dir) {					/* Root directory */
 9442               	.LM965:
 9443 315a 3097      		sbiw r30,0
 9444 315c 01F0      		breq .L649
3479:ff.c          **** 				ST_WORD(dir+DIR_WrtTime, fno->ftime);
 9446               	.LM966:
 9447 315e D801      		movw r26,r16
 9448 3160 1696      		adiw r26,6
 9449 3162 8C91      		ld r24,X
 9450 3164 1697      		sbiw r26,6
 9451 3166 868B      		std Z+22,r24
 9452 3168 1796      		adiw r26,7
 9453 316a 8C91      		ld r24,X
 9454 316c 1797      		sbiw r26,7
 9455 316e 878B      		std Z+23,r24
3480:ff.c          **** 				ST_WORD(dir+DIR_WrtDate, fno->fdate);
 9457               	.LM967:
 9458 3170 1496      		adiw r26,4
 9459 3172 8C91      		ld r24,X
 9460 3174 1497      		sbiw r26,4
 9461 3176 808F      		std Z+24,r24
 9462 3178 1596      		adiw r26,5
 9463 317a 8C91      		ld r24,X
 9464 317c 818F      		std Z+25,r24
3481:ff.c          **** 				dj.fs->wflag = 1;
 9466               	.LM968:
 9467 317e 8981      		ldd r24,Y+1
 9468 3180 9A81      		ldd r25,Y+2
 9469 3182 21E0      		ldi r18,lo8(1)
 9470 3184 FC01      		movw r30,r24
 9471 3186 2483      		std Z+4,r18
3482:ff.c          **** 				res = sync_fs(dj.fs);
 9473               	.LM969:
 9474 3188 0E94 0000 		call sync_fs
 9475 318c 00C0      		rjmp .L648
 9476               	.L649:
3477:ff.c          **** 				res = FR_INVALID_NAME;
 9478               	.LM970:
 9479 318e 86E0      		ldi r24,lo8(6)
 9480               	.L648:
 9481               	/* epilogue start */
3488:ff.c          **** }
 9483               	.LM971:
 9484 3190 A496      		adiw r28,36
 9485 3192 0FB6      		in __tmp_reg__,__SREG__
 9486 3194 F894      		cli
 9487 3196 DEBF      		out __SP_H__,r29
 9488 3198 0FBE      		out __SREG__,__tmp_reg__
 9489 319a CDBF      		out __SP_L__,r28
 9490 319c DF91      		pop r29
 9491 319e CF91      		pop r28
 9492 31a0 1F91      		pop r17
 9493 31a2 0F91      		pop r16
 9494 31a4 0895      		ret
 9502               	.Lscope36:
 9504               		.stabd	78,0,0
 9508               	.global	f_rename
 9510               	f_rename:
 9511               		.stabd	46,0,0
3501:ff.c          **** {
 9513               	.LM972:
 9514               	.LFBB37:
 9515 31a6 EF92      		push r14
 9516 31a8 FF92      		push r15
 9517 31aa 0F93      		push r16
 9518 31ac 1F93      		push r17
 9519 31ae CF93      		push r28
 9520 31b0 DF93      		push r29
 9521 31b2 CDB7      		in r28,__SP_L__
 9522 31b4 DEB7      		in r29,__SP_H__
 9523 31b6 CF54      		subi r28,79
 9524 31b8 D109      		sbc r29,__zero_reg__
 9525 31ba 0FB6      		in __tmp_reg__,__SREG__
 9526 31bc F894      		cli
 9527 31be DEBF      		out __SP_H__,r29
 9528 31c0 0FBE      		out __SREG__,__tmp_reg__
 9529 31c2 CDBF      		out __SP_L__,r28
 9530               	/* prologue: function */
 9531               	/* frame size = 79 */
 9532               	/* stack size = 85 */
 9533               	.L__stack_usage = 85
 9534 31c4 6096      		adiw r28,78-62
 9535 31c6 9FAF      		std Y+63,r25
 9536 31c8 8EAF      		std Y+62,r24
 9537 31ca 6097      		sbiw r28,78-62
 9538 31cc 8B01      		movw r16,r22
3509:ff.c          **** 	res = chk_mounted(&path_old, &djo.fs, 1);
 9540               	.LM973:
 9541 31ce 41E0      		ldi r20,lo8(1)
 9542 31d0 BE01      		movw r22,r28
 9543 31d2 695E      		subi r22,-23
 9544 31d4 7F4F      		sbci r23,-1
 9545 31d6 CE01      		movw r24,r28
 9546 31d8 825B      		subi r24,-78
 9547 31da 9F4F      		sbci r25,-1
 9548 31dc 0E94 0000 		call chk_mounted
3510:ff.c          **** 	if (res == FR_OK) {
 9550               	.LM974:
 9551 31e0 8111      		cpse r24,__zero_reg__
 9552 31e2 00C0      		rjmp .L663
3511:ff.c          **** 		djn.fs = djo.fs;
 9554               	.LM975:
 9555 31e4 8F89      		ldd r24,Y+23
 9556 31e6 988D      		ldd r25,Y+24
 9557 31e8 9A83      		std Y+2,r25
 9558 31ea 8983      		std Y+1,r24
3512:ff.c          **** 		INIT_BUF(djo);
 9560               	.LM976:
 9561 31ec CE01      		movw r24,r28
 9562 31ee 8E5B      		subi r24,-66
 9563 31f0 9F4F      		sbci r25,-1
 9564 31f2 9CA7      		std Y+44,r25
 9565 31f4 8BA7      		std Y+43,r24
3513:ff.c          **** 		res = follow_path(&djo, path_old);		/* Check old object */
 9567               	.LM977:
 9568 31f6 6096      		adiw r28,78-62
 9569 31f8 6EAD      		ldd r22,Y+62
 9570 31fa 7FAD      		ldd r23,Y+63
 9571 31fc 6097      		sbiw r28,78-62
 9572 31fe CE01      		movw r24,r28
 9573 3200 4796      		adiw r24,23
 9574 3202 0E94 0000 		call follow_path
3519:ff.c          **** 		if (res == FR_OK) {						/* Old object is found */
 9576               	.LM978:
 9577 3206 8111      		cpse r24,__zero_reg__
 9578 3208 00C0      		rjmp .L663
3520:ff.c          **** 			if (!djo.dir) {						/* Is root dir? */
 9580               	.LM979:
 9581 320a 89A5      		ldd r24,Y+41
 9582 320c 9AA5      		ldd r25,Y+42
 9583 320e 0097      		sbiw r24,0
 9584 3210 01F4      		brne .+2
 9585 3212 00C0      		rjmp .L658
3523:ff.c          **** 				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
 9587               	.LM980:
 9588 3214 BC01      		movw r22,r24
 9589 3216 655F      		subi r22,-11
 9590 3218 7F4F      		sbci r23,-1
 9591 321a 45E1      		ldi r20,lo8(21)
 9592 321c 50E0      		ldi r21,0
 9593 321e CE01      		movw r24,r28
 9594 3220 8D96      		adiw r24,45
 9595 3222 0E94 0000 		call mem_cpy
3524:ff.c          **** 				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
 9597               	.LM981:
 9598 3226 46E1      		ldi r20,lo8(22)
 9599 3228 50E0      		ldi r21,0
 9600 322a BE01      		movw r22,r28
 9601 322c 695E      		subi r22,-23
 9602 322e 7F4F      		sbci r23,-1
 9603 3230 CE01      		movw r24,r28
 9604 3232 0196      		adiw r24,1
 9605 3234 0E94 0000 		call mem_cpy
3525:ff.c          **** 				res = follow_path(&djn, path_new);
 9607               	.LM982:
 9608 3238 B801      		movw r22,r16
 9609 323a CE01      		movw r24,r28
 9610 323c 0196      		adiw r24,1
 9611 323e 0E94 0000 		call follow_path
3526:ff.c          **** 				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
 9613               	.LM983:
 9614 3242 8823      		tst r24
 9615 3244 01F4      		brne .+2
 9616 3246 00C0      		rjmp .L659
3527:ff.c          **** 				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
 9618               	.LM984:
 9619 3248 8430      		cpi r24,lo8(4)
 9620 324a 01F0      		breq .+2
 9621 324c 00C0      		rjmp .L663
3529:ff.c          **** 					res = dir_register(&djn);			/* Register the new entry */
 9623               	.LM985:
 9624 324e CE01      		movw r24,r28
 9625 3250 0196      		adiw r24,1
 9626 3252 0E94 0000 		call dir_register
3530:ff.c          **** 					if (res == FR_OK) {
 9628               	.LM986:
 9629 3256 8111      		cpse r24,__zero_reg__
 9630 3258 00C0      		rjmp .L663
3531:ff.c          **** 						dir = djn.dir;					/* Copy object information except for name */
 9632               	.LM987:
 9633 325a EB88      		ldd r14,Y+19
 9634 325c FC88      		ldd r15,Y+20
3532:ff.c          **** 						mem_cpy(dir+13, buf+2, 19);
 9636               	.LM988:
 9637 325e 43E1      		ldi r20,lo8(19)
 9638 3260 50E0      		ldi r21,0
 9639 3262 BE01      		movw r22,r28
 9640 3264 615D      		subi r22,-47
 9641 3266 7F4F      		sbci r23,-1
 9642 3268 C701      		movw r24,r14
 9643 326a 0D96      		adiw r24,13
 9644 326c 0E94 0000 		call mem_cpy
3533:ff.c          **** 						dir[DIR_Attr] = buf[0] | AM_ARC;
 9646               	.LM989:
 9647 3270 8DA5      		ldd r24,Y+45
 9648 3272 8062      		ori r24,lo8(32)
 9649 3274 D701      		movw r26,r14
 9650 3276 1B96      		adiw r26,11
 9651 3278 8C93      		st X,r24
3534:ff.c          **** 						djo.fs->wflag = 1;
 9653               	.LM990:
 9654 327a 0F89      		ldd r16,Y+23
 9655 327c 188D      		ldd r17,Y+24
 9656 327e 81E0      		ldi r24,lo8(1)
 9657 3280 F801      		movw r30,r16
 9658 3282 8483      		std Z+4,r24
3535:ff.c          **** 						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the direct
 9660               	.LM991:
 9661 3284 4D8D      		ldd r20,Y+29
 9662 3286 5E8D      		ldd r21,Y+30
 9663 3288 6F8D      		ldd r22,Y+31
 9664 328a 78A1      		ldd r23,Y+32
 9665 328c 8F81      		ldd r24,Y+7
 9666 328e 9885      		ldd r25,Y+8
 9667 3290 A985      		ldd r26,Y+9
 9668 3292 BA85      		ldd r27,Y+10
 9669 3294 4817      		cp r20,r24
 9670 3296 5907      		cpc r21,r25
 9671 3298 6A07      		cpc r22,r26
 9672 329a 7B07      		cpc r23,r27
 9673 329c 01F4      		brne .+2
 9674 329e 00C0      		rjmp .L656
3535:ff.c          **** 						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the direct
 9676               	.LM992:
 9677 32a0 D701      		movw r26,r14
 9678 32a2 1B96      		adiw r26,11
 9679 32a4 8C91      		ld r24,X
 9680 32a6 84FF      		sbrs r24,4
 9681 32a8 00C0      		rjmp .L656
3536:ff.c          **** 							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
 9683               	.LM993:
 9684 32aa B701      		movw r22,r14
 9685 32ac 8081      		ld r24,Z
 9686 32ae 0E94 0000 		call ld_clust.isra.0
 9687 32b2 AB01      		movw r20,r22
 9688 32b4 BC01      		movw r22,r24
 9689 32b6 C801      		movw r24,r16
 9690 32b8 0E94 0000 		call clust2sect
 9691 32bc AB01      		movw r20,r22
 9692 32be BC01      		movw r22,r24
3537:ff.c          **** 							if (!dw) {
 9694               	.LM994:
 9695 32c0 4115      		cp r20,__zero_reg__
 9696 32c2 5105      		cpc r21,__zero_reg__
 9697 32c4 6105      		cpc r22,__zero_reg__
 9698 32c6 7105      		cpc r23,__zero_reg__
 9699 32c8 01F4      		brne .+2
 9700 32ca 00C0      		rjmp .L660
3540:ff.c          **** 								res = move_window(djo.fs, dw);
 9702               	.LM995:
 9703 32cc C801      		movw r24,r16
 9704 32ce 0E94 0000 		call move_window
3541:ff.c          **** 								dir = djo.fs->win+SZ_DIR;	/* .. entry */
 9706               	.LM996:
 9707 32d2 EF89      		ldd r30,Y+23
 9708 32d4 F88D      		ldd r31,Y+24
3542:ff.c          **** 								if (res == FR_OK && dir[1] == '.') {
 9710               	.LM997:
 9711 32d6 8111      		cpse r24,__zero_reg__
 9712 32d8 00C0      		rjmp .L663
3542:ff.c          **** 								if (res == FR_OK && dir[1] == '.') {
 9714               	.LM998:
 9715 32da DF01      		movw r26,r30
 9716 32dc AD5A      		subi r26,-83
 9717 32de BF4F      		sbci r27,-1
 9718 32e0 8C91      		ld r24,X
 9719 32e2 8E32      		cpi r24,lo8(46)
 9720 32e4 01F4      		brne .L656
3543:ff.c          **** 									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
 9722               	.LM999:
 9723 32e6 2081      		ld r18,Z
 9724 32e8 8F81      		ldd r24,Y+7
 9725 32ea 9885      		ldd r25,Y+8
 9726 32ec A985      		ldd r26,Y+9
 9727 32ee BA85      		ldd r27,Y+10
 9728 32f0 2330      		cpi r18,lo8(3)
 9729 32f2 01F4      		brne .L654
3543:ff.c          **** 									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
 9731               	.LM1000:
 9732 32f4 46A1      		ldd r20,Z+38
 9733 32f6 57A1      		ldd r21,Z+39
 9734 32f8 60A5      		ldd r22,Z+40
 9735 32fa 71A5      		ldd r23,Z+41
 9736 32fc 8417      		cp r24,r20
 9737 32fe 9507      		cpc r25,r21
 9738 3300 A607      		cpc r26,r22
 9739 3302 B707      		cpc r27,r23
 9740 3304 01F0      		breq .L661
 9741               	.L654:
3543:ff.c          **** 									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
 9743               	.LM1001:
 9744 3306 AC01      		movw r20,r24
 9745 3308 BD01      		movw r22,r26
 9746 330a 00C0      		rjmp .L655
 9747               	.L661:
3543:ff.c          **** 									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
 9749               	.LM1002:
 9750 330c 40E0      		ldi r20,0
 9751 330e 50E0      		ldi r21,0
 9752 3310 BA01      		movw r22,r20
 9753               	.L655:
 9754               	.LBB128:
 9755               	.LBB129:
1261:ff.c          **** 	ST_WORD(dir+DIR_FstClusLO, cl);
 9757               	.LM1003:
 9758 3312 9F01      		movw r18,r30
 9759 3314 2459      		subi r18,-108
 9760 3316 3F4F      		sbci r19,-1
 9761 3318 D901      		movw r26,r18
 9762 331a 4C93      		st X,r20
 9763 331c 9F01      		movw r18,r30
 9764 331e 2359      		subi r18,-109
 9765 3320 3F4F      		sbci r19,-1
 9766 3322 D901      		movw r26,r18
 9767 3324 5C93      		st X,r21
1262:ff.c          **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 9769               	.LM1004:
 9770 3326 AB01      		movw r20,r22
 9771 3328 6627      		clr r22
 9772 332a 7727      		clr r23
 9773 332c 9F01      		movw r18,r30
 9774 332e 2A59      		subi r18,-102
 9775 3330 3F4F      		sbci r19,-1
 9776 3332 D901      		movw r26,r18
 9777 3334 4C93      		st X,r20
 9778 3336 9F01      		movw r18,r30
 9779 3338 2959      		subi r18,-103
 9780 333a 3F4F      		sbci r19,-1
 9781 333c D901      		movw r26,r18
 9782 333e 5C93      		st X,r21
 9783               	.LBE129:
 9784               	.LBE128:
3545:ff.c          **** 									djo.fs->wflag = 1;
 9786               	.LM1005:
 9787 3340 81E0      		ldi r24,lo8(1)
 9788 3342 8483      		std Z+4,r24
 9789 3344 00C0      		rjmp .L656
 9790               	.L657:
3552:ff.c          **** 								res = sync_fs(djo.fs);
 9792               	.LM1006:
 9793 3346 8F89      		ldd r24,Y+23
 9794 3348 988D      		ldd r25,Y+24
 9795 334a 0E94 0000 		call sync_fs
 9796 334e 00C0      		rjmp .L663
 9797               	.L658:
3521:ff.c          **** 				res = FR_NO_FILE;
 9799               	.LM1007:
 9800 3350 84E0      		ldi r24,lo8(4)
 9801 3352 00C0      		rjmp .L663
 9802               	.L659:
3526:ff.c          **** 				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
 9804               	.LM1008:
 9805 3354 88E0      		ldi r24,lo8(8)
 9806 3356 00C0      		rjmp .L663
 9807               	.L660:
3538:ff.c          **** 								res = FR_INT_ERR;
 9809               	.LM1009:
 9810 3358 82E0      		ldi r24,lo8(2)
 9811 335a 00C0      		rjmp .L663
 9812               	.L656:
3550:ff.c          **** 							res = dir_remove(&djo);		/* Remove old entry */
 9814               	.LM1010:
 9815 335c CE01      		movw r24,r28
 9816 335e 4796      		adiw r24,23
 9817 3360 0E94 0000 		call dir_remove
3551:ff.c          **** 							if (res == FR_OK)
 9819               	.LM1011:
 9820 3364 8823      		tst r24
 9821 3366 01F0      		breq .L657
 9822               	.L663:
 9823               	/* epilogue start */
 9825               	.LM1012:
 9826 3368 C15B      		subi r28,-79
 9827 336a DF4F      		sbci r29,-1
 9828 336c 0FB6      		in __tmp_reg__,__SREG__
 9829 336e F894      		cli
 9830 3370 DEBF      		out __SP_H__,r29
 9831 3372 0FBE      		out __SREG__,__tmp_reg__
 9832 3374 CDBF      		out __SP_L__,r28
 9833 3376 DF91      		pop r29
 9834 3378 CF91      		pop r28
 9835 337a 1F91      		pop r17
 9836 337c 0F91      		pop r16
 9837 337e FF90      		pop r15
 9838 3380 EF90      		pop r14
 9839 3382 0895      		ret
 9849               	.Lscope37:
 9851               		.stabd	78,0,0
 9852               		.local	FatFs
 9853               		.comm	FatFs,2,1
 9854               		.local	Fsid
 9855               		.comm	Fsid,2,1
 9859               	.Letext0:
 9860               		.ident	"GCC: (Fedora 4.7.3-0.1.fc19) 4.7.3 20130216 (prerelease)"
 9861               	.global __do_copy_data
 9862               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 ff.c
     /tmp/ccscE4lZ.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccscE4lZ.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccscE4lZ.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccscE4lZ.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccscE4lZ.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccscE4lZ.s:59     .text:0000000000000000 mem_cpy
     /tmp/ccscE4lZ.s:105    .text:0000000000000016 get_fileinfo
     /tmp/ccscE4lZ.s:288    .text:00000000000000f6 validate
     /tmp/ccscE4lZ.s:351    .text:0000000000000134 ld_clust.isra.0
     /tmp/ccscE4lZ.s:411    .text:0000000000000170 check_fs
     /tmp/ccscE4lZ.s:565    .text:0000000000000250 chk_mounted
                             .bss:0000000000000000 FatFs
     /tmp/ccscE4lZ.s:9853   .bss:0000000000000002 Fsid
     /tmp/ccscE4lZ.s:1664   .text:0000000000000914 sync_window
     /tmp/ccscE4lZ.s:1821   .text:00000000000009e6 sync_fs
     /tmp/ccscE4lZ.s:2016   .text:0000000000000aec move_window
     /tmp/ccscE4lZ.s:2105   .text:0000000000000b52 clust2sect
     /tmp/ccscE4lZ.s:2179   .text:0000000000000baa get_fat
     /tmp/ccscE4lZ.s:2466   .text:0000000000000d62 dir_sdi
     /tmp/ccscE4lZ.s:2712   .text:0000000000000ea8 dir_remove
     /tmp/ccscE4lZ.s:2782   .text:0000000000000ee4 put_fat
     /tmp/ccscE4lZ.s:3159   .text:0000000000001118 create_chain
     /tmp/ccscE4lZ.s:3469   .text:00000000000012c6 dir_next
     /tmp/ccscE4lZ.s:3867   .text:00000000000014c4 follow_path
     /tmp/ccscE4lZ.s:4425   .text:0000000000001730 dir_read.constprop.10
     /tmp/ccscE4lZ.s:4538   .text:000000000000179e dir_register
     /tmp/ccscE4lZ.s:4679   .text:0000000000001832 remove_chain
     /tmp/ccscE4lZ.s:4876   .text:0000000000001922 f_mount
     /tmp/ccscE4lZ.s:4939   .text:000000000000194e f_open
     /tmp/ccscE4lZ.s:5371   .text:0000000000001b76 f_read
     /tmp/ccscE4lZ.s:5921   .text:0000000000001ea2 f_write
     /tmp/ccscE4lZ.s:6589   .text:000000000000228c f_sync
     /tmp/ccscE4lZ.s:6759   .text:000000000000234e f_close
     /tmp/ccscE4lZ.s:6801   .text:0000000000002366 f_lseek
     /tmp/ccscE4lZ.s:7456   .text:000000000000273a f_opendir
     /tmp/ccscE4lZ.s:7616   .text:00000000000027fe f_readdir
     /tmp/ccscE4lZ.s:7751   .text:00000000000028a4 f_stat
     /tmp/ccscE4lZ.s:7858   .text:0000000000002926 f_getfree
     /tmp/ccscE4lZ.s:8267   .text:0000000000002b6e f_truncate
     /tmp/ccscE4lZ.s:8480   .text:0000000000002c7e f_unlink
     /tmp/ccscE4lZ.s:8726   .text:0000000000002db8 f_mkdir
     /tmp/ccscE4lZ.s:9262   .text:000000000000307e f_chmod
     /tmp/ccscE4lZ.s:9383   .text:000000000000310c f_utime
     /tmp/ccscE4lZ.s:9510   .text:00000000000031a6 f_rename

UNDEFINED SYMBOLS
disk_status
disk_read
disk_initialize
__muluhisi3
__udivmodsi4
disk_write
disk_ioctl
get_fattime
__do_copy_data
__do_clear_bss
